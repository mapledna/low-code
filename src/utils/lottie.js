/* eslint-disable */
export default function lottie(window) {
  const svgNS = 'http://www.w3.org/2000/svg'; let locationHref = ''; const initialDefaultFrame = -999999; let subframeEnabled = !0; let expressionsPlugin; const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent); const cachedColors = {}; const bm_rounder = Math.round; let bm_rnd; const bm_pow = Math.pow; const bm_sqrt = Math.sqrt; const bm_abs = Math.abs; const bm_floor = Math.floor; const bm_max = Math.max; const bm_min = Math.min; const blitter = 10; const BMMath = {}; function ProjectInterface() { return {} }!(function () { let t; const e = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'atan2', 'ceil', 'cbrt', 'expm1', 'clz32', 'cos', 'cosh', 'exp', 'floor', 'fround', 'hypot', 'imul', 'log', 'log1p', 'log2', 'log10', 'max', 'min', 'pow', 'random', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc', 'E', 'LN10', 'LN2', 'LOG10E', 'LOG2E', 'PI', 'SQRT1_2', 'SQRT2']; const r = e.length; for (t = 0; t < r; t += 1)BMMath[e[t]] = Math[e[t]] }()), BMMath.random = Math.random, BMMath.abs = function (t) { if (typeof t === 'object' && t.length) { let e; const r = createSizedArray(t.length); const i = t.length; for (e = 0; e < i; e += 1)r[e] = Math.abs(t[e]); return r } return Math.abs(t) }; let defaultCurveSegments = 150; const degToRads = Math.PI / 180; const roundCorner = 0.5519; function roundValues(t) { bm_rnd = t ? Math.round : function (t) { return t } } function styleDiv(t) { t.style.position = 'absolute', t.style.top = 0, t.style.left = 0, t.style.display = 'block', t.style.transformOrigin = t.style.webkitTransformOrigin = '0 0', t.style.backfaceVisibility = t.style.webkitBackfaceVisibility = 'visible', t.style.transformStyle = t.style.webkitTransformStyle = t.style.mozTransformStyle = 'preserve-3d' } function BMEnterFrameEvent(t, e, r, i) { this.type = t, this.currentTime = e, this.totalTime = r, this.direction = i < 0 ? -1 : 1 } function BMCompleteEvent(t, e) { this.type = t, this.direction = e < 0 ? -1 : 1 } function BMCompleteLoopEvent(t, e, r, i) { this.type = t, this.currentLoop = r, this.totalLoops = e, this.direction = i < 0 ? -1 : 1 } function BMSegmentStartEvent(t, e, r) { this.type = t, this.firstFrame = e, this.totalFrames = r } function BMDestroyEvent(t, e) { this.type = t, this.target = e } function BMRenderFrameErrorEvent(t, e) { this.type = 'renderFrameError', this.nativeError = t, this.currentTime = e } function BMConfigErrorEvent(t) { this.type = 'configError', this.nativeError = t } function BMAnimationConfigErrorEvent(t, e) { this.type = t, this.nativeError = e, this.currentTime = currentTime }roundValues(!1); const createElementID = (G = 0, function () { return `__lottie_element_${++G}` }); let G; function HSVtoRGB(t, e, r) { let i; let s; let a; let n; let o; let h; let l; let p; switch (h = r * (1 - e), l = r * (1 - (o = 6 * t - (n = Math.floor(6 * t))) * e), p = r * (1 - (1 - o) * e), n % 6) { case 0: i = r, s = p, a = h; break; case 1: i = l, s = r, a = h; break; case 2: i = h, s = r, a = p; break; case 3: i = h, s = l, a = r; break; case 4: i = p, s = h, a = r; break; case 5: i = r, s = h, a = l } return [i, s, a] } function RGBtoHSV(t, e, r) { let i; const s = Math.max(t, e, r); const a = Math.min(t, e, r); const n = s - a; const o = s === 0 ? 0 : n / s; const h = s / 255; switch (s) { case a: i = 0; break; case t: i = e - r + n * (e < r ? 6 : 0), i /= 6 * n; break; case e: i = r - t + 2 * n, i /= 6 * n; break; case r: i = t - e + 4 * n, i /= 6 * n } return [i, o, h] } function addSaturationToRGB(t, e) { const r = RGBtoHSV(255 * t[0], 255 * t[1], 255 * t[2]); return r[1] += e, r[1] > 1 ? r[1] = 1 : r[1] <= 0 && (r[1] = 0), HSVtoRGB(r[0], r[1], r[2]) } function addBrightnessToRGB(t, e) { const r = RGBtoHSV(255 * t[0], 255 * t[1], 255 * t[2]); return r[2] += e, r[2] > 1 ? r[2] = 1 : r[2] < 0 && (r[2] = 0), HSVtoRGB(r[0], r[1], r[2]) } function addHueToRGB(t, e) { const r = RGBtoHSV(255 * t[0], 255 * t[1], 255 * t[2]); return r[0] += e / 360, r[0] > 1 ? r[0] -= 1 : r[0] < 0 && (r[0] += 1), HSVtoRGB(r[0], r[1], r[2]) } const rgbToHex = (function () { let t; let e; const i = []; for (t = 0; t < 256; t += 1)e = t.toString(16), i[t] = e.length == 1 ? `0${e}` : e; return function (t, e, r) { return t < 0 && (t = 0), e < 0 && (e = 0), r < 0 && (r = 0), `#${i[t]}${i[e]}${i[r]}` } }()); function BaseEvent() {}BaseEvent.prototype = { triggerEvent(t, e) { if (this._cbs[t]) for (let r = this._cbs[t].length, i = 0; i < r; i++) this._cbs[t][i](e) }, addEventListener(t, e) { return this._cbs[t] || (this._cbs[t] = []), this._cbs[t].push(e), function () { this.removeEventListener(t, e) }.bind(this) }, removeEventListener(t, e) { if (e) { if (this._cbs[t]) { for (let r = 0, i = this._cbs[t].length; r < i;) this._cbs[t][r] === e && (this._cbs[t].splice(r, 1), r -= 1, i -= 1), r += 1; this._cbs[t].length || (this._cbs[t] = null) } } else this._cbs[t] = null } }; const createTypedArray = typeof Uint8ClampedArray === 'function' && typeof Float32Array === 'function' ? function (t, e) { return t === 'float32' ? new Float32Array(e) : t === 'int16' ? new Int16Array(e) : t === 'uint8c' ? new Uint8ClampedArray(e) : void 0 } : function (t, e) { let r; let i = 0; const s = []; switch (t) { case 'int16': case 'uint8c': r = 1; break; default: r = 1.1 } for (i = 0; i < e; i += 1)s.push(r); return s }; function createSizedArray(t) { return Array.apply(null, { length: t }) } function createNS(t) { return document.createElementNS(svgNS, t) } function createTag(t) { return document.createElement(t) } function DynamicPropertyContainer() {}DynamicPropertyContainer.prototype = { addDynamicProperty(t) { this.dynamicProperties.indexOf(t) === -1 && (this.dynamicProperties.push(t), this.container.addDynamicProperty(this), this._isAnimated = !0) }, iterateDynamicProperties() { this._mdf = !1; let t; const e = this.dynamicProperties.length; for (t = 0; t < e; t += 1) this.dynamicProperties[t].getValue(), this.dynamicProperties[t]._mdf && (this._mdf = !0) }, initDynamicPropertyContainer(t) { this.container = t, this.dynamicProperties = [], this._mdf = !1, this._isAnimated = !1 } }; const getBlendMode = (Pa = {
    0: 'source-over', 1: 'multiply', 2: 'screen', 3: 'overlay', 4: 'darken', 5: 'lighten', 6: 'color-dodge', 7: 'color-burn', 8: 'hard-light', 9: 'soft-light', 10: 'difference', 11: 'exclusion', 12: 'hue', 13: 'saturation', 14: 'color', 15: 'luminosity'
  }, function (t) { return Pa[t] || '' }); let Pa; var Matrix = (function () { const s = Math.cos; const a = Math.sin; const n = Math.tan; const i = Math.round; function t() { return this.props[0] = 1, this.props[1] = 0, this.props[2] = 0, this.props[3] = 0, this.props[4] = 0, this.props[5] = 1, this.props[6] = 0, this.props[7] = 0, this.props[8] = 0, this.props[9] = 0, this.props[10] = 1, this.props[11] = 0, this.props[12] = 0, this.props[13] = 0, this.props[14] = 0, this.props[15] = 1, this } function e(t) { if (t === 0) return this; const e = s(t); const r = a(t); return this._t(e, -r, 0, 0, r, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1) } function r(t) { if (t === 0) return this; const e = s(t); const r = a(t); return this._t(1, 0, 0, 0, 0, e, -r, 0, 0, r, e, 0, 0, 0, 0, 1) } function o(t) { if (t === 0) return this; const e = s(t); const r = a(t); return this._t(e, 0, r, 0, 0, 1, 0, 0, -r, 0, e, 0, 0, 0, 0, 1) } function h(t) { if (t === 0) return this; const e = s(t); const r = a(t); return this._t(e, -r, 0, 0, r, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1) } function l(t, e) { return this._t(1, e, t, 1, 0, 0) } function p(t, e) { return this.shear(n(t), n(e)) } function m(t, e) { const r = s(e); const i = a(e); return this._t(r, i, 0, 0, -i, r, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, n(t), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(r, -i, 0, 0, i, r, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1) } function f(t, e, r) { return r || r === 0 || (r = 1), t === 1 && e === 1 && r === 1 ? this : this._t(t, 0, 0, 0, 0, e, 0, 0, 0, 0, r, 0, 0, 0, 0, 1) } function c(t, e, r, i, s, a, n, o, h, l, p, m, f, c, d, u) { return this.props[0] = t, this.props[1] = e, this.props[2] = r, this.props[3] = i, this.props[4] = s, this.props[5] = a, this.props[6] = n, this.props[7] = o, this.props[8] = h, this.props[9] = l, this.props[10] = p, this.props[11] = m, this.props[12] = f, this.props[13] = c, this.props[14] = d, this.props[15] = u, this } function d(t, e, r) { return r = r || 0, t !== 0 || e !== 0 || r !== 0 ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, t, e, r, 1) : this } function u(t, e, r, i, s, a, n, o, h, l, p, m, f, c, d, u) { const y = this.props; if (t === 1 && e === 0 && r === 0 && i === 0 && s === 0 && a === 1 && n === 0 && o === 0 && h === 0 && l === 0 && p === 1 && m === 0) return y[12] = y[12] * t + y[15] * f, y[13] = y[13] * a + y[15] * c, y[14] = y[14] * p + y[15] * d, y[15] *= u, this._identityCalculated = !1, this; const g = y[0]; const v = y[1]; const b = y[2]; const E = y[3]; const x = y[4]; const S = y[5]; const P = y[6]; const _ = y[7]; const A = y[8]; const C = y[9]; const T = y[10]; const k = y[11]; const M = y[12]; const D = y[13]; const w = y[14]; const F = y[15]; return y[0] = g * t + v * s + b * h + E * f, y[1] = g * e + v * a + b * l + E * c, y[2] = g * r + v * n + b * p + E * d, y[3] = g * i + v * o + b * m + E * u, y[4] = x * t + S * s + P * h + _ * f, y[5] = x * e + S * a + P * l + _ * c, y[6] = x * r + S * n + P * p + _ * d, y[7] = x * i + S * o + P * m + _ * u, y[8] = A * t + C * s + T * h + k * f, y[9] = A * e + C * a + T * l + k * c, y[10] = A * r + C * n + T * p + k * d, y[11] = A * i + C * o + T * m + k * u, y[12] = M * t + D * s + w * h + F * f, y[13] = M * e + D * a + w * l + F * c, y[14] = M * r + D * n + w * p + F * d, y[15] = M * i + D * o + w * m + F * u, this._identityCalculated = !1, this } function y() { return this._identityCalculated || (this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1), this._identityCalculated = !0), this._identity } function g(t) { for (let e = 0; e < 16;) { if (t.props[e] !== this.props[e]) return !1; e += 1 } return !0 } function v(t) { let e; for (e = 0; e < 16; e += 1)t.props[e] = this.props[e] } function b(t) { let e; for (e = 0; e < 16; e += 1) this.props[e] = t[e] } function E(t, e, r) { return { x: t * this.props[0] + e * this.props[4] + r * this.props[8] + this.props[12], y: t * this.props[1] + e * this.props[5] + r * this.props[9] + this.props[13], z: t * this.props[2] + e * this.props[6] + r * this.props[10] + this.props[14] } } function x(t, e, r) { return t * this.props[0] + e * this.props[4] + r * this.props[8] + this.props[12] } function S(t, e, r) { return t * this.props[1] + e * this.props[5] + r * this.props[9] + this.props[13] } function P(t, e, r) { return t * this.props[2] + e * this.props[6] + r * this.props[10] + this.props[14] } function _() { const t = this.props[0] * this.props[5] - this.props[1] * this.props[4]; const e = this.props[5] / t; const r = -this.props[1] / t; const i = -this.props[4] / t; const s = this.props[0] / t; const a = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / t; const n = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / t; const o = new Matrix(); return o.props[0] = e, o.props[1] = r, o.props[4] = i, o.props[5] = s, o.props[12] = a, o.props[13] = n, o } function A(t) { return this.getInverseMatrix().applyToPointArray(t[0], t[1], t[2] || 0) } function C(t) { let e; const r = t.length; const i = []; for (e = 0; e < r; e += 1)i[e] = A(t[e]); return i } function T(t, e, r) { const i = createTypedArray('float32', 6); if (this.isIdentity())i[0] = t[0], i[1] = t[1], i[2] = e[0], i[3] = e[1], i[4] = r[0], i[5] = r[1]; else { const s = this.props[0]; const a = this.props[1]; const n = this.props[4]; const o = this.props[5]; const h = this.props[12]; const l = this.props[13]; i[0] = t[0] * s + t[1] * n + h, i[1] = t[0] * a + t[1] * o + l, i[2] = e[0] * s + e[1] * n + h, i[3] = e[0] * a + e[1] * o + l, i[4] = r[0] * s + r[1] * n + h, i[5] = r[0] * a + r[1] * o + l } return i } function k(t, e, r) { return this.isIdentity() ? [t, e, r] : [t * this.props[0] + e * this.props[4] + r * this.props[8] + this.props[12], t * this.props[1] + e * this.props[5] + r * this.props[9] + this.props[13], t * this.props[2] + e * this.props[6] + r * this.props[10] + this.props[14]] } function M(t, e) { if (this.isIdentity()) return `${t},${e}`; const r = this.props; return `${Math.round(100 * (t * r[0] + e * r[4] + r[12])) / 100},${Math.round(100 * (t * r[1] + e * r[5] + r[13])) / 100}` } function D() { for (var t = 0, e = this.props, r = 'matrix3d('; t < 16;)r += i(1e4 * e[t]) / 1e4, r += t === 15 ? ')' : ',', t += 1; return r } function w(t) { return t < 1e-6 && t > 0 || t > -1e-6 && t < 0 ? i(1e4 * t) / 1e4 : t } function F() { const t = this.props; return `matrix(${w(t[0])},${w(t[1])},${w(t[4])},${w(t[5])},${w(t[12])},${w(t[13])})` } return function () { this.reset = t, this.rotate = e, this.rotateX = r, this.rotateY = o, this.rotateZ = h, this.skew = p, this.skewFromAxis = m, this.shear = l, this.scale = f, this.setTransform = c, this.translate = d, this.transform = u, this.applyToPoint = E, this.applyToX = x, this.applyToY = S, this.applyToZ = P, this.applyToPointArray = k, this.applyToTriplePoints = T, this.applyToPointStringified = M, this.toCSS = D, this.to2dCSS = F, this.clone = v, this.cloneFromProps = b, this.equals = g, this.inversePoints = C, this.inversePoint = A, this.getInverseMatrix = _, this._t = this.transform, this.isIdentity = y, this._identity = !0, this._identityCalculated = !1, this.props = createTypedArray('float32', 16), this.reset() } }()); !(function (o, h) { let l; const p = this; const m = 256; const f = 6; const c = 'random'; const d = h.pow(m, f); const u = h.pow(2, 52); const y = 2 * u; const g = m - 1; function v(t) { let e; let r = t.length; const n = this; let i = 0; let s = n.i = n.j = 0; const a = n.S = []; for (r || (t = [r++]); i < m;)a[i] = i++; for (i = 0; i < m; i++)a[i] = a[s = g & s + t[i % r] + (e = a[i])], a[s] = e; n.g = function (t) { for (var e, r = 0, { i } = n, s = n.j, a = n.S; t--;)e = a[i = g & i + 1], r = r * m + a[g & (a[i] = a[s = g & s + e]) + (a[s] = e)]; return n.i = i, n.j = s, r } } function b(t, e) { return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e } function E(t, e) { for (var r, i = `${t}`, s = 0; s < i.length;)e[g & s] = g & (r ^= 19 * e[g & s]) + i.charCodeAt(s++); return x(e) } function x(t) { return String.fromCharCode.apply(0, t) }h[`seed${c}`] = function (t, e, r) { const i = []; const s = E((function t(e, r) { let i; const s = []; const a = typeof e; if (r && a == 'object') for (i in e) try { s.push(t(e[i], r - 1)) } catch (t) {} return s.length ? s : a == 'string' ? e : `${e}\0` }((e = !0 === e ? { entropy: !0 } : e || {}).entropy ? [t, x(o)] : t === null ? (function () { try { if (l) return x(l.randomBytes(m)); const t = new Uint8Array(m); return (p.crypto || p.msCrypto).getRandomValues(t), x(t) } catch (t) { const e = p.navigator; const r = e && e.plugins; return [+new Date(), p, r, p.screen, x(o)] } }()) : t, 3)), i); const a = new v(i); const n = function () { for (var t = a.g(f), e = d, r = 0; t < u;)t = (t + r) * m, e *= m, r = a.g(1); for (;y <= t;)t /= 2, e /= 2, r >>>= 1; return (t + r) / e }; return n.int32 = function () { return 0 | a.g(4) }, n.quick = function () { return a.g(4) / 4294967296 }, n.double = n, E(x(a.S), o), (e.pass || r || function (t, e, r, i) { return i && (i.S && b(i, a), t.state = function () { return b(a, {}) }), r ? (h[c] = t, e) : t })(n, s, 'global' in e ? e.global : this == h, e.state) }, E(h.random(), o) }([], BMMath)); const BezierFactory = (function () {
    const t = { getBezierEasing(t, e, r, i, s) { const a = s || (`bez_${t}_${e}_${r}_${i}`).replace(/\./g, 'p'); if (o[a]) return o[a]; const n = new h([t, e, r, i]); return o[a] = n } }; var o = {}; const l = 11; const p = 1 / (l - 1); const e = typeof Float32Array === 'function'; function i(t, e) { return 1 - 3 * e + 3 * t } function s(t, e) { return 3 * e - 6 * t } function a(t) { return 3 * t } function m(t, e, r) { return ((i(e, r) * t + s(e, r)) * t + a(e)) * t } function f(t, e, r) { return 3 * i(e, r) * t * t + 2 * s(e, r) * t + a(e) } function h(t) { this._p = t, this._mSampleValues = e ? new Float32Array(l) : new Array(l), this._precomputed = !1, this.get = this.get.bind(this) } return h.prototype = {
      get(t) { const e = this._p[0]; const r = this._p[1]; const i = this._p[2]; const s = this._p[3]; return this._precomputed || this._precompute(), e === r && i === s ? t : t === 0 ? 0 : t === 1 ? 1 : m(this._getTForX(t), r, s) }, _precompute() { const t = this._p[0]; const e = this._p[1]; const r = this._p[2]; const i = this._p[3]; this._precomputed = !0, t === e && r === i || this._calcSampleValues() }, _calcSampleValues() { for (let t = this._p[0], e = this._p[2], r = 0; r < l; ++r) this._mSampleValues[r] = m(r * p, t, e) }, _getTForX(t) { for (var e = this._p[0], r = this._p[2], i = this._mSampleValues, s = 0, a = 1, n = l - 1; a !== n && i[a] <= t; ++a)s += p; const o = s + (t - i[--a]) / (i[a + 1] - i[a]) * p; const h = f(o, e, r); return h >= 0.001 ? (function (t, e, r, i) { for (let s = 0; s < 4; ++s) { const a = f(e, r, i); if (a === 0) return e; e -= (m(e, r, i) - t) / a } return e }(t, o, e, r)) : h === 0 ? o : (function (t, e, r, i, s) { for (var a, n, o = 0; (a = m(n = e + (r - e) / 2, i, s) - t) > 0 ? r = n : e = n, Math.abs(a) > 1e-7 && ++o < 10;);return n }(t, s, s + p, e, r)) }
    }, t
  }()); function extendPrototype(t, e) { let r; let i; const s = t.length; for (r = 0; r < s; r += 1) for (const a in i = t[r].prototype)i.hasOwnProperty(a) && (e.prototype[a] = i[a]) } function getDescriptor(t, e) { return Object.getOwnPropertyDescriptor(t, e) } function createProxyFunction(t) { function e() {} return e.prototype = t, e } function bezFunction() {
    Math; function y(t, e, r, i, s, a) { const n = t * i + e * s + r * a - s * i - a * t - r * e; return n > -0.001 && n < 0.001 } const p = function (t, e, r, i) { let s; let a; let n; let o; let h; let l; const p = defaultCurveSegments; let m = 0; const f = []; const c = []; const d = bezier_length_pool.newElement(); for (n = r.length, s = 0; s < p; s += 1) { for (h = s / (p - 1), a = l = 0; a < n; a += 1)o = bm_pow(1 - h, 3) * t[a] + 3 * bm_pow(1 - h, 2) * h * r[a] + 3 * (1 - h) * bm_pow(h, 2) * i[a] + bm_pow(h, 3) * e[a], f[a] = o, c[a] !== null && (l += bm_pow(f[a] - c[a], 2)), c[a] = f[a]; l && (m += l = bm_sqrt(l)), d.percents[s] = h, d.lengths[s] = m } return d.addedLength = m, d }; function g(t) { this.segmentLength = 0, this.points = new Array(t) } function v(t, e) { this.partialLength = t, this.point = e } let b; const t = (b = {}, function (t, e, r, i) { const s = (`${t[0]}_${t[1]}_${e[0]}_${e[1]}_${r[0]}_${r[1]}_${i[0]}_${i[1]}`).replace(/\./g, 'p'); if (!b[s]) { let a; let n; let o; let h; let l; let p; let m; let f = defaultCurveSegments; let c = 0; let d = null; t.length === 2 && (t[0] != e[0] || t[1] != e[1]) && y(t[0], t[1], e[0], e[1], t[0] + r[0], t[1] + r[1]) && y(t[0], t[1], e[0], e[1], e[0] + i[0], e[1] + i[1]) && (f = 2); const u = new g(f); for (o = r.length, a = 0; a < f; a += 1) { for (m = createSizedArray(o), l = a / (f - 1), n = p = 0; n < o; n += 1)h = bm_pow(1 - l, 3) * t[n] + 3 * bm_pow(1 - l, 2) * l * (t[n] + r[n]) + 3 * (1 - l) * bm_pow(l, 2) * (e[n] + i[n]) + bm_pow(l, 3) * e[n], m[n] = h, d !== null && (p += bm_pow(m[n] - d[n], 2)); c += p = bm_sqrt(p), u.points[a] = new v(p, m), d = m }u.segmentLength = c, b[s] = u } return b[s] }); function M(t, e) { const r = e.percents; const i = e.lengths; const s = r.length; let a = bm_floor((s - 1) * t); const n = t * e.addedLength; let o = 0; if (a === s - 1 || a === 0 || n === i[a]) return r[a]; for (let h = i[a] > n ? -1 : 1, l = !0; l;) if (i[a] <= n && i[a + 1] > n ? (o = (n - i[a]) / (i[a + 1] - i[a]), l = !1) : a += h, a < 0 || s - 1 <= a) { if (a === s - 1) return r[a]; l = !1 } return r[a] + (r[a + 1] - r[a]) * o } const D = createTypedArray('float32', 8); return {
      getSegmentsLength(t) { let e; const r = segments_length_pool.newElement(); const i = t.c; const s = t.v; const a = t.o; const n = t.i; const o = t._length; const h = r.lengths; let l = 0; for (e = 0; e < o - 1; e += 1)h[e] = p(s[e], s[e + 1], a[e], n[e + 1]), l += h[e].addedLength; return i && o && (h[e] = p(s[e], s[0], a[e], n[0]), l += h[e].addedLength), r.totalLength = l, r }, getNewSegment(t, e, r, i, s, a, n) { let o; const h = M(s = s < 0 ? 0 : s > 1 ? 1 : s, n); const l = M(a = a > 1 ? 1 : a, n); const p = t.length; const m = 1 - h; const f = 1 - l; const c = m * m * m; const d = h * m * m * 3; const u = h * h * m * 3; const y = h * h * h; const g = m * m * f; const v = h * m * f + m * h * f + m * m * l; const b = h * h * f + m * h * l + h * m * l; const E = h * h * l; const x = m * f * f; const S = h * f * f + m * l * f + m * f * l; const P = h * l * f + m * l * l + h * f * l; const _ = h * l * l; const A = f * f * f; const C = l * f * f + f * l * f + f * f * l; const T = l * l * f + f * l * l + l * f * l; const k = l * l * l; for (o = 0; o < p; o += 1)D[4 * o] = Math.round(1e3 * (c * t[o] + d * r[o] + u * i[o] + y * e[o])) / 1e3, D[4 * o + 1] = Math.round(1e3 * (g * t[o] + v * r[o] + b * i[o] + E * e[o])) / 1e3, D[4 * o + 2] = Math.round(1e3 * (x * t[o] + S * r[o] + P * i[o] + _ * e[o])) / 1e3, D[4 * o + 3] = Math.round(1e3 * (A * t[o] + C * r[o] + T * i[o] + k * e[o])) / 1e3; return D }, getPointInSegment(t, e, r, i, s, a) { const n = M(s, a); const o = 1 - n; return [Math.round(1e3 * (o * o * o * t[0] + (n * o * o + o * n * o + o * o * n) * r[0] + (n * n * o + o * n * n + n * o * n) * i[0] + n * n * n * e[0])) / 1e3, Math.round(1e3 * (o * o * o * t[1] + (n * o * o + o * n * o + o * o * n) * r[1] + (n * n * o + o * n * n + n * o * n) * i[1] + n * n * n * e[1])) / 1e3] }, buildBezierData: t, pointOnLine2D: y, pointOnLine3D(t, e, r, i, s, a, n, o, h) { if (r === 0 && a === 0 && h === 0) return y(t, e, i, s, n, o); let l; const p = Math.sqrt(Math.pow(i - t, 2) + Math.pow(s - e, 2) + Math.pow(a - r, 2)); const m = Math.sqrt(Math.pow(n - t, 2) + Math.pow(o - e, 2) + Math.pow(h - r, 2)); const f = Math.sqrt(Math.pow(n - i, 2) + Math.pow(o - s, 2) + Math.pow(h - a, 2)); return (l = m < p ? f < p ? p - m - f : f - m - p : m < f ? f - m - p : m - p - f) > -1e-4 && l < 1e-4 }
    }
  }!(function () { for (var a = 0, t = ['ms', 'moz', 'webkit', 'o'], e = 0; e < t.length && !window.requestAnimationFrame; ++e)window.requestAnimationFrame = window[`${t[e]}RequestAnimationFrame`], window.cancelAnimationFrame = window[`${t[e]}CancelAnimationFrame`] || window[`${t[e]}CancelRequestAnimationFrame`]; window.requestAnimationFrame || (window.requestAnimationFrame = function (t, e) { const r = (new Date()).getTime(); const i = Math.max(0, 16 - (r - a)); const s = setTimeout(() => { t(r + i) }, i); return a = r + i, s }), window.cancelAnimationFrame || (window.cancelAnimationFrame = function (t) { clearTimeout(t) }) }()); const bez = bezFunction(); function dataFunctionManager() { function m(t, e, r) { let i; let s; let a; let n; let o; let h; const l = t.length; for (s = 0; s < l; s += 1) if ('ks' in (i = t[s]) && !i.completed) { if (i.completed = !0, i.tt && (t[s - 1].td = i.tt), [], -1, i.hasMask) { const p = i.masksProperties; for (n = p.length, a = 0; a < n; a += 1) if (p[a].pt.k.i)d(p[a].pt.k); else for (h = p[a].pt.k.length, o = 0; o < h; o += 1)p[a].pt.k[o].s && d(p[a].pt.k[o].s[0]), p[a].pt.k[o].e && d(p[a].pt.k[o].e[0]) }i.ty === 0 ? (i.layers = f(i.refId, e), m(i.layers, e, r)) : i.ty === 4 ? c(i.shapes) : i.ty == 5 && u(i, r) } } function f(t, e) { for (let r = 0, i = e.length; r < i;) { if (e[r].id === t) return e[r].layers.__used ? JSON.parse(JSON.stringify(e[r].layers)) : (e[r].layers.__used = !0, e[r].layers); r += 1 } } function c(t) { let e; let r; let i; for (e = t.length - 1; e >= 0; e -= 1) if (t[e].ty == 'sh') { if (t[e].ks.k.i)d(t[e].ks.k); else for (i = t[e].ks.k.length, r = 0; r < i; r += 1)t[e].ks.k[r].s && d(t[e].ks.k[r].s[0]), t[e].ks.k[r].e && d(t[e].ks.k[r].e[0]); !0 } else t[e].ty == 'gr' && c(t[e].it) } function d(t) { let e; const r = t.i.length; for (e = 0; e < r; e += 1)t.i[e][0] += t.v[e][0], t.i[e][1] += t.v[e][1], t.o[e][0] += t.v[e][0], t.o[e][1] += t.v[e][1] } function o(t, e) { const r = e ? e.split('.') : [100, 100, 100]; return t[0] > r[0] || !(r[0] > t[0]) && (t[1] > r[1] || !(r[1] > t[1]) && (t[2] > r[2] || !(r[2] > t[2]) && void 0)) } let h; const r = (function () { const i = [4, 4, 14]; function s(t) { let e; let r; let i; const s = t.length; for (e = 0; e < s; e += 1)t[e].ty === 5 && (r = t[e], void 0, i = r.t.d, r.t.d = { k: [{ s: i, t: 0 }] }) } return function (t) { if (o(i, t.v) && (s(t.layers), t.assets)) { let e; const r = t.assets.length; for (e = 0; e < r; e += 1)t.assets[e].layers && s(t.assets[e].layers) } } }()); const i = (h = [4, 7, 99], function (t) { if (t.chars && !o(h, t.v)) { let e; let r; let i; let s; let a; const n = t.chars.length; for (e = 0; e < n; e += 1) if (t.chars[e].data && t.chars[e].data.shapes) for (i = (a = t.chars[e].data.shapes[0].it).length, r = 0; r < i; r += 1)(s = a[r].ks.k).__converted || (d(a[r].ks.k), s.__converted = !0) } }); const s = (function () { const i = [4, 1, 9]; function a(t) { let e; let r; let i; const s = t.length; for (e = 0; e < s; e += 1) if (t[e].ty === 'gr')a(t[e].it); else if (t[e].ty === 'fl' || t[e].ty === 'st') if (t[e].c.k && t[e].c.k[0].i) for (i = t[e].c.k.length, r = 0; r < i; r += 1)t[e].c.k[r].s && (t[e].c.k[r].s[0] /= 255, t[e].c.k[r].s[1] /= 255, t[e].c.k[r].s[2] /= 255, t[e].c.k[r].s[3] /= 255), t[e].c.k[r].e && (t[e].c.k[r].e[0] /= 255, t[e].c.k[r].e[1] /= 255, t[e].c.k[r].e[2] /= 255, t[e].c.k[r].e[3] /= 255); else t[e].c.k[0] /= 255, t[e].c.k[1] /= 255, t[e].c.k[2] /= 255, t[e].c.k[3] /= 255 } function s(t) { let e; const r = t.length; for (e = 0; e < r; e += 1)t[e].ty === 4 && a(t[e].shapes) } return function (t) { if (o(i, t.v) && (s(t.layers), t.assets)) { let e; const r = t.assets.length; for (e = 0; e < r; e += 1)t.assets[e].layers && s(t.assets[e].layers) } } }()); const a = (function () { const i = [4, 4, 18]; function l(t) { let e; let r; let i; for (e = t.length - 1; e >= 0; e -= 1) if (t[e].ty == 'sh') { if (t[e].ks.k.i)t[e].ks.k.c = t[e].closed; else for (i = t[e].ks.k.length, r = 0; r < i; r += 1)t[e].ks.k[r].s && (t[e].ks.k[r].s[0].c = t[e].closed), t[e].ks.k[r].e && (t[e].ks.k[r].e[0].c = t[e].closed); !0 } else t[e].ty == 'gr' && l(t[e].it) } function s(t) { let e; let r; let i; let s; let a; let n; const o = t.length; for (r = 0; r < o; r += 1) { if ((e = t[r]).hasMask) { const h = e.masksProperties; for (s = h.length, i = 0; i < s; i += 1) if (h[i].pt.k.i)h[i].pt.k.c = h[i].cl; else for (n = h[i].pt.k.length, a = 0; a < n; a += 1)h[i].pt.k[a].s && (h[i].pt.k[a].s[0].c = h[i].cl), h[i].pt.k[a].e && (h[i].pt.k[a].e[0].c = h[i].cl) }e.ty === 4 && l(e.shapes) } } return function (t) { if (o(i, t.v) && (s(t.layers), t.assets)) { let e; const r = t.assets.length; for (e = 0; e < r; e += 1)t.assets[e].layers && s(t.assets[e].layers) } } }()); function u(t, e) { t.t.a.length !== 0 || 'm' in t.t.p || (t.singleShape = !0) } const t = { completeData(t, e) { t.__complete || (s(t), r(t), i(t), a(t), m(t.layers, t.assets, e), t.__complete = !0) } }; return t.checkColors = s, t.checkChars = i, t.checkShapes = a, t.completeLayers = m, t } const dataManager = dataFunctionManager(); const FontManager = (function () { const a = { w: 0, size: 0, shapes: [] }; let t = []; function u(t, e) { const r = createTag('span'); r.style.fontFamily = e; const i = createTag('span'); i.innerHTML = 'giItT1WQy@!-/#', r.style.position = 'absolute', r.style.left = '-10000px', r.style.top = '-10000px', r.style.fontSize = '300px', r.style.fontVariant = 'normal', r.style.fontStyle = 'normal', r.style.fontWeight = 'normal', r.style.letterSpacing = '0', r.appendChild(i), document.body.appendChild(r); const s = i.offsetWidth; return i.style.fontFamily = `${t}, ${e}`, { node: i, w: s, parent: r } }t = t.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]); const e = function () { this.fonts = [], this.chars = null, this.typekitLoaded = 0, this.isLoaded = !1, this.initTime = Date.now() }; return e.getCombinedCharacterCodes = function () { return t }, e.prototype.addChars = function (t) { if (t) { this.chars || (this.chars = []); let e; let r; let i; const s = t.length; let a = this.chars.length; for (e = 0; e < s; e += 1) { for (r = 0, i = !1; r < a;) this.chars[r].style === t[e].style && this.chars[r].fFamily === t[e].fFamily && this.chars[r].ch === t[e].ch && (i = !0), r += 1; i || (this.chars.push(t[e]), a += 1) } } }, e.prototype.addFonts = function (t, e) { if (t) { if (this.chars) return this.isLoaded = !0, void (this.fonts = t.list); let r; let i; let s; let a; const n = t.list; const o = n.length; let h = o; for (r = 0; r < o; r += 1) { var l; var p; let m = !0; if (n[r].loaded = !1, n[r].monoCase = u(n[r].fFamily, 'monospace'), n[r].sansCase = u(n[r].fFamily, 'sans-serif'), n[r].fPath) { if (n[r].fOrigin === 'p' || n[r].origin === 3) { if ((l = document.querySelectorAll(`style[f-forigin="p"][f-family="${n[r].fFamily}"], style[f-origin="3"][f-family="${n[r].fFamily}"]`)).length > 0 && (m = !1), m) { const f = createTag('style'); f.setAttribute('f-forigin', n[r].fOrigin), f.setAttribute('f-origin', n[r].origin), f.setAttribute('f-family', n[r].fFamily), f.type = 'text/css', f.innerHTML = `@font-face {font-family: ${n[r].fFamily}; font-style: normal; src: url('${n[r].fPath}');}`, e.appendChild(f) } } else if (n[r].fOrigin === 'g' || n[r].origin === 1) { for (l = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'), p = 0; p < l.length; p++)l[p].href.indexOf(n[r].fPath) !== -1 && (m = !1); if (m) { const c = createTag('link'); c.setAttribute('f-forigin', n[r].fOrigin), c.setAttribute('f-origin', n[r].origin), c.type = 'text/css', c.rel = 'stylesheet', c.href = n[r].fPath, document.body.appendChild(c) } } else if (n[r].fOrigin === 't' || n[r].origin === 2) { for (l = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'), p = 0; p < l.length; p++)n[r].fPath === l[p].src && (m = !1); if (m) { const d = createTag('link'); d.setAttribute('f-forigin', n[r].fOrigin), d.setAttribute('f-origin', n[r].origin), d.setAttribute('rel', 'stylesheet'), d.setAttribute('href', n[r].fPath), e.appendChild(d) } } } else n[r].loaded = !0, h -= 1; n[r].helper = (i = e, s = n[r], a = void 0, (a = createNS('text')).style.fontSize = '100px', a.setAttribute('font-family', s.fFamily), a.setAttribute('font-style', s.fStyle), a.setAttribute('font-weight', s.fWeight), a.textContent = '1', s.fClass ? (a.style.fontFamily = 'inherit', a.setAttribute('class', s.fClass)) : a.style.fontFamily = s.fFamily, i.appendChild(a), createTag('canvas').getContext('2d').font = `${s.fWeight} ${s.fStyle} 100px ${s.fFamily}`, a), n[r].cache = {}, this.fonts.push(n[r]) }h === 0 ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100) } else this.isLoaded = !0 }, e.prototype.getCharData = function (t, e, r) { for (let i = 0, s = this.chars.length; i < s;) { if (this.chars[i].ch === t && this.chars[i].style === e && this.chars[i].fFamily === r) return this.chars[i]; i += 1 } return (typeof t === 'string' && t.charCodeAt(0) !== 13 || !t) && console && console.warn && console.warn('Missing character from exported characters list: ', t, e, r), a }, e.prototype.getFontByName = function (t) { for (let e = 0, r = this.fonts.length; e < r;) { if (this.fonts[e].fName === t) return this.fonts[e]; e += 1 } return this.fonts[0] }, e.prototype.measureText = function (t, e, r) { const i = this.getFontByName(e); const s = t.charCodeAt(0); if (!i.cache[s + 1]) { const a = i.helper; if (t === ' ') { a.textContent = `|${t}|`; const n = a.getComputedTextLength(); a.textContent = '||'; const o = a.getComputedTextLength(); i.cache[s + 1] = (n - o) / 100 } else a.textContent = t, i.cache[s + 1] = a.getComputedTextLength() / 100 } return i.cache[s + 1] * r }, e.prototype.checkLoadedFonts = function () { let t; let e; let r; const i = this.fonts.length; let s = i; for (t = 0; t < i; t += 1) this.fonts[t].loaded ? s -= 1 : this.fonts[t].fOrigin === 'n' || this.fonts[t].origin === 0 ? this.fonts[t].loaded = !0 : (e = this.fonts[t].monoCase.node, r = this.fonts[t].monoCase.w, e.offsetWidth !== r ? (s -= 1, this.fonts[t].loaded = !0) : (e = this.fonts[t].sansCase.node, r = this.fonts[t].sansCase.w, e.offsetWidth !== r && (s -= 1, this.fonts[t].loaded = !0)), this.fonts[t].loaded && (this.fonts[t].sansCase.parent.parentNode.removeChild(this.fonts[t].sansCase.parent), this.fonts[t].monoCase.parent.parentNode.removeChild(this.fonts[t].monoCase.parent))); s !== 0 && Date.now() - this.initTime < 5e3 ? setTimeout(this.checkLoadedFonts.bind(this), 20) : setTimeout(() => { this.isLoaded = !0 }, 0) }, e.prototype.loaded = function () { return this.isLoaded }, e }()); const PropertyFactory = (function () {
    const m = initialDefaultFrame; const s = Math.abs; function f(t, e) { let r; const i = this.offsetTime; this.propType === 'multidimensional' && (r = createTypedArray('float32', this.pv.length)); for (var s, a, n, o, h, l, p, m, f = e.lastIndex, c = f, d = this.keyframes.length - 1, u = !0; u;) { if (s = this.keyframes[c], a = this.keyframes[c + 1], c === d - 1 && t >= a.t - i) { s.h && (s = a), f = 0; break } if (a.t - i > t) { f = c; break }c < d - 1 ? c += 1 : (f = 0, u = !1) } let y; let g; let v; let b; let E; let x; let S; let P; let _; let A; const C = a.t - i; const T = s.t - i; if (s.to) { s.bezierData || (s.bezierData = bez.buildBezierData(s.s, a.s || s.e, s.to, s.ti)); const k = s.bezierData; if (C <= t || t < T) { const M = C <= t ? k.points.length - 1 : 0; for (o = k.points[M].point.length, n = 0; n < o; n += 1)r[n] = k.points[M].point[n] } else { s.__fnct ? m = s.__fnct : (m = BezierFactory.getBezierEasing(s.o.x, s.o.y, s.i.x, s.i.y, s.n).get, s.__fnct = m), h = m((t - T) / (C - T)); let D; const w = k.segmentLength * h; let F = e.lastFrame < t && e._lastKeyframeIndex === c ? e._lastAddedLength : 0; for (p = e.lastFrame < t && e._lastKeyframeIndex === c ? e._lastPoint : 0, u = !0, l = k.points.length; u;) { if (F += k.points[p].partialLength, w === 0 || h === 0 || p === k.points.length - 1) { for (o = k.points[p].point.length, n = 0; n < o; n += 1)r[n] = k.points[p].point[n]; break } if (F <= w && w < F + k.points[p + 1].partialLength) { for (D = (w - F) / k.points[p + 1].partialLength, o = k.points[p].point.length, n = 0; n < o; n += 1)r[n] = k.points[p].point[n] + (k.points[p + 1].point[n] - k.points[p].point[n]) * D; break }p < l - 1 ? p += 1 : u = !1 }e._lastPoint = p, e._lastAddedLength = F - k.points[p].partialLength, e._lastKeyframeIndex = c } } else { let I; let V; let R; let B; let L; if (d = s.s.length, y = a.s || s.e, this.sh && s.h !== 1) if (C <= t)r[0] = y[0], r[1] = y[1], r[2] = y[2]; else if (t <= T)r[0] = s.s[0], r[1] = s.s[1], r[2] = s.s[2]; else { const G = N(s.s); const z = N(y); g = r, v = (function (t, e, r) { let i; let s; let a; let n; let o; const h = []; const l = t[0]; const p = t[1]; const m = t[2]; const f = t[3]; let c = e[0]; let d = e[1]; let u = e[2]; let y = e[3]; (s = l * c + p * d + m * u + f * y) < 0 && (s = -s, c = -c, d = -d, u = -u, y = -y); o = 1 - s > 1e-6 ? (i = Math.acos(s), a = Math.sin(i), n = Math.sin((1 - r) * i) / a, Math.sin(r * i) / a) : (n = 1 - r, r); return h[0] = n * l + o * c, h[1] = n * p + o * d, h[2] = n * m + o * u, h[3] = n * f + o * y, h }(G, z, (t - T) / (C - T))), b = v[0], E = v[1], x = v[2], S = v[3], P = Math.atan2(2 * E * S - 2 * b * x, 1 - 2 * E * E - 2 * x * x), _ = Math.asin(2 * b * E + 2 * x * S), A = Math.atan2(2 * b * S - 2 * E * x, 1 - 2 * b * b - 2 * x * x), g[0] = P / degToRads, g[1] = _ / degToRads, g[2] = A / degToRads } else for (c = 0; c < d; c += 1)s.h !== 1 && (h = C <= t ? 1 : t < T ? 0 : (s.o.x.constructor === Array ? (s.__fnct || (s.__fnct = []), s.__fnct[c] ? m = s.__fnct[c] : (I = void 0 === s.o.x[c] ? s.o.x[0] : s.o.x[c], V = void 0 === s.o.y[c] ? s.o.y[0] : s.o.y[c], R = void 0 === s.i.x[c] ? s.i.x[0] : s.i.x[c], B = void 0 === s.i.y[c] ? s.i.y[0] : s.i.y[c], m = BezierFactory.getBezierEasing(I, V, R, B).get, s.__fnct[c] = m)) : s.__fnct ? m = s.__fnct : (I = s.o.x, V = s.o.y, R = s.i.x, B = s.i.y, m = BezierFactory.getBezierEasing(I, V, R, B).get, s.__fnct = m), m((t - T) / (C - T)))), y = a.s || s.e, L = s.h === 1 ? s.s[c] : s.s[c] + (y[c] - s.s[c]) * h, this.propType === 'multidimensional' ? r[c] = L : r = L } return e.lastIndex = f, r } function N(t) { const e = t[0] * degToRads; const r = t[1] * degToRads; const i = t[2] * degToRads; const s = Math.cos(e / 2); const a = Math.cos(r / 2); const n = Math.cos(i / 2); const o = Math.sin(e / 2); const h = Math.sin(r / 2); const l = Math.sin(i / 2); return [o * h * n + s * a * l, o * a * n + s * h * l, s * h * n - o * a * l, s * a * n - o * h * l] } function c() { const t = this.comp.renderedFrame - this.offsetTime; const e = this.keyframes[0].t - this.offsetTime; const r = this.keyframes[this.keyframes.length - 1].t - this.offsetTime; if (!(t === this._caching.lastFrame || this._caching.lastFrame !== m && (this._caching.lastFrame >= r && r <= t || this._caching.lastFrame < e && t < e))) { this._caching.lastFrame >= t && (this._caching._lastKeyframeIndex = -1, this._caching.lastIndex = 0); const i = this.interpolateValue(t, this._caching); this.pv = i } return this._caching.lastFrame = t, this.pv } function d(t) { let e; if (this.propType === 'unidimensional')e = t * this.mult, s(this.v - e) > 1e-5 && (this.v = e, this._mdf = !0); else for (let r = 0, i = this.v.length; r < i;)e = t[r] * this.mult, s(this.v[r] - e) > 1e-5 && (this.v[r] = e, this._mdf = !0), r += 1 } function u() { if (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length) if (this.lock) this.setVValue(this.pv); else { this.lock = !0, this._mdf = this._isFirstFrame; let t; const e = this.effectsSequence.length; let r = this.kf ? this.pv : this.data.k; for (t = 0; t < e; t += 1)r = this.effectsSequence[t](r); this.setVValue(r), this._isFirstFrame = !1, this.lock = !1, this.frameId = this.elem.globalData.frameId } } function y(t) { this.effectsSequence.push(t), this.container.addDynamicProperty(this) } function n(t, e, r, i) { this.propType = 'unidimensional', this.mult = r || 1, this.data = e, this.v = r ? e.k * r : e.k, this.pv = e.k, this._mdf = !1, this.elem = t, this.container = i, this.comp = t.comp, this.k = !1, this.kf = !1, this.vel = 0, this.effectsSequence = [], this._isFirstFrame = !0, this.getValue = u, this.setVValue = d, this.addEffect = y } function o(t, e, r, i) { this.propType = 'multidimensional', this.mult = r || 1, this.data = e, this._mdf = !1, this.elem = t, this.container = i, this.comp = t.comp, this.k = !1, this.kf = !1, this.frameId = -1; let s; const a = e.k.length; this.v = createTypedArray('float32', a), this.pv = createTypedArray('float32', a); createTypedArray('float32', a); for (this.vel = createTypedArray('float32', a), s = 0; s < a; s += 1) this.v[s] = e.k[s] * this.mult, this.pv[s] = e.k[s]; this._isFirstFrame = !0, this.effectsSequence = [], this.getValue = u, this.setVValue = d, this.addEffect = y } function h(t, e, r, i) {
      this.propType = 'unidimensional', this.keyframes = e.k, this.offsetTime = t.data.st, this.frameId = -1, this._caching = {
        lastFrame: m, lastIndex: 0, value: 0, _lastKeyframeIndex: -1
      }, this.k = !0, this.kf = !0, this.data = e, this.mult = r || 1, this.elem = t, this.container = i, this.comp = t.comp, this.v = m, this.pv = m, this._isFirstFrame = !0, this.getValue = u, this.setVValue = d, this.interpolateValue = f, this.effectsSequence = [c.bind(this)], this.addEffect = y
    } function l(t, e, r, i) { this.propType = 'multidimensional'; let s; let a; let n; let o; let h; const l = e.k.length; for (s = 0; s < l - 1; s += 1)e.k[s].to && e.k[s].s && e.k[s + 1] && e.k[s + 1].s && (a = e.k[s].s, n = e.k[s + 1].s, o = e.k[s].to, h = e.k[s].ti, (a.length === 2 && (a[0] !== n[0] || a[1] !== n[1]) && bez.pointOnLine2D(a[0], a[1], n[0], n[1], a[0] + o[0], a[1] + o[1]) && bez.pointOnLine2D(a[0], a[1], n[0], n[1], n[0] + h[0], n[1] + h[1]) || a.length === 3 && (a[0] !== n[0] || a[1] !== n[1] || a[2] !== n[2]) && bez.pointOnLine3D(a[0], a[1], a[2], n[0], n[1], n[2], a[0] + o[0], a[1] + o[1], a[2] + o[2]) && bez.pointOnLine3D(a[0], a[1], a[2], n[0], n[1], n[2], n[0] + h[0], n[1] + h[1], n[2] + h[2])) && (e.k[s].to = null, e.k[s].ti = null), a[0] === n[0] && a[1] === n[1] && o[0] === 0 && o[1] === 0 && h[0] === 0 && h[1] === 0 && (a.length === 2 || a[2] === n[2] && o[2] === 0 && h[2] === 0) && (e.k[s].to = null, e.k[s].ti = null)); this.effectsSequence = [c.bind(this)], this.keyframes = e.k, this.offsetTime = t.data.st, this.k = !0, this.kf = !0, this._isFirstFrame = !0, this.mult = r || 1, this.elem = t, this.container = i, this.comp = t.comp, this.getValue = u, this.setVValue = d, this.interpolateValue = f, this.frameId = -1; const p = e.k[0].s.length; for (this.v = createTypedArray('float32', p), this.pv = createTypedArray('float32', p), s = 0; s < p; s += 1) this.v[s] = m, this.pv[s] = m; this._caching = { lastFrame: m, lastIndex: 0, value: createTypedArray('float32', p) }, this.addEffect = y } return { getProp(t, e, r, i, s) { let a; if (e.k.length) if (typeof e.k[0] === 'number')a = new o(t, e, i, s); else switch (r) { case 0: a = new h(t, e, i, s); break; case 1: a = new l(t, e, i, s) } else a = new n(t, e, i, s); return a.effectsSequence.length && s.addDynamicProperty(a), a } }
  }()); const TransformPropertyFactory = (function () {
    const n = [0, 0]; function i(t, e, r) { if (this.elem = t, this.frameId = -1, this.propType = 'transform', this.data = e, this.v = new Matrix(), this.pre = new Matrix(), this.appliedTransformations = 0, this.initDynamicPropertyContainer(r || t), e.p && e.p.s ? (this.px = PropertyFactory.getProp(t, e.p.x, 0, 0, this), this.py = PropertyFactory.getProp(t, e.p.y, 0, 0, this), e.p.z && (this.pz = PropertyFactory.getProp(t, e.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(t, e.p || { k: [0, 0, 0] }, 1, 0, this), e.rx) { if (this.rx = PropertyFactory.getProp(t, e.rx, 0, degToRads, this), this.ry = PropertyFactory.getProp(t, e.ry, 0, degToRads, this), this.rz = PropertyFactory.getProp(t, e.rz, 0, degToRads, this), e.or.k[0].ti) { let i; const s = e.or.k.length; for (i = 0; i < s; i += 1)e.or.k[i].to = e.or.k[i].ti = null } this.or = PropertyFactory.getProp(t, e.or, 1, degToRads, this), this.or.sh = !0 } else this.r = PropertyFactory.getProp(t, e.r || { k: 0 }, 0, degToRads, this); e.sk && (this.sk = PropertyFactory.getProp(t, e.sk, 0, degToRads, this), this.sa = PropertyFactory.getProp(t, e.sa, 0, degToRads, this)), this.a = PropertyFactory.getProp(t, e.a || { k: [0, 0, 0] }, 1, 0, this), this.s = PropertyFactory.getProp(t, e.s || { k: [100, 100, 100] }, 1, 0.01, this), e.o ? this.o = PropertyFactory.getProp(t, e.o, 0, 0.01, t) : this.o = { _mdf: !1, v: 1 }, this._isDirty = !0, this.dynamicProperties.length || this.getValue(!0) } return i.prototype = {
      applyToMatrix(t) {
        const e = this._mdf; this.iterateDynamicProperties(), this._mdf = this._mdf || e, this.a && t.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.s && t.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && t.skewFromAxis(-this.sk.v, this.sa.v), this.r ? t.rotate(-this.r.v) : t.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2])
          .rotateY(this.or.v[1])
          .rotateX(this.or.v[0]), this.data.p.s ? this.data.p.z ? t.translate(this.px.v, this.py.v, -this.pz.v) : t.translate(this.px.v, this.py.v, 0) : t.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
      },
      getValue(t) {
        if (this.elem.globalData.frameId !== this.frameId) {
          if (this._isDirty && (this.precalculateMatrix(), this._isDirty = !1), this.iterateDynamicProperties(), this._mdf || t) {
            if (this.v.cloneFromProps(this.pre.props), this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v), this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2])
              .rotateY(this.or.v[1])
              .rotateX(this.or.v[0]), this.autoOriented) { let e; let r; const i = this.elem.globalData.frameRate; if (this.p && this.p.keyframes && this.p.getValueAtTime)r = this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? (e = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / i, 0), this.p.getValueAtTime(this.p.keyframes[0].t / i, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? (e = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / i, 0), this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / i, 0)) : (e = this.p.pv, this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / i, this.p.offsetTime)); else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) { e = [], r = []; const s = this.px; const a = this.py; s._caching.lastFrame + s.offsetTime <= s.keyframes[0].t ? (e[0] = s.getValueAtTime((s.keyframes[0].t + 0.01) / i, 0), e[1] = a.getValueAtTime((a.keyframes[0].t + 0.01) / i, 0), r[0] = s.getValueAtTime(s.keyframes[0].t / i, 0), r[1] = a.getValueAtTime(a.keyframes[0].t / i, 0)) : s._caching.lastFrame + s.offsetTime >= s.keyframes[s.keyframes.length - 1].t ? (e[0] = s.getValueAtTime(s.keyframes[s.keyframes.length - 1].t / i, 0), e[1] = a.getValueAtTime(a.keyframes[a.keyframes.length - 1].t / i, 0), r[0] = s.getValueAtTime((s.keyframes[s.keyframes.length - 1].t - 0.01) / i, 0), r[1] = a.getValueAtTime((a.keyframes[a.keyframes.length - 1].t - 0.01) / i, 0)) : (e = [s.pv, a.pv], r[0] = s.getValueAtTime((s._caching.lastFrame + s.offsetTime - 0.01) / i, s.offsetTime), r[1] = a.getValueAtTime((a._caching.lastFrame + a.offsetTime - 0.01) / i, a.offsetTime)) } else e = r = n; this.v.rotate(-Math.atan2(e[1] - r[1], e[0] - r[0])) } this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
          } this.frameId = this.elem.globalData.frameId
        }
      },
      precalculateMatrix() {
        if (!this.a.k && (this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations = 1, !this.s.effectsSequence.length)) {
          if (this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.appliedTransformations = 2, this.sk) { if (this.sk.effectsSequence.length || this.sa.effectsSequence.length) return; this.pre.skewFromAxis(-this.sk.v, this.sa.v), this.appliedTransformations = 3 } if (this.r) { if (this.r.effectsSequence.length) return; this.pre.rotate(-this.r.v), this.appliedTransformations = 4 } else {
            this.rz.effectsSequence.length || this.ry.effectsSequence.length || this.rx.effectsSequence.length || this.or.effectsSequence.length || (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2])
              .rotateY(this.or.v[1])
              .rotateX(this.or.v[0]), this.appliedTransformations = 4)
          }
        }
      },
      autoOrient() {}
    }, extendPrototype([DynamicPropertyContainer], i), i.prototype.addDynamicProperty = function (t) { this._addDynamicProperty(t), this.elem.addDynamicProperty(t), this._isDirty = !0 }, i.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty, { getTransformProperty(t, e, r) { return new i(t, e, r) } }
  }()); function ShapePath() { this.c = !1, this._length = 0, this._maxLength = 8, this.v = createSizedArray(this._maxLength), this.o = createSizedArray(this._maxLength), this.i = createSizedArray(this._maxLength) }ShapePath.prototype.setPathData = function (t, e) { this.c = t, this.setLength(e); for (let r = 0; r < e;) this.v[r] = point_pool.newElement(), this.o[r] = point_pool.newElement(), this.i[r] = point_pool.newElement(), r += 1 }, ShapePath.prototype.setLength = function (t) { for (;this._maxLength < t;) this.doubleArrayLength(); this._length = t }, ShapePath.prototype.doubleArrayLength = function () { this.v = this.v.concat(createSizedArray(this._maxLength)), this.i = this.i.concat(createSizedArray(this._maxLength)), this.o = this.o.concat(createSizedArray(this._maxLength)), this._maxLength *= 2 }, ShapePath.prototype.setXYAt = function (t, e, r, i, s) { let a; switch (this._length = Math.max(this._length, i + 1), this._length >= this._maxLength && this.doubleArrayLength(), r) { case 'v': a = this.v; break; case 'i': a = this.i; break; case 'o': a = this.o }(!a[i] || a[i] && !s) && (a[i] = point_pool.newElement()), a[i][0] = t, a[i][1] = e }, ShapePath.prototype.setTripleAt = function (t, e, r, i, s, a, n, o) { this.setXYAt(t, e, 'v', n, o), this.setXYAt(r, i, 'o', n, o), this.setXYAt(s, a, 'i', n, o) }, ShapePath.prototype.reverse = function () { const t = new ShapePath(); t.setPathData(this.c, this._length); const e = this.v; const r = this.o; const { i } = this; let s = 0; this.c && (t.setTripleAt(e[0][0], e[0][1], i[0][0], i[0][1], r[0][0], r[0][1], 0, !1), s = 1); let a; let n = this._length - 1; const o = this._length; for (a = s; a < o; a += 1)t.setTripleAt(e[n][0], e[n][1], i[n][0], i[n][1], r[n][0], r[n][1], a, !1), n -= 1; return t }; const ShapePropertyFactory = (function () {
    const s = -999999; function t(t, e, r) { let i; let s; let a; let n; let o; let h; let l; let p; let m; let f = r.lastIndex; const c = this.keyframes; if (t < c[0].t - this.offsetTime)i = c[0].s[0], a = !0, f = 0; else if (t >= c[c.length - 1].t - this.offsetTime)i = c[c.length - 1].s ? c[c.length - 1].s[0] : c[c.length - 2].e[0], a = !0; else { for (var d, u, y = f, g = c.length - 1, v = !0; v && (d = c[y], !((u = c[y + 1]).t - this.offsetTime > t));)y < g - 1 ? y += 1 : v = !1; if (f = y, !(a = d.h === 1)) { if (t >= u.t - this.offsetTime)p = 1; else if (t < d.t - this.offsetTime)p = 0; else { let b; d.__fnct ? b = d.__fnct : (b = BezierFactory.getBezierEasing(d.o.x, d.o.y, d.i.x, d.i.y).get, d.__fnct = b), p = b((t - (d.t - this.offsetTime)) / (u.t - this.offsetTime - (d.t - this.offsetTime))) }s = u.s ? u.s[0] : d.e[0] }i = d.s[0] } for (h = e._length, l = i.i[0].length, r.lastIndex = f, n = 0; n < h; n += 1) for (o = 0; o < l; o += 1)m = a ? i.i[n][o] : i.i[n][o] + (s.i[n][o] - i.i[n][o]) * p, e.i[n][o] = m, m = a ? i.o[n][o] : i.o[n][o] + (s.o[n][o] - i.o[n][o]) * p, e.o[n][o] = m, m = a ? i.v[n][o] : i.v[n][o] + (s.v[n][o] - i.v[n][o]) * p, e.v[n][o] = m } function a() { this.paths = this.localShapeCollection } function e(t) { (function (t, e) { if (t._length !== e._length || t.c !== e.c) return !1; let r; const i = t._length; for (r = 0; r < i; r += 1) if (t.v[r][0] !== e.v[r][0] || t.v[r][1] !== e.v[r][1] || t.o[r][0] !== e.o[r][0] || t.o[r][1] !== e.o[r][1] || t.i[r][0] !== e.i[r][0] || t.i[r][1] !== e.i[r][1]) return !1; return !0 }(this.v, t)) || (this.v = shape_pool.clone(t), this.localShapeCollection.releaseShapes(), this.localShapeCollection.addShape(this.v), this._mdf = !0, this.paths = this.localShapeCollection) } function r() { if (this.elem.globalData.frameId !== this.frameId) if (this.effectsSequence.length) if (this.lock) this.setVValue(this.pv); else { this.lock = !0, this._mdf = !1; let t; let e = this.kf ? this.pv : this.data.ks ? this.data.ks.k : this.data.pt.k; const r = this.effectsSequence.length; for (t = 0; t < r; t += 1)e = this.effectsSequence[t](e); this.setVValue(e), this.lock = !1, this.frameId = this.elem.globalData.frameId } else this._mdf = !1 } function n(t, e, r) { this.propType = 'shape', this.comp = t.comp, this.container = t, this.elem = t, this.data = e, this.k = !1, this.kf = !1, this._mdf = !1; const i = r === 3 ? e.pt.k : e.ks.k; this.v = shape_pool.clone(i), this.pv = shape_pool.clone(this.v), this.localShapeCollection = shapeCollection_pool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.reset = a, this.effectsSequence = [] } function i(t) { this.effectsSequence.push(t), this.container.addDynamicProperty(this) } function o(t, e, r) { this.propType = 'shape', this.comp = t.comp, this.elem = t, this.container = t, this.offsetTime = t.data.st, this.keyframes = r === 3 ? e.pt.k : e.ks.k, this.k = !0, this.kf = !0; const i = this.keyframes[0].s[0].i.length; this.keyframes[0].s[0].i[0].length; this.v = shape_pool.newElement(), this.v.setPathData(this.keyframes[0].s[0].c, i), this.pv = shape_pool.clone(this.v), this.localShapeCollection = shapeCollection_pool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.lastFrame = s, this.reset = a, this._caching = { lastFrame: s, lastIndex: 0 }, this.effectsSequence = [function () { const t = this.comp.renderedFrame - this.offsetTime; const e = this.keyframes[0].t - this.offsetTime; const r = this.keyframes[this.keyframes.length - 1].t - this.offsetTime; const i = this._caching.lastFrame; return i !== s && (i < e && t < e || r < i && r < t) || (this._caching.lastIndex = i < t ? this._caching.lastIndex : 0, this.interpolateShape(t, this.pv, this._caching)), this._caching.lastFrame = t, this.pv }.bind(this)] }n.prototype.interpolateShape = t, n.prototype.getValue = r, n.prototype.setVValue = e, n.prototype.addEffect = i, o.prototype.getValue = r, o.prototype.interpolateShape = t, o.prototype.setVValue = e, o.prototype.addEffect = i; const h = (function () { const n = roundCorner; function t(t, e) { this.v = shape_pool.newElement(), this.v.setPathData(!0, 4), this.localShapeCollection = shapeCollection_pool.newShapeCollection(), this.paths = this.localShapeCollection, this.localShapeCollection.addShape(this.v), this.d = e.d, this.elem = t, this.comp = t.comp, this.frameId = -1, this.initDynamicPropertyContainer(t), this.p = PropertyFactory.getProp(t, e.p, 1, 0, this), this.s = PropertyFactory.getProp(t, e.s, 1, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertEllToPath()) } return t.prototype = { reset: a, getValue() { this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertEllToPath()) }, convertEllToPath() { const t = this.p.v[0]; const e = this.p.v[1]; const r = this.s.v[0] / 2; const i = this.s.v[1] / 2; const s = this.d !== 3; const a = this.v; a.v[0][0] = t, a.v[0][1] = e - i, a.v[1][0] = s ? t + r : t - r, a.v[1][1] = e, a.v[2][0] = t, a.v[2][1] = e + i, a.v[3][0] = s ? t - r : t + r, a.v[3][1] = e, a.i[0][0] = s ? t - r * n : t + r * n, a.i[0][1] = e - i, a.i[1][0] = s ? t + r : t - r, a.i[1][1] = e - i * n, a.i[2][0] = s ? t + r * n : t - r * n, a.i[2][1] = e + i, a.i[3][0] = s ? t - r : t + r, a.i[3][1] = e + i * n, a.o[0][0] = s ? t + r * n : t - r * n, a.o[0][1] = e - i, a.o[1][0] = s ? t + r : t - r, a.o[1][1] = e + i * n, a.o[2][0] = s ? t - r * n : t + r * n, a.o[2][1] = e + i, a.o[3][0] = s ? t - r : t + r, a.o[3][1] = e - i * n } }, extendPrototype([DynamicPropertyContainer], t), t }()); const l = (function () {
      function t(t, e) { this.v = shape_pool.newElement(), this.v.setPathData(!0, 0), this.elem = t, this.comp = t.comp, this.data = e, this.frameId = -1, this.d = e.d, this.initDynamicPropertyContainer(t), e.sy === 1 ? (this.ir = PropertyFactory.getProp(t, e.ir, 0, 0, this), this.is = PropertyFactory.getProp(t, e.is, 0, 0.01, this), this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath, this.pt = PropertyFactory.getProp(t, e.pt, 0, 0, this), this.p = PropertyFactory.getProp(t, e.p, 1, 0, this), this.r = PropertyFactory.getProp(t, e.r, 0, degToRads, this), this.or = PropertyFactory.getProp(t, e.or, 0, 0, this), this.os = PropertyFactory.getProp(t, e.os, 0, 0.01, this), this.localShapeCollection = shapeCollection_pool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertToPath()) } return t.prototype = {
        reset: a, getValue() { this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertToPath()) }, convertStarToPath() { let t; let e; let r; let i; const s = 2 * Math.floor(this.pt.v); const a = 2 * Math.PI / s; let n = !0; const o = this.or.v; const h = this.ir.v; const l = this.os.v; const p = this.is.v; const m = 2 * Math.PI * o / (2 * s); const f = 2 * Math.PI * h / (2 * s); let c = -Math.PI / 2; c += this.r.v; const d = this.data.d === 3 ? -1 : 1; for (t = this.v._length = 0; t < s; t += 1) { r = n ? l : p, i = n ? m : f; let u = (e = n ? o : h) * Math.cos(c); let y = e * Math.sin(c); const g = u === 0 && y === 0 ? 0 : y / Math.sqrt(u * u + y * y); const v = u === 0 && y === 0 ? 0 : -u / Math.sqrt(u * u + y * y); u += +this.p.v[0], y += +this.p.v[1], this.v.setTripleAt(u, y, u - g * i * r * d, y - v * i * r * d, u + g * i * r * d, y + v * i * r * d, t, !0), n = !n, c += a * d } }, convertPolygonToPath() { let t; const e = Math.floor(this.pt.v); const r = 2 * Math.PI / e; const i = this.or.v; const s = this.os.v; const a = 2 * Math.PI * i / (4 * e); let n = -Math.PI / 2; const o = this.data.d === 3 ? -1 : 1; for (n += this.r.v, t = this.v._length = 0; t < e; t += 1) { let h = i * Math.cos(n); let l = i * Math.sin(n); const p = h === 0 && l === 0 ? 0 : l / Math.sqrt(h * h + l * l); const m = h === 0 && l === 0 ? 0 : -h / Math.sqrt(h * h + l * l); h += +this.p.v[0], l += +this.p.v[1], this.v.setTripleAt(h, l, h - p * a * s * o, l - m * a * s * o, h + p * a * s * o, l + m * a * s * o, t, !0), n += r * o } this.paths.length = 0, this.paths[0] = this.v }
      }, extendPrototype([DynamicPropertyContainer], t), t
    }()); const p = (function () { function t(t, e) { this.v = shape_pool.newElement(), this.v.c = !0, this.localShapeCollection = shapeCollection_pool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.elem = t, this.comp = t.comp, this.frameId = -1, this.d = e.d, this.initDynamicPropertyContainer(t), this.p = PropertyFactory.getProp(t, e.p, 1, 0, this), this.s = PropertyFactory.getProp(t, e.s, 1, 0, this), this.r = PropertyFactory.getProp(t, e.r, 0, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertRectToPath()) } return t.prototype = { convertRectToPath() { const t = this.p.v[0]; const e = this.p.v[1]; const r = this.s.v[0] / 2; const i = this.s.v[1] / 2; const s = bm_min(r, i, this.r.v); const a = s * (1 - roundCorner); this.v._length = 0, this.d === 2 || this.d === 1 ? (this.v.setTripleAt(t + r, e - i + s, t + r, e - i + s, t + r, e - i + a, 0, !0), this.v.setTripleAt(t + r, e + i - s, t + r, e + i - a, t + r, e + i - s, 1, !0), s !== 0 ? (this.v.setTripleAt(t + r - s, e + i, t + r - s, e + i, t + r - a, e + i, 2, !0), this.v.setTripleAt(t - r + s, e + i, t - r + a, e + i, t - r + s, e + i, 3, !0), this.v.setTripleAt(t - r, e + i - s, t - r, e + i - s, t - r, e + i - a, 4, !0), this.v.setTripleAt(t - r, e - i + s, t - r, e - i + a, t - r, e - i + s, 5, !0), this.v.setTripleAt(t - r + s, e - i, t - r + s, e - i, t - r + a, e - i, 6, !0), this.v.setTripleAt(t + r - s, e - i, t + r - a, e - i, t + r - s, e - i, 7, !0)) : (this.v.setTripleAt(t - r, e + i, t - r + a, e + i, t - r, e + i, 2), this.v.setTripleAt(t - r, e - i, t - r, e - i + a, t - r, e - i, 3))) : (this.v.setTripleAt(t + r, e - i + s, t + r, e - i + a, t + r, e - i + s, 0, !0), s !== 0 ? (this.v.setTripleAt(t + r - s, e - i, t + r - s, e - i, t + r - a, e - i, 1, !0), this.v.setTripleAt(t - r + s, e - i, t - r + a, e - i, t - r + s, e - i, 2, !0), this.v.setTripleAt(t - r, e - i + s, t - r, e - i + s, t - r, e - i + a, 3, !0), this.v.setTripleAt(t - r, e + i - s, t - r, e + i - a, t - r, e + i - s, 4, !0), this.v.setTripleAt(t - r + s, e + i, t - r + s, e + i, t - r + a, e + i, 5, !0), this.v.setTripleAt(t + r - s, e + i, t + r - a, e + i, t + r - s, e + i, 6, !0), this.v.setTripleAt(t + r, e + i - s, t + r, e + i - s, t + r, e + i - a, 7, !0)) : (this.v.setTripleAt(t - r, e - i, t - r + a, e - i, t - r, e - i, 1, !0), this.v.setTripleAt(t - r, e + i, t - r, e + i - a, t - r, e + i, 2, !0), this.v.setTripleAt(t + r, e + i, t + r - a, e + i, t + r, e + i, 3, !0))) }, getValue(t) { this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertRectToPath()) }, reset: a }, extendPrototype([DynamicPropertyContainer], t), t }()); const m = { getShapeProp(t, e, r) { let i; return r === 3 || r === 4 ? i = (r === 3 ? e.pt : e.ks).k.length ? new o(t, e, r) : new n(t, e, r) : r === 5 ? i = new p(t, e) : r === 6 ? i = new h(t, e) : r === 7 && (i = new l(t, e)), i.k && t.addDynamicProperty(i), i }, getConstructorFunction() { return n }, getKeyframedConstructorFunction() { return o } }; return m
  }()); const ShapeModifiers = ($r = {}, _r = {}, $r.registerModifier = function (t, e) { _r[t] || (_r[t] = e) }, $r.getModifier = function (t, e, r) { return new _r[t](e, r) }, $r); let $r; let _r; function ShapeModifier() {} function TrimModifier() {} function RoundCornersModifier() {} function RepeaterModifier() {} function ShapeCollection() { this._length = 0, this._maxLength = 4, this.shapes = createSizedArray(this._maxLength) } function DashProperty(t, e, r, i) { this.elem = t, this.frameId = -1, this.dataProps = createSizedArray(e.length), this.renderer = r, this.k = !1, this.dashStr = '', this.dashArray = createTypedArray('float32', e.length ? e.length - 1 : 0), this.dashoffset = createTypedArray('float32', 1), this.initDynamicPropertyContainer(i); let s; let a; const n = e.length || 0; for (s = 0; s < n; s += 1)a = PropertyFactory.getProp(t, e[s].v, 0, 0, this), this.k = a.k || this.k, this.dataProps[s] = { n: e[s].n, p: a }; this.k || this.getValue(!0), this._isAnimated = this.k } function GradientProperty(t, e, r) { this.data = e, this.c = createTypedArray('uint8c', 4 * e.p); const i = e.k.k[0].s ? e.k.k[0].s.length - 4 * e.p : e.k.k.length - 4 * e.p; this.o = createTypedArray('float32', i), this._cmdf = !1, this._omdf = !1, this._collapsable = this.checkCollapsable(), this._hasOpacity = i, this.initDynamicPropertyContainer(r), this.prop = PropertyFactory.getProp(t, e.k, 1, null, this), this.k = this.prop.k, this.getValue(!0) }ShapeModifier.prototype.initModifierProperties = function () {}, ShapeModifier.prototype.addShapeToModifier = function () {}, ShapeModifier.prototype.addShape = function (t) { if (!this.closed) { t.sh.container.addDynamicProperty(t.sh); const e = { shape: t.sh, data: t, localShapeCollection: shapeCollection_pool.newShapeCollection() }; this.shapes.push(e), this.addShapeToModifier(e), this._isAnimated && t.setAsAnimated() } }, ShapeModifier.prototype.init = function (t, e) { this.shapes = [], this.elem = t, this.initDynamicPropertyContainer(t), this.initModifierProperties(t, e), this.frameId = initialDefaultFrame, this.closed = !1, this.k = !1, this.dynamicProperties.length ? this.k = !0 : this.getValue(!0) }, ShapeModifier.prototype.processKeys = function () { this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties()) }, extendPrototype([DynamicPropertyContainer], ShapeModifier), extendPrototype([ShapeModifier], TrimModifier), TrimModifier.prototype.initModifierProperties = function (t, e) { this.s = PropertyFactory.getProp(t, e.s, 0, 0.01, this), this.e = PropertyFactory.getProp(t, e.e, 0, 0.01, this), this.o = PropertyFactory.getProp(t, e.o, 0, 0, this), this.sValue = 0, this.eValue = 0, this.getValue = this.processKeys, this.m = e.m, this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length }, TrimModifier.prototype.addShapeToModifier = function (t) { t.pathsData = [] }, TrimModifier.prototype.calculateShapeEdges = function (t, e, r, i, s) { const a = []; e <= 1 ? a.push({ s: t, e }) : t >= 1 ? a.push({ s: t - 1, e: e - 1 }) : (a.push({ s: t, e: 1 }), a.push({ s: 0, e: e - 1 })); let n; let o; const h = []; const l = a.length; for (n = 0; n < l; n += 1) { var p; var m; if ((o = a[n]).e * s < i || o.s * s > i + r);else p = o.s * s <= i ? 0 : (o.s * s - i) / r, m = o.e * s >= i + r ? 1 : (o.e * s - i) / r, h.push([p, m]) } return h.length || h.push([0, 0]), h }, TrimModifier.prototype.releasePathsData = function (t) { let e; const r = t.length; for (e = 0; e < r; e += 1)segments_length_pool.release(t[e]); return t.length = 0, t }, TrimModifier.prototype.processShapes = function (t) { let e; let r; let i; if (this._mdf || t) { let s = this.o.v % 360 / 360; if (s < 0 && (s += 1), e = (this.s.v > 1 ? 1 : this.s.v < 0 ? 0 : this.s.v) + s, (r = (this.e.v > 1 ? 1 : this.e.v < 0 ? 0 : this.e.v) + s) < e) { const a = e; e = r, r = a }e = 1e-4 * Math.round(1e4 * e), r = 1e-4 * Math.round(1e4 * r), this.sValue = e, this.eValue = r } else e = this.sValue, r = this.eValue; let n; let o; let h; let l; let p; let m; const f = this.shapes.length; let c = 0; if (r === e) for (n = 0; n < f; n += 1) this.shapes[n].localShapeCollection.releaseShapes(), this.shapes[n].shape._mdf = !0, this.shapes[n].shape.paths = this.shapes[n].localShapeCollection; else if (r === 1 && e === 0 || r === 0 && e === 1) { if (this._mdf) for (n = 0; n < f; n += 1) this.shapes[n].pathsData.length = 0, this.shapes[n].shape._mdf = !0 } else { let d; let u; const y = []; for (n = 0; n < f; n += 1) if ((d = this.shapes[n]).shape._mdf || this._mdf || t || this.m === 2) { if (h = (i = d.shape.paths)._length, m = 0, !d.shape._mdf && d.pathsData.length)m = d.totalShapeLength; else { for (l = this.releasePathsData(d.pathsData), o = 0; o < h; o += 1)p = bez.getSegmentsLength(i.shapes[o]), l.push(p), m += p.totalLength; d.totalShapeLength = m, d.pathsData = l }c += m, d.shape._mdf = !0 } else d.shape.paths = d.localShapeCollection; let g; let v = e; let b = r; let E = 0; for (n = f - 1; n >= 0; n -= 1) if ((d = this.shapes[n]).shape._mdf) { for ((u = d.localShapeCollection).releaseShapes(), this.m === 2 && f > 1 ? (g = this.calculateShapeEdges(e, r, d.totalShapeLength, E, c), E += d.totalShapeLength) : g = [[v, b]], h = g.length, o = 0; o < h; o += 1) { v = g[o][0], b = g[o][1], y.length = 0, b <= 1 ? y.push({ s: d.totalShapeLength * v, e: d.totalShapeLength * b }) : v >= 1 ? y.push({ s: d.totalShapeLength * (v - 1), e: d.totalShapeLength * (b - 1) }) : (y.push({ s: d.totalShapeLength * v, e: d.totalShapeLength }), y.push({ s: 0, e: d.totalShapeLength * (b - 1) })); let x = this.addShapes(d, y[0]); if (y[0].s !== y[0].e) { if (y.length > 1) if (d.shape.paths.shapes[d.shape.paths._length - 1].c) { const S = x.pop(); this.addPaths(x, u), x = this.addShapes(d, y[1], S) } else this.addPaths(x, u), x = this.addShapes(d, y[1]); this.addPaths(x, u) } }d.shape.paths = u } } }, TrimModifier.prototype.addPaths = function (t, e) { let r; const i = t.length; for (r = 0; r < i; r += 1)e.addShape(t[r]) }, TrimModifier.prototype.addSegment = function (t, e, r, i, s, a, n) { s.setXYAt(e[0], e[1], 'o', a), s.setXYAt(r[0], r[1], 'i', a + 1), n && s.setXYAt(t[0], t[1], 'v', a), s.setXYAt(i[0], i[1], 'v', a + 1) }, TrimModifier.prototype.addSegmentFromArray = function (t, e, r, i) { e.setXYAt(t[1], t[5], 'o', r), e.setXYAt(t[2], t[6], 'i', r + 1), i && e.setXYAt(t[0], t[4], 'v', r), e.setXYAt(t[3], t[7], 'v', r + 1) }, TrimModifier.prototype.addShapes = function (t, e, r) { let i; let s; let a; let n; let o; let h; let l; let p; const m = t.pathsData; const f = t.shape.paths.shapes; const c = t.shape.paths._length; let d = 0; const u = []; let y = !0; for (p = r ? (o = r._length, r._length) : (r = shape_pool.newElement(), o = 0), u.push(r), i = 0; i < c; i += 1) { for (h = m[i].lengths, r.c = f[i].c, a = f[i].c ? h.length : h.length + 1, s = 1; s < a; s += 1) if (d + (n = h[s - 1]).addedLength < e.s)d += n.addedLength, r.c = !1; else { if (d > e.e) { r.c = !1; break }e.s <= d && e.e >= d + n.addedLength ? (this.addSegment(f[i].v[s - 1], f[i].o[s - 1], f[i].i[s], f[i].v[s], r, o, y), y = !1) : (l = bez.getNewSegment(f[i].v[s - 1], f[i].v[s], f[i].o[s - 1], f[i].i[s], (e.s - d) / n.addedLength, (e.e - d) / n.addedLength, h[s - 1]), this.addSegmentFromArray(l, r, o, y), y = !1, r.c = !1), d += n.addedLength, o += 1 } if (f[i].c && h.length) { if (n = h[s - 1], d <= e.e) { const g = h[s - 1].addedLength; e.s <= d && e.e >= d + g ? (this.addSegment(f[i].v[s - 1], f[i].o[s - 1], f[i].i[0], f[i].v[0], r, o, y), y = !1) : (l = bez.getNewSegment(f[i].v[s - 1], f[i].v[0], f[i].o[s - 1], f[i].i[0], (e.s - d) / g, (e.e - d) / g, h[s - 1]), this.addSegmentFromArray(l, r, o, y), y = !1, r.c = !1) } else r.c = !1; d += n.addedLength, o += 1 } if (r._length && (r.setXYAt(r.v[p][0], r.v[p][1], 'i', p), r.setXYAt(r.v[r._length - 1][0], r.v[r._length - 1][1], 'o', r._length - 1)), d > e.e) break; i < c - 1 && (r = shape_pool.newElement(), y = !0, u.push(r), o = 0) } return u }, ShapeModifiers.registerModifier('tm', TrimModifier), extendPrototype([ShapeModifier], RoundCornersModifier), RoundCornersModifier.prototype.initModifierProperties = function (t, e) { this.getValue = this.processKeys, this.rd = PropertyFactory.getProp(t, e.r, 0, null, this), this._isAnimated = !!this.rd.effectsSequence.length }, RoundCornersModifier.prototype.processPath = function (t, e) { const r = shape_pool.newElement(); r.c = t.c; let i; let s; let a; let n; let o; let h; let l; let p; let m; let f; let c; let d; let u; const y = t._length; let g = 0; for (i = 0; i < y; i += 1)s = t.v[i], n = t.o[i], a = t.i[i], s[0] === n[0] && s[1] === n[1] && s[0] === a[0] && s[1] === a[1] ? i !== 0 && i !== y - 1 || t.c ? (o = i === 0 ? t.v[y - 1] : t.v[i - 1], l = (h = Math.sqrt(Math.pow(s[0] - o[0], 2) + Math.pow(s[1] - o[1], 2))) ? Math.min(h / 2, e) / h : 0, p = d = s[0] + (o[0] - s[0]) * l, m = u = s[1] - (s[1] - o[1]) * l, f = p - (p - s[0]) * roundCorner, c = m - (m - s[1]) * roundCorner, r.setTripleAt(p, m, f, c, d, u, g), g += 1, o = i === y - 1 ? t.v[0] : t.v[i + 1], l = (h = Math.sqrt(Math.pow(s[0] - o[0], 2) + Math.pow(s[1] - o[1], 2))) ? Math.min(h / 2, e) / h : 0, p = f = s[0] + (o[0] - s[0]) * l, m = c = s[1] + (o[1] - s[1]) * l, d = p - (p - s[0]) * roundCorner, u = m - (m - s[1]) * roundCorner, r.setTripleAt(p, m, f, c, d, u, g)) : r.setTripleAt(s[0], s[1], n[0], n[1], a[0], a[1], g) : r.setTripleAt(t.v[i][0], t.v[i][1], t.o[i][0], t.o[i][1], t.i[i][0], t.i[i][1], g), g += 1; return r }, RoundCornersModifier.prototype.processShapes = function (t) { let e; let r; let i; let s; let a; let n; const o = this.shapes.length; const h = this.rd.v; if (h !== 0) for (r = 0; r < o; r += 1) { if ((a = this.shapes[r]).shape.paths, n = a.localShapeCollection, a.shape._mdf || this._mdf || t) for (n.releaseShapes(), a.shape._mdf = !0, e = a.shape.paths.shapes, s = a.shape.paths._length, i = 0; i < s; i += 1)n.addShape(this.processPath(e[i], h)); a.shape.paths = a.localShapeCollection } this.dynamicProperties.length || (this._mdf = !1) }, ShapeModifiers.registerModifier('rd', RoundCornersModifier), extendPrototype([ShapeModifier], RepeaterModifier), RepeaterModifier.prototype.initModifierProperties = function (t, e) { this.getValue = this.processKeys, this.c = PropertyFactory.getProp(t, e.c, 0, null, this), this.o = PropertyFactory.getProp(t, e.o, 0, null, this), this.tr = TransformPropertyFactory.getTransformProperty(t, e.tr, this), this.so = PropertyFactory.getProp(t, e.tr.so, 0, 0.01, this), this.eo = PropertyFactory.getProp(t, e.tr.eo, 0, 0.01, this), this.data = e, this.dynamicProperties.length || this.getValue(!0), this._isAnimated = !!this.dynamicProperties.length, this.pMatrix = new Matrix(), this.rMatrix = new Matrix(), this.sMatrix = new Matrix(), this.tMatrix = new Matrix(), this.matrix = new Matrix() }, RepeaterModifier.prototype.applyTransforms = function (t, e, r, i, s, a) { const n = a ? -1 : 1; const o = i.s.v[0] + (1 - i.s.v[0]) * (1 - s); const h = i.s.v[1] + (1 - i.s.v[1]) * (1 - s); t.translate(i.p.v[0] * n * s, i.p.v[1] * n * s, i.p.v[2]), e.translate(-i.a.v[0], -i.a.v[1], i.a.v[2]), e.rotate(-i.r.v * n * s), e.translate(i.a.v[0], i.a.v[1], i.a.v[2]), r.translate(-i.a.v[0], -i.a.v[1], i.a.v[2]), r.scale(a ? 1 / o : o, a ? 1 / h : h), r.translate(i.a.v[0], i.a.v[1], i.a.v[2]) }, RepeaterModifier.prototype.init = function (t, e, r, i) { this.elem = t, this.arr = e, this.pos = r, this.elemsData = i, this._currentCopies = 0, this._elements = [], this._groups = [], this.frameId = -1, this.initDynamicPropertyContainer(t), this.initModifierProperties(t, e[r]); for (;r > 0;)r -= 1, this._elements.unshift(e[r]), 1; this.dynamicProperties.length ? this.k = !0 : this.getValue(!0) }, RepeaterModifier.prototype.resetElements = function (t) { let e; const r = t.length; for (e = 0; e < r; e += 1)t[e]._processed = !1, t[e].ty === 'gr' && this.resetElements(t[e].it) }, RepeaterModifier.prototype.cloneElements = function (t) { t.length; const e = JSON.parse(JSON.stringify(t)); return this.resetElements(e), e }, RepeaterModifier.prototype.changeGroupRender = function (t, e) { let r; const i = t.length; for (r = 0; r < i; r += 1)t[r]._render = e, t[r].ty === 'gr' && this.changeGroupRender(t[r].it, e) }, RepeaterModifier.prototype.processShapes = function (t) {
    let e; let r; let i; let s; let a; if (this._mdf || t) {
      let n; const o = Math.ceil(this.c.v); if (this._groups.length < o) {
        for (;this._groups.length < o;) {
          const h = { it: this.cloneElements(this._elements), ty: 'gr' }; h.it.push({
            a: { a: 0, ix: 1, k: [0, 0] }, nm: 'Transform', o: { a: 0, ix: 7, k: 100 }, p: { a: 0, ix: 2, k: [0, 0] }, r: { a: 1, ix: 6, k: [{ s: 0, e: 0, t: 0 }, { s: 0, e: 0, t: 1 }] }, s: { a: 0, ix: 3, k: [100, 100] }, sa: { a: 0, ix: 5, k: 0 }, sk: { a: 0, ix: 4, k: 0 }, ty: 'tr'
          }), this.arr.splice(0, 0, h), this._groups.splice(0, 0, h), this._currentCopies += 1
        } this.elem.reloadShapes()
      } for (i = a = 0; i <= this._groups.length - 1; i += 1)n = a < o, this._groups[i]._render = n, this.changeGroupRender(this._groups[i].it, n), a += 1; this._currentCopies = o; const l = this.o.v; const p = l % 1; const m = l > 0 ? Math.floor(l) : Math.ceil(l); const f = (this.tr.v.props, this.pMatrix.props); const c = this.rMatrix.props; const d = this.sMatrix.props; this.pMatrix.reset(), this.rMatrix.reset(), this.sMatrix.reset(), this.tMatrix.reset(), this.matrix.reset(); let u; let y; let g = 0; if (l > 0) { for (;g < m;) this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), g += 1; p && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, p, !1), g += p) } else if (l < 0) { for (;m < g;) this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0), g -= 1; p && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -p, !0), g -= p) } for (i = this.data.m === 1 ? 0 : this._currentCopies - 1, s = this.data.m === 1 ? 1 : -1, a = this._currentCopies; a;) { if (y = (r = (e = this.elemsData[i].it)[e.length - 1].transform.mProps.v.props).length, e[e.length - 1].transform.mProps._mdf = !0, e[e.length - 1].transform.op._mdf = !0, e[e.length - 1].transform.op.v = this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1)), g !== 0) { for ((i !== 0 && s === 1 || i !== this._currentCopies - 1 && s === -1) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), this.matrix.transform(c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7], c[8], c[9], c[10], c[11], c[12], c[13], c[14], c[15]), this.matrix.transform(d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], d[8], d[9], d[10], d[11], d[12], d[13], d[14], d[15]), this.matrix.transform(f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9], f[10], f[11], f[12], f[13], f[14], f[15]), u = 0; u < y; u += 1)r[u] = this.matrix.props[u]; this.matrix.reset() } else for (this.matrix.reset(), u = 0; u < y; u += 1)r[u] = this.matrix.props[u]; g += 1, a -= 1, i += s }
    } else for (a = this._currentCopies, i = 0, s = 1; a;)r = (e = this.elemsData[i].it)[e.length - 1].transform.mProps.v.props, e[e.length - 1].transform.mProps._mdf = !1, e[e.length - 1].transform.op._mdf = !1, a -= 1, i += s
  }, RepeaterModifier.prototype.addShape = function () {}, ShapeModifiers.registerModifier('rp', RepeaterModifier), ShapeCollection.prototype.addShape = function (t) { this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)), this._maxLength *= 2), this.shapes[this._length] = t, this._length += 1 }, ShapeCollection.prototype.releaseShapes = function () { let t; for (t = 0; t < this._length; t += 1)shape_pool.release(this.shapes[t]); this._length = 0 }, DashProperty.prototype.getValue = function (t) { if ((this.elem.globalData.frameId !== this.frameId || t) && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf = this._mdf || t, this._mdf)) { let e = 0; const r = this.dataProps.length; for (this.renderer === 'svg' && (this.dashStr = ''), e = 0; e < r; e += 1) this.dataProps[e].n != 'o' ? this.renderer === 'svg' ? this.dashStr += ` ${this.dataProps[e].p.v}` : this.dashArray[e] = this.dataProps[e].p.v : this.dashoffset[0] = this.dataProps[e].p.v } }, extendPrototype([DynamicPropertyContainer], DashProperty), GradientProperty.prototype.comparePoints = function (t, e) { for (let r = 0, i = this.o.length / 2; r < i;) { if (Math.abs(t[4 * r] - t[4 * e + 2 * r]) > 0.01) return !1; r += 1 } return !0 }, GradientProperty.prototype.checkCollapsable = function () { if (this.o.length / 2 != this.c.length / 4) return !1; if (this.data.k.k[0].s) for (let t = 0, e = this.data.k.k.length; t < e;) { if (!this.comparePoints(this.data.k.k[t].s, this.data.p)) return !1; t += 1 } else if (!this.comparePoints(this.data.k.k, this.data.p)) return !1; return !0 }, GradientProperty.prototype.getValue = function (t) { if (this.prop.getValue(), this._mdf = !1, this._cmdf = !1, this._omdf = !1, this.prop._mdf || t) { let e; let r; let i; let s = 4 * this.data.p; for (e = 0; e < s; e += 1)r = e % 4 == 0 ? 100 : 255, i = Math.round(this.prop.v[e] * r), this.c[e] !== i && (this.c[e] = i, this._cmdf = !t); if (this.o.length) for (s = this.prop.v.length, e = 4 * this.data.p; e < s; e += 1)r = e % 2 == 0 ? 100 : 1, i = e % 2 == 0 ? Math.round(100 * this.prop.v[e]) : this.prop.v[e], this.o[e - 4 * this.data.p] !== i && (this.o[e - 4 * this.data.p] = i, this._omdf = !t); this._mdf = !t } }, extendPrototype([DynamicPropertyContainer], GradientProperty); const buildShapeString = function (t, e, r, i) { if (e === 0) return ''; let s; const a = t.o; const n = t.i; const o = t.v; let h = ` M${i.applyToPointStringified(o[0][0], o[0][1])}`; for (s = 1; s < e; s += 1)h += ` C${i.applyToPointStringified(a[s - 1][0], a[s - 1][1])} ${i.applyToPointStringified(n[s][0], n[s][1])} ${i.applyToPointStringified(o[s][0], o[s][1])}`; return r && e && (h += ` C${i.applyToPointStringified(a[s - 1][0], a[s - 1][1])} ${i.applyToPointStringified(n[0][0], n[0][1])} ${i.applyToPointStringified(o[0][0], o[0][1])}`, h += 'z'), h }; const ImagePreloader = (function () { const s = (function () { const t = createTag('canvas'); t.width = 1, t.height = 1; const e = t.getContext('2d'); return e.fillStyle = 'rgba(0,0,0,0)', e.fillRect(0, 0, 1, 1), t }()); function t() { this.loadedAssets += 1, this.loadedAssets === this.totalImages && this.imagesLoadedCb && this.imagesLoadedCb(null) } function e(t) { const e = (function (t, e, r) { let i = ''; if (t.e)i = t.p; else if (e) { let s = t.p; s.indexOf('images/') !== -1 && (s = s.split('/')[1]), i = e + s } else i = r, i += t.u ? t.u : '', i += t.p; return i }(t, this.assetsPath, this.path)); const r = createTag('img'); r.crossOrigin = 'anonymous', r.addEventListener('load', this._imageLoaded.bind(this), !1), r.addEventListener('error', () => { i.img = s, this._imageLoaded() }, !1), r.src = e; var i = { img: r, assetData: t }; return i } function r(t, e) { this.imagesLoadedCb = e; let r; const i = t.length; for (r = 0; r < i; r += 1)t[r].layers || (this.totalImages += 1, this.images.push(this._createImageData(t[r]))) } function i(t) { this.path = t || '' } function a(t) { this.assetsPath = t || '' } function n(t) { for (let e = 0, r = this.images.length; e < r;) { if (this.images[e].assetData === t) return this.images[e].img; e += 1 } } function o() { this.imagesLoadedCb = null, this.images.length = 0 } function h() { return this.totalImages === this.loadedAssets } return function () { this.loadAssets = r, this.setAssetsPath = a, this.setPath = i, this.loaded = h, this.destroy = o, this.getImage = n, this._createImageData = e, this._imageLoaded = t, this.assetsPath = '', this.path = '', this.totalImages = 0, this.loadedAssets = 0, this.imagesLoadedCb = null, this.images = [] } }()); const featureSupport = (sw = { maskType: !0 }, (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (sw.maskType = !1), sw); let sw; const filtersFactory = (tw = {}, tw.createFilter = function (t) { const e = createNS('filter'); return e.setAttribute('id', t), e.setAttribute('filterUnits', 'objectBoundingBox'), e.setAttribute('x', '0%'), e.setAttribute('y', '0%'), e.setAttribute('width', '100%'), e.setAttribute('height', '100%'), e }, tw.createAlphaToLuminanceFilter = function () { const t = createNS('feColorMatrix'); return t.setAttribute('type', 'matrix'), t.setAttribute('color-interpolation-filters', 'sRGB'), t.setAttribute('values', '0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1'), t }, tw); let tw; const assetLoader = (function () { function a(t) { return t.response && typeof t.response === 'object' ? t.response : t.response && typeof t.response === 'string' ? JSON.parse(t.response) : t.responseText ? JSON.parse(t.responseText) : void 0 } return { load(t, e, r) { let i; const s = new XMLHttpRequest(); s.open('GET', t, !0); try { s.responseType = 'json' } catch (t) {}s.send(), s.onreadystatechange = function () { if (s.readyState == 4) if (s.status == 200)i = a(s), e(i); else try { i = a(s), e(i) } catch (t) { r && r(t) } } } } }()); function TextAnimatorProperty(t, e, r) { this._isFirstFrame = !0, this._hasMaskedPath = !1, this._frameId = -1, this._textData = t, this._renderType = e, this._elem = r, this._animatorsData = createSizedArray(this._textData.a.length), this._pathData = {}, this._moreOptions = { alignment: {} }, this.renderedLetters = [], this.lettersChangedFlag = !1, this.initDynamicPropertyContainer(r) } function TextAnimatorDataProperty(t, e, r) {
    const i = { propType: !1 }; const s = PropertyFactory.getProp; const { a } = e; this.a = {
      r: a.r ? s(t, a.r, 0, degToRads, r) : i, rx: a.rx ? s(t, a.rx, 0, degToRads, r) : i, ry: a.ry ? s(t, a.ry, 0, degToRads, r) : i, sk: a.sk ? s(t, a.sk, 0, degToRads, r) : i, sa: a.sa ? s(t, a.sa, 0, degToRads, r) : i, s: a.s ? s(t, a.s, 1, 0.01, r) : i, a: a.a ? s(t, a.a, 1, 0, r) : i, o: a.o ? s(t, a.o, 0, 0.01, r) : i, p: a.p ? s(t, a.p, 1, 0, r) : i, sw: a.sw ? s(t, a.sw, 0, 0, r) : i, sc: a.sc ? s(t, a.sc, 1, 0, r) : i, fc: a.fc ? s(t, a.fc, 1, 0, r) : i, fh: a.fh ? s(t, a.fh, 0, 0, r) : i, fs: a.fs ? s(t, a.fs, 0, 0.01, r) : i, fb: a.fb ? s(t, a.fb, 0, 0.01, r) : i, t: a.t ? s(t, a.t, 0, 0, r) : i
    }, this.s = TextSelectorProp.getTextSelectorProp(t, e.s, r), this.s.t = e.s.t
  } function LetterProps(t, e, r, i, s, a) {
    this.o = t, this.sw = e, this.sc = r, this.fc = i, this.m = s, this.p = a, this._mdf = {
      o: !0, sw: !!e, sc: !!r, fc: !!i, m: !0, p: !0
    }
  } function TextProperty(t, e) {
    this._frameId = initialDefaultFrame, this.pv = '', this.v = '', this.kf = !1, this._isFirstFrame = !0, this._mdf = !1, this.data = e, this.elem = t, this.comp = this.elem.comp, this.keysIndex = 0, this.canResize = !1, this.minimumFontSize = 1, this.effectsSequence = [], this.currentData = {
      ascent: 0, boxWidth: this.defaultBoxWidth, f: '', fStyle: '', fWeight: '', fc: '', j: '', justifyOffset: '', l: [], lh: 0, lineWidths: [], ls: '', of: '', s: '', sc: '', sw: 0, t: 0, tr: 0, sz: 0, ps: null, fillColorAnim: !1, strokeColorAnim: !1, strokeWidthAnim: !1, yOffset: 0, finalSize: 0, finalText: [], finalLineHeight: 0, __complete: !1
    }, this.copyData(this.currentData, this.data.d.k[0].s), this.searchProperty() || this.completeTextData(this.currentData)
  }TextAnimatorProperty.prototype.searchProperties = function () {
    let t; let e; const r = this._textData.a.length; const i = PropertyFactory.getProp; for (t = 0; t < r; t += 1)e = this._textData.a[t], this._animatorsData[t] = new TextAnimatorDataProperty(this._elem, e, this); this._textData.p && 'm' in this._textData.p ? (this._pathData = {
      f: i(this._elem, this._textData.p.f, 0, 0, this), l: i(this._elem, this._textData.p.l, 0, 0, this), r: this._textData.p.r, m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
    }, this._hasMaskedPath = !0) : this._hasMaskedPath = !1, this._moreOptions.alignment = i(this._elem, this._textData.m.a, 1, 0, this)
  }, TextAnimatorProperty.prototype.getMeasures = function (t, e) { if (this.lettersChangedFlag = e, this._mdf || this._isFirstFrame || e || this._hasMaskedPath && this._pathData.m._mdf) { this._isFirstFrame = !1; let r; let i; let s; let a; let n; let o; let h; let l; let p; let m; let f; let c; let d; let u; let y; let g; let v; let b; let E; const x = this._moreOptions.alignment.v; const S = this._animatorsData; const P = this._textData; const _ = this.mHelper; const A = this._renderType; let C = this.renderedLetters.length; const T = (this.data, t.l); if (this._hasMaskedPath) { if (E = this._pathData.m, !this._pathData.n || this._pathData._mdf) { let k; let M = E.v; for (this._pathData.r && (M = M.reverse()), n = { tLength: 0, segments: [] }, a = M._length - 1, s = g = 0; s < a; s += 1)k = bez.buildBezierData(M.v[s], M.v[s + 1], [M.o[s][0] - M.v[s][0], M.o[s][1] - M.v[s][1]], [M.i[s + 1][0] - M.v[s + 1][0], M.i[s + 1][1] - M.v[s + 1][1]]), n.tLength += k.segmentLength, n.segments.push(k), g += k.segmentLength; s = a, E.v.c && (k = bez.buildBezierData(M.v[s], M.v[0], [M.o[s][0] - M.v[s][0], M.o[s][1] - M.v[s][1]], [M.i[0][0] - M.v[0][0], M.i[0][1] - M.v[0][1]]), n.tLength += k.segmentLength, n.segments.push(k), g += k.segmentLength), this._pathData.pi = n } if (n = this._pathData.pi, o = this._pathData.f.v, m = 1, p = !(l = f = 0), u = n.segments, o < 0 && E.v.c) for (n.tLength < Math.abs(o) && (o = -Math.abs(o) % n.tLength), m = (d = u[f = u.length - 1].points).length - 1; o < 0;)o += d[m].partialLength, (m -= 1) < 0 && (m = (d = u[f -= 1].points).length - 1); c = (d = u[f].points)[m - 1], y = (h = d[m]).partialLength }a = T.length, i = r = 0; let D; let w; let F; let I; const V = 1.2 * t.finalSize * 0.714; let R = !0; F = S.length; let B; let L; let G; let z; let N; let O; let H; let j; let q; let W; let Y; let X; let $; let K = -1; const U = o; const J = f; const Z = m; let Q = -1; let tt = ''; let et = this.defaultPropsArray; if (t.j === 2 || t.j === 1) { let rt = 0; let it = 0; const st = t.j === 2 ? -0.5 : -1; let at = 0; let nt = !0; for (s = 0; s < a; s += 1) if (T[s].n) { for (rt && (rt += it); at < s;)T[at].animatorJustifyOffset = rt, at += 1; nt = !(rt = 0) } else { for (w = 0; w < F; w += 1)(D = S[w].a).t.propType && (nt && t.j === 2 && (it += D.t.v * st), (B = S[w].s.getMult(T[s].anIndexes[w], P.a[w].s.totalChars)).length ? rt += D.t.v * B[0] * st : rt += D.t.v * B * st); nt = !1 } for (rt && (rt += it); at < s;)T[at].animatorJustifyOffset = rt, at += 1 } for (s = 0; s < a; s += 1) { if (_.reset(), N = 1, T[s].n)r = 0, i += t.yOffset, i += R ? 1 : 0, o = U, R = !1, 0, this._hasMaskedPath && (m = Z, c = (d = u[f = J].points)[m - 1], y = (h = d[m]).partialLength, l = 0), $ = W = X = tt = '', et = this.defaultPropsArray; else { if (this._hasMaskedPath) { if (Q !== T[s].line) { switch (t.j) { case 1: o += g - t.lineWidths[T[s].line]; break; case 2: o += (g - t.lineWidths[T[s].line]) / 2 }Q = T[s].line }K !== T[s].ind && (T[K] && (o += T[K].extra), o += T[s].an / 2, K = T[s].ind), o += x[0] * T[s].an / 200; let ot = 0; for (w = 0; w < F; w += 1)(D = S[w].a).p.propType && ((B = S[w].s.getMult(T[s].anIndexes[w], P.a[w].s.totalChars)).length ? ot += D.p.v[0] * B[0] : ot += D.p.v[0] * B), D.a.propType && ((B = S[w].s.getMult(T[s].anIndexes[w], P.a[w].s.totalChars)).length ? ot += D.a.v[0] * B[0] : ot += D.a.v[0] * B); for (p = !0; p;)o + ot <= l + y || !d ? (v = (o + ot - l) / h.partialLength, G = c.point[0] + (h.point[0] - c.point[0]) * v, z = c.point[1] + (h.point[1] - c.point[1]) * v, _.translate(-x[0] * T[s].an / 200, -x[1] * V / 100), p = !1) : d && (l += h.partialLength, (m += 1) >= d.length && (m = 0, d = u[f += 1] ? u[f].points : E.v.c ? u[f = m = 0].points : (l -= h.partialLength, null)), d && (c = h, y = (h = d[m]).partialLength)); L = T[s].an / 2 - T[s].add, _.translate(-L, 0, 0) } else L = T[s].an / 2 - T[s].add, _.translate(-L, 0, 0), _.translate(-x[0] * T[s].an / 200, -x[1] * V / 100, 0); for (T[s].l / 2, w = 0; w < F; w += 1)(D = S[w].a).t.propType && (B = S[w].s.getMult(T[s].anIndexes[w], P.a[w].s.totalChars), r === 0 && t.j === 0 || (this._hasMaskedPath ? B.length ? o += D.t.v * B[0] : o += D.t.v * B : B.length ? r += D.t.v * B[0] : r += D.t.v * B)); for (T[s].l / 2, t.strokeWidthAnim && (H = t.sw || 0), t.strokeColorAnim && (O = t.sc ? [t.sc[0], t.sc[1], t.sc[2]] : [0, 0, 0]), t.fillColorAnim && t.fc && (j = [t.fc[0], t.fc[1], t.fc[2]]), w = 0; w < F; w += 1)(D = S[w].a).a.propType && ((B = S[w].s.getMult(T[s].anIndexes[w], P.a[w].s.totalChars)).length ? _.translate(-D.a.v[0] * B[0], -D.a.v[1] * B[1], D.a.v[2] * B[2]) : _.translate(-D.a.v[0] * B, -D.a.v[1] * B, D.a.v[2] * B)); for (w = 0; w < F; w += 1)(D = S[w].a).s.propType && ((B = S[w].s.getMult(T[s].anIndexes[w], P.a[w].s.totalChars)).length ? _.scale(1 + (D.s.v[0] - 1) * B[0], 1 + (D.s.v[1] - 1) * B[1], 1) : _.scale(1 + (D.s.v[0] - 1) * B, 1 + (D.s.v[1] - 1) * B, 1)); for (w = 0; w < F; w += 1) { if (D = S[w].a, B = S[w].s.getMult(T[s].anIndexes[w], P.a[w].s.totalChars), D.sk.propType && (B.length ? _.skewFromAxis(-D.sk.v * B[0], D.sa.v * B[1]) : _.skewFromAxis(-D.sk.v * B, D.sa.v * B)), D.r.propType && (B.length ? _.rotateZ(-D.r.v * B[2]) : _.rotateZ(-D.r.v * B)), D.ry.propType && (B.length ? _.rotateY(D.ry.v * B[1]) : _.rotateY(D.ry.v * B)), D.rx.propType && (B.length ? _.rotateX(D.rx.v * B[0]) : _.rotateX(D.rx.v * B)), D.o.propType && (B.length ? N += (D.o.v * B[0] - N) * B[0] : N += (D.o.v * B - N) * B), t.strokeWidthAnim && D.sw.propType && (B.length ? H += D.sw.v * B[0] : H += D.sw.v * B), t.strokeColorAnim && D.sc.propType) for (q = 0; q < 3; q += 1)B.length ? O[q] = O[q] + (D.sc.v[q] - O[q]) * B[0] : O[q] = O[q] + (D.sc.v[q] - O[q]) * B; if (t.fillColorAnim && t.fc) { if (D.fc.propType) for (q = 0; q < 3; q += 1)B.length ? j[q] = j[q] + (D.fc.v[q] - j[q]) * B[0] : j[q] = j[q] + (D.fc.v[q] - j[q]) * B; D.fh.propType && (j = B.length ? addHueToRGB(j, D.fh.v * B[0]) : addHueToRGB(j, D.fh.v * B)), D.fs.propType && (j = B.length ? addSaturationToRGB(j, D.fs.v * B[0]) : addSaturationToRGB(j, D.fs.v * B)), D.fb.propType && (j = B.length ? addBrightnessToRGB(j, D.fb.v * B[0]) : addBrightnessToRGB(j, D.fb.v * B)) } } for (w = 0; w < F; w += 1)(D = S[w].a).p.propType && (B = S[w].s.getMult(T[s].anIndexes[w], P.a[w].s.totalChars), this._hasMaskedPath ? B.length ? _.translate(0, D.p.v[1] * B[0], -D.p.v[2] * B[1]) : _.translate(0, D.p.v[1] * B, -D.p.v[2] * B) : B.length ? _.translate(D.p.v[0] * B[0], D.p.v[1] * B[1], -D.p.v[2] * B[2]) : _.translate(D.p.v[0] * B, D.p.v[1] * B, -D.p.v[2] * B)); if (t.strokeWidthAnim && (W = H < 0 ? 0 : H), t.strokeColorAnim && (Y = `rgb(${Math.round(255 * O[0])},${Math.round(255 * O[1])},${Math.round(255 * O[2])})`), t.fillColorAnim && t.fc && (X = `rgb(${Math.round(255 * j[0])},${Math.round(255 * j[1])},${Math.round(255 * j[2])})`), this._hasMaskedPath) { if (_.translate(0, -t.ls), _.translate(0, x[1] * V / 100 + i, 0), P.p.p) { b = (h.point[1] - c.point[1]) / (h.point[0] - c.point[0]); let ht = 180 * Math.atan(b) / Math.PI; h.point[0] < c.point[0] && (ht += 180), _.rotate(-ht * Math.PI / 180) }_.translate(G, z, 0), o -= x[0] * T[s].an / 200, T[s + 1] && K !== T[s + 1].ind && (o += T[s].an / 2, o += t.tr / 1e3 * t.finalSize) } else { switch (_.translate(r, i, 0), t.ps && _.translate(t.ps[0], t.ps[1] + t.ascent, 0), t.j) { case 1: _.translate(T[s].animatorJustifyOffset + t.justifyOffset + (t.boxWidth - t.lineWidths[T[s].line]), 0, 0); break; case 2: _.translate(T[s].animatorJustifyOffset + t.justifyOffset + (t.boxWidth - t.lineWidths[T[s].line]) / 2, 0, 0) }_.translate(0, -t.ls), _.translate(L, 0, 0), _.translate(x[0] * T[s].an / 200, x[1] * V / 100, 0), r += T[s].l + t.tr / 1e3 * t.finalSize }A === 'html' ? tt = _.toCSS() : A === 'svg' ? tt = _.to2dCSS() : et = [_.props[0], _.props[1], _.props[2], _.props[3], _.props[4], _.props[5], _.props[6], _.props[7], _.props[8], _.props[9], _.props[10], _.props[11], _.props[12], _.props[13], _.props[14], _.props[15]], $ = N } this.lettersChangedFlag = C <= s ? (I = new LetterProps($, W, Y, X, tt, et), this.renderedLetters.push(I), C += 1, !0) : (I = this.renderedLetters[s]).update($, W, Y, X, tt, et) || this.lettersChangedFlag } } }, TextAnimatorProperty.prototype.getValue = function () { this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId, this.iterateDynamicProperties()) }, TextAnimatorProperty.prototype.mHelper = new Matrix(), TextAnimatorProperty.prototype.defaultPropsArray = [], extendPrototype([DynamicPropertyContainer], TextAnimatorProperty), LetterProps.prototype.update = function (t, e, r, i, s, a) { this._mdf.o = !1, this._mdf.sw = !1, this._mdf.sc = !1, this._mdf.fc = !1, this._mdf.m = !1; let n = this._mdf.p = !1; return this.o !== t && (this.o = t, n = this._mdf.o = !0), this.sw !== e && (this.sw = e, n = this._mdf.sw = !0), this.sc !== r && (this.sc = r, n = this._mdf.sc = !0), this.fc !== i && (this.fc = i, n = this._mdf.fc = !0), this.m !== s && (this.m = s, n = this._mdf.m = !0), !a.length || this.p[0] === a[0] && this.p[1] === a[1] && this.p[4] === a[4] && this.p[5] === a[5] && this.p[12] === a[12] && this.p[13] === a[13] || (this.p = a, n = this._mdf.p = !0), n }, TextProperty.prototype.defaultBoxWidth = [0, 0], TextProperty.prototype.copyData = function (t, e) { for (const r in e)e.hasOwnProperty(r) && (t[r] = e[r]); return t }, TextProperty.prototype.setCurrentData = function (t) { t.__complete || this.completeTextData(t), this.currentData = t, this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth, this._mdf = !0 }, TextProperty.prototype.searchProperty = function () { return this.searchKeyframes() }, TextProperty.prototype.searchKeyframes = function () { return this.kf = this.data.d.k.length > 1, this.kf && this.addEffect(this.getKeyframeValue.bind(this)), this.kf }, TextProperty.prototype.addEffect = function (t) { this.effectsSequence.push(t), this.elem.addDynamicProperty(this) }, TextProperty.prototype.getValue = function (t) { if (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length || t) { this.currentData.t = this.data.d.k[this.keysIndex].s.t; const e = this.currentData; const r = this.keysIndex; if (this.lock) this.setCurrentData(this.currentData); else { this.lock = !0, this._mdf = !1; let i; const s = this.effectsSequence.length; let a = t || this.data.d.k[this.keysIndex].s; for (i = 0; i < s; i += 1)a = r !== this.keysIndex ? this.effectsSequence[i](a, a.t) : this.effectsSequence[i](this.currentData, a.t); e !== a && this.setCurrentData(a), this.pv = this.v = this.currentData, this.lock = !1, this.frameId = this.elem.globalData.frameId } } }, TextProperty.prototype.getKeyframeValue = function () { for (var t = this.data.d.k, e = this.elem.comp.renderedFrame, r = 0, i = t.length; r <= i - 1 && (t[r].s, !(r === i - 1 || t[r + 1].t > e));)r += 1; return this.keysIndex !== r && (this.keysIndex = r), this.data.d.k[this.keysIndex].s }, TextProperty.prototype.buildFinalText = function (t) { for (var e, r = FontManager.getCombinedCharacterCodes(), i = [], s = 0, a = t.length; s < a;)e = t.charCodeAt(s), r.indexOf(e) !== -1 ? i[i.length - 1] += t.charAt(s) : e >= 55296 && e <= 56319 && (e = t.charCodeAt(s + 1)) >= 56320 && e <= 57343 ? (i.push(t.substr(s, 2)), ++s) : i.push(t.charAt(s)), s += 1; return i }, TextProperty.prototype.completeTextData = function (t) {
    t.__complete = !0; let e; let r; let i; let s; let a; let n; let o; const h = this.elem.globalData.fontManager; const l = this.data; const p = []; let m = 0; const f = l.m.g; let c = 0; let d = 0; let u = 0; const y = []; let g = 0; let v = 0; const b = h.getFontByName(t.f); let E = 0; const x = b.fStyle ? b.fStyle.split(' ') : []; let S = 'normal'; let P = 'normal'; for (r = x.length, e = 0; e < r; e += 1) switch (x[e].toLowerCase()) { case 'italic': P = 'italic'; break; case 'bold': S = '700'; break; case 'black': S = '900'; break; case 'medium': S = '500'; break; case 'regular': case 'normal': S = '400'; break; case 'light': case 'thin': S = '200' }t.fWeight = b.fWeight || S, t.fStyle = P, t.finalSize = t.s, t.finalText = this.buildFinalText(t.t), r = t.finalText.length, t.finalLineHeight = t.lh; let _; let A = t.tr / 1e3 * t.finalSize; if (t.sz) for (var C, T, k = !0, M = t.sz[0], D = t.sz[1]; k;) { g = C = 0, r = (T = this.buildFinalText(t.t)).length, A = t.tr / 1e3 * t.finalSize; let w = -1; for (e = 0; e < r; e += 1)_ = T[e].charCodeAt(0), i = !1, T[e] === ' ' ? w = e : _ !== 13 && _ !== 3 || (i = !(g = 0), C += t.finalLineHeight || 1.2 * t.finalSize), M < g + (E = h.chars ? (o = h.getCharData(T[e], b.fStyle, b.fFamily), i ? 0 : o.w * t.finalSize / 100) : h.measureText(T[e], t.f, t.finalSize)) && T[e] !== ' ' ? (w === -1 ? r += 1 : e = w, C += t.finalLineHeight || 1.2 * t.finalSize, T.splice(e, w === e ? 1 : 0, '\r'), w = -1, g = 0) : (g += E, g += A); C += b.ascent * t.finalSize / 100, this.canResize && t.finalSize > this.minimumFontSize && D < C ? (t.finalSize -= 1, t.finalLineHeight = t.finalSize * t.lh / t.s) : (t.finalText = T, r = t.finalText.length, k = !1) }g = -A; let F; let I = E = 0; for (e = 0; e < r; e += 1) {
      if (i = !1, _ = (F = t.finalText[e]).charCodeAt(0), F === ' ' ? s = '\xa0' : _ === 13 || _ === 3 ? (I = 0, y.push(g), v = v < g ? g : v, g = -2 * A, i = !(s = ''), u += 1) : s = t.finalText[e], E = h.chars ? (o = h.getCharData(F, b.fStyle, h.getFontByName(t.f).fFamily), i ? 0 : o.w * t.finalSize / 100) : h.measureText(s, t.f, t.finalSize), F === ' ' ? I += E + A : (g += E + A + I, I = 0), p.push({
        l: E, an: E, add: c, n: i, anIndexes: [], val: s, line: u, animatorJustifyOffset: 0
      }), f == 2) { if (c += E, s === '' || s === '\xa0' || e === r - 1) { for (s !== '' && s !== '\xa0' || (c -= E); d <= e;)p[d].an = c, p[d].ind = m, p[d].extra = E, d += 1; m += 1, c = 0 } } else if (f == 3) { if (c += E, s === '' || e === r - 1) { for (s === '' && (c -= E); d <= e;)p[d].an = c, p[d].ind = m, p[d].extra = E, d += 1; c = 0, m += 1 } } else p[m].ind = m, p[m].extra = 0, m += 1
    } if (t.l = p, v = v < g ? g : v, y.push(g), t.sz)t.boxWidth = t.sz[0], t.justifyOffset = 0; else switch (t.boxWidth = v, t.j) { case 1: t.justifyOffset = -t.boxWidth; break; case 2: t.justifyOffset = -t.boxWidth / 2; break; default: t.justifyOffset = 0 }t.lineWidths = y; let V; let R; const B = l.a; n = B.length; let L; let G; const z = []; for (a = 0; a < n; a += 1) { for ((V = B[a]).a.sc && (t.strokeColorAnim = !0), V.a.sw && (t.strokeWidthAnim = !0), (V.a.fc || V.a.fh || V.a.fs || V.a.fb) && (t.fillColorAnim = !0), G = 0, L = V.s.b, e = 0; e < r; e += 1)(R = p[e]).anIndexes[a] = G, (L == 1 && R.val !== '' || L == 2 && R.val !== '' && R.val !== '\xa0' || L == 3 && (R.n || R.val == '\xa0' || e == r - 1) || L == 4 && (R.n || e == r - 1)) && (V.s.rn === 1 && z.push(G), G += 1); l.a[a].s.totalChars = G; var N; let O = -1; if (V.s.rn === 1) for (e = 0; e < r; e += 1)O != (R = p[e]).anIndexes[a] && (O = R.anIndexes[a], N = z.splice(Math.floor(Math.random() * z.length), 1)[0]), R.anIndexes[a] = N }t.yOffset = t.finalLineHeight || 1.2 * t.finalSize, t.ls = t.ls || 0, t.ascent = b.ascent * t.finalSize / 100
  }, TextProperty.prototype.updateDocumentData = function (t, e) { e = void 0 === e ? this.keysIndex : e; let r = this.copyData({}, this.data.d.k[e].s); r = this.copyData(r, t), this.data.d.k[e].s = r, this.recalculate(e), this.elem.addDynamicProperty(this) }, TextProperty.prototype.recalculate = function (t) { const e = this.data.d.k[t].s; e.__complete = !1, this.keysIndex = 0, this._isFirstFrame = !0, this.getValue(e) }, TextProperty.prototype.canResizeFont = function (t) { this.canResize = t, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this) }, TextProperty.prototype.setMinimumFontSize = function (t) { this.minimumFontSize = Math.floor(t) || 1, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this) }; var TextSelectorProp = (function () { const c = Math.max; const d = Math.min; const u = Math.floor; function i(t, e) { this._currentTextLength = -1, this.k = !1, this.data = e, this.elem = t, this.comp = t.comp, this.finalS = 0, this.finalE = 0, this.initDynamicPropertyContainer(t), this.s = PropertyFactory.getProp(t, e.s || { k: 0 }, 0, 0, this), this.e = 'e' in e ? PropertyFactory.getProp(t, e.e, 0, 0, this) : { v: 100 }, this.o = PropertyFactory.getProp(t, e.o || { k: 0 }, 0, 0, this), this.xe = PropertyFactory.getProp(t, e.xe || { k: 0 }, 0, 0, this), this.ne = PropertyFactory.getProp(t, e.ne || { k: 0 }, 0, 0, this), this.a = PropertyFactory.getProp(t, e.a, 0, 0.01, this), this.dynamicProperties.length || this.getValue() } return i.prototype = { getMult(t) { this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue(); let e = 0; let r = 0; let i = 1; let s = 1; this.ne.v > 0 ? e = this.ne.v / 100 : r = -this.ne.v / 100, this.xe.v > 0 ? i = 1 - this.xe.v / 100 : s = 1 + this.xe.v / 100; const a = BezierFactory.getBezierEasing(e, r, i, s).get; let n = 0; const o = this.finalS; const h = this.finalE; const l = this.data.sh; if (l === 2)n = a(n = h === o ? h <= t ? 1 : 0 : c(0, d(0.5 / (h - o) + (t - o) / (h - o), 1))); else if (l === 3)n = a(n = h === o ? h <= t ? 0 : 1 : 1 - c(0, d(0.5 / (h - o) + (t - o) / (h - o), 1))); else if (l === 4)h === o ? n = 0 : (n = c(0, d(0.5 / (h - o) + (t - o) / (h - o), 1))) < 0.5 ? n *= 2 : n = 1 - 2 * (n - 0.5), n = a(n); else if (l === 5) { if (h === o)n = 0; else { const p = h - o; const m = -p / 2 + (t = d(c(0, t + 0.5 - o), h - o)); const f = p / 2; n = Math.sqrt(1 - m * m / (f * f)) }n = a(n) } else n = l === 6 ? a(n = h === o ? 0 : (t = d(c(0, t + 0.5 - o), h - o), (1 + Math.cos(Math.PI + 2 * Math.PI * t / (h - o))) / 2)) : (t >= u(o) && (n = c(0, d(t - o < 0 ? d(h, 1) - (o - t) : h - t, 1))), a(n)); return n * this.a.v }, getValue(t) { this.iterateDynamicProperties(), this._mdf = t || this._mdf, this._currentTextLength = this.elem.textProperty.currentData.l.length || 0, t && this.data.r === 2 && (this.e.v = this._currentTextLength); const e = this.data.r === 2 ? 1 : 100 / this.data.totalChars; const r = this.o.v / e; let i = this.s.v / e + r; let s = this.e.v / e + r; if (s < i) { const a = i; i = s, s = a } this.finalS = i, this.finalE = s } }, extendPrototype([DynamicPropertyContainer], i), { getTextSelectorProp(t, e, r) { return new i(t, e, r) } } }()); const pool_factory = function (t, e, r, i) { let s = 0; let a = t; let n = createSizedArray(a); function o() { return s ? n[s -= 1] : e() } return { newElement: o, release(t) { s === a && (n = pooling.double(n), a *= 2), r && r(t), n[s] = t, s += 1 } } }; var pooling = { double(t) { return t.concat(createSizedArray(t.length)) } }; var point_pool = pool_factory(8, () => createTypedArray('float32', 2)); var shape_pool = (KA = pool_factory(4, () => new ShapePath(), t => { let e; const r = t._length; for (e = 0; e < r; e += 1)point_pool.release(t.v[e]), point_pool.release(t.i[e]), point_pool.release(t.o[e]), t.v[e] = null, t.i[e] = null, t.o[e] = null; t._length = 0, t.c = !1 }), KA.clone = function (t) { let e; const r = KA.newElement(); const i = void 0 === t._length ? t.v.length : t._length; for (r.setLength(i), r.c = t.c, e = 0; e < i; e += 1)r.setTripleAt(t.v[e][0], t.v[e][1], t.o[e][0], t.o[e][1], t.i[e][0], t.i[e][1], e); return r }, KA); let KA; var shapeCollection_pool = (TA = { newShapeCollection() { let t; t = UA ? WA[UA -= 1] : new ShapeCollection(); return t }, release(t) { let e; const r = t._length; for (e = 0; e < r; e += 1)shape_pool.release(t.shapes[e]); t._length = 0, UA === VA && (WA = pooling.double(WA), VA *= 2); WA[UA] = t, UA += 1 } }, UA = 0, VA = 4, WA = createSizedArray(VA), TA); let TA; let UA; let VA; let WA; var segments_length_pool = pool_factory(8, () => ({ lengths: [], totalLength: 0 }), t => { let e; const r = t.lengths.length; for (e = 0; e < r; e += 1)bezier_length_pool.release(t.lengths[e]); t.lengths.length = 0 }); var bezier_length_pool = pool_factory(8, () => ({ addedLength: 0, percents: createTypedArray('float32', defaultCurveSegments), lengths: createTypedArray('float32', defaultCurveSegments) })); function BaseRenderer() {} function SVGRenderer(t, e) {
    this.animationItem = t, this.layers = null, this.renderedFrame = -1, this.svgElement = createNS('svg'); let r = ''; if (e && e.title) { const i = createNS('title'); const s = createElementID(); i.setAttribute('id', s), i.textContent = e.title, this.svgElement.appendChild(i), r += s } if (e && e.description) { const a = createNS('desc'); const n = createElementID(); a.setAttribute('id', n), a.textContent = e.description, this.svgElement.appendChild(a), r += ` ${n}` }r && this.svgElement.setAttribute('aria-labelledby', r); const o = createNS('defs'); this.svgElement.appendChild(o); const h = createNS('g'); this.svgElement.appendChild(h), this.layerElement = h, this.renderConfig = {
      preserveAspectRatio: e && e.preserveAspectRatio || 'xMidYMid meet',
      imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || 'xMidYMid slice',
      progressiveLoad: e && e.progressiveLoad || !1,
      hideOnTransparent: !e || !1 !== e.hideOnTransparent,
      viewBoxOnly: e && e.viewBoxOnly || !1,
      viewBoxSize: e && e.viewBoxSize || !1,
      className: e && e.className || '',
      id: e && e.id || '',
      focusable: e && e.focusable,
      filterSize: {
        width: e && e.filterSize && e.filterSize.width || '100%', height: e && e.filterSize && e.filterSize.height || '100%', x: e && e.filterSize && e.filterSize.x || '0%', y: e && e.filterSize && e.filterSize.y || '0%'
      }
    }, this.globalData = {
      _mdf: !1, frameNum: -1, defs: o, renderConfig: this.renderConfig
    }, this.elements = [], this.pendingElements = [], this.destroyed = !1, this.rendererType = 'svg'
  } function CanvasRenderer(t, e) {
    this.animationItem = t, this.renderConfig = {
      clearCanvas: !e || void 0 === e.clearCanvas || e.clearCanvas, context: e && e.context || null, progressiveLoad: e && e.progressiveLoad || !1, preserveAspectRatio: e && e.preserveAspectRatio || 'xMidYMid meet', imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || 'xMidYMid slice', className: e && e.className || '', id: e && e.id || ''
    }, this.renderConfig.dpr = e && e.dpr || 1, this.animationItem.wrapper && (this.renderConfig.dpr = e && e.dpr || window.devicePixelRatio || 1), this.renderedFrame = -1, this.globalData = {
      frameNum: -1, _mdf: !1, renderConfig: this.renderConfig, currentGlobalAlpha: -1
    }, this.contextData = new CVContextData(), this.elements = [], this.pendingElements = [], this.transformMat = new Matrix(), this.completeLayers = !1, this.rendererType = 'canvas'
  } function HybridRenderer(t, e) {
    this.animationItem = t, this.layers = null, this.renderedFrame = -1, this.renderConfig = {
      className: e && e.className || '',
      imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || 'xMidYMid slice',
      hideOnTransparent: !e || !1 !== e.hideOnTransparent,
      filterSize: {
        width: e && e.filterSize && e.filterSize.width || '400%', height: e && e.filterSize && e.filterSize.height || '400%', x: e && e.filterSize && e.filterSize.x || '-100%', y: e && e.filterSize && e.filterSize.y || '-100%'
      }
    }, this.globalData = { _mdf: !1, frameNum: -1, renderConfig: this.renderConfig }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = 'html'
  } function MaskElement(t, e, r) {
    this.data = t, this.element = e, this.globalData = r, this.storedData = [], this.masksProperties = this.data.masksProperties || [], this.maskElement = null; let i; const s = this.globalData.defs; let a = this.masksProperties ? this.masksProperties.length : 0; this.viewData = createSizedArray(a), this.solidPath = ''; let n; let o; let h; let l; let p; let m; let f; const c = this.masksProperties; let d = 0; const u = []; const y = createElementID(); let g = 'clipPath'; let v = 'clip-path'; for (i = 0; i < a; i++) {
      if ((c[i].mode !== 'a' && c[i].mode !== 'n' || c[i].inv || c[i].o.k !== 100 || c[i].o.x) && (v = g = 'mask'), c[i].mode != 's' && c[i].mode != 'i' || d !== 0 ? l = null : ((l = createNS('rect')).setAttribute('fill', '#ffffff'), l.setAttribute('width', this.element.comp.data.w || 0), l.setAttribute('height', this.element.comp.data.h || 0), u.push(l)), n = createNS('path'), c[i].mode != 'n') {
        var b; if (d += 1, n.setAttribute('fill', c[i].mode === 's' ? '#000000' : '#ffffff'), n.setAttribute('clip-rule', 'nonzero'), c[i].x.k !== 0 ? (v = g = 'mask', f = PropertyFactory.getProp(this.element, c[i].x, 0, null, this.element), b = createElementID(), (p = createNS('filter')).setAttribute('id', b), (m = createNS('feMorphology')).setAttribute('operator', 'erode'), m.setAttribute('in', 'SourceGraphic'), m.setAttribute('radius', '0'), p.appendChild(m), s.appendChild(p), n.setAttribute('stroke', c[i].mode === 's' ? '#000000' : '#ffffff')) : f = m = null, this.storedData[i] = {
          elem: n, x: f, expan: m, lastPath: '', lastOperator: '', filterId: b, lastRadius: 0
        }, c[i].mode == 'i') { h = u.length; const E = createNS('g'); for (o = 0; o < h; o += 1)E.appendChild(u[o]); const x = createNS('mask'); x.setAttribute('mask-type', 'alpha'), x.setAttribute('id', `${y}_${d}`), x.appendChild(n), s.appendChild(x), E.setAttribute('mask', `url(${locationHref}#${y}_${d})`), u.length = 0, u.push(E) } else u.push(n); c[i].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()), this.viewData[i] = {
          elem: n, lastPath: '', op: PropertyFactory.getProp(this.element, c[i].o, 0, 0.01, this.element), prop: ShapePropertyFactory.getShapeProp(this.element, c[i], 3), invRect: l
        }, this.viewData[i].prop.k || this.drawPath(c[i], this.viewData[i].prop.v, this.viewData[i])
      } else {
        this.viewData[i] = {
          op: PropertyFactory.getProp(this.element, c[i].o, 0, 0.01, this.element), prop: ShapePropertyFactory.getShapeProp(this.element, c[i], 3), elem: n, lastPath: ''
        }, s.appendChild(n)
      }
    } for (this.maskElement = createNS(g), a = u.length, i = 0; i < a; i += 1) this.maskElement.appendChild(u[i]); d > 0 && (this.maskElement.setAttribute('id', y), this.element.maskedElement.setAttribute(v, `url(${locationHref}#${y})`), s.appendChild(this.maskElement)), this.viewData.length && this.element.addRenderableComponent(this)
  } function HierarchyElement() {} function FrameElement() {} function TransformElement() {} function RenderableElement() {} function RenderableDOMElement() {} function ProcessedElement(t, e) { this.elem = t, this.pos = e } function SVGStyleData(t, e) { this.data = t, this.type = t.ty, this.d = '', this.lvl = e, this._mdf = !1, this.closed = !0 === t.hd, this.pElem = createNS('path'), this.msElem = null } function SVGShapeData(t, e, r) { this.caches = [], this.styles = [], this.transformers = t, this.lStr = '', this.sh = r, this.lvl = e, this._isAnimated = !!r.k; for (let i = 0, s = t.length; i < s;) { if (t[i].mProps.dynamicProperties.length) { this._isAnimated = !0; break }i += 1 } } function SVGTransformData(t, e, r) { this.transform = { mProps: t, op: e, container: r }, this.elements = [], this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length } function SVGStrokeStyleData(t, e, r) { this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(t, e.o, 0, 0.01, this), this.w = PropertyFactory.getProp(t, e.w, 0, null, this), this.d = new DashProperty(t, e.d || {}, 'svg', this), this.c = PropertyFactory.getProp(t, e.c, 1, 255, this), this.style = r, this._isAnimated = !!this._isAnimated } function SVGFillStyleData(t, e, r) { this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(t, e.o, 0, 0.01, this), this.c = PropertyFactory.getProp(t, e.c, 1, 255, this), this.style = r } function SVGGradientFillStyleData(t, e, r) { this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.initGradientData(t, e, r) } function SVGGradientStrokeStyleData(t, e, r) { this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.w = PropertyFactory.getProp(t, e.w, 0, null, this), this.d = new DashProperty(t, e.d || {}, 'svg', this), this.initGradientData(t, e, r), this._isAnimated = !!this._isAnimated } function ShapeGroupData() { this.it = [], this.prevViewData = [], this.gr = createNS('g') }BaseRenderer.prototype.checkLayers = function (t) { let e; let r; const i = this.layers.length; for (this.completeLayers = !0, e = i - 1; e >= 0; e--) this.elements[e] || (r = this.layers[e]).ip - r.st <= t - this.layers[e].st && r.op - r.st > t - this.layers[e].st && this.buildItem(e), this.completeLayers = !!this.elements[e] && this.completeLayers; this.checkPendingElements() }, BaseRenderer.prototype.createItem = function (t) { switch (t.ty) { case 2: return this.createImage(t); case 0: return this.createComp(t); case 1: return this.createSolid(t); case 3: return this.createNull(t); case 4: return this.createShape(t); case 5: return this.createText(t); case 13: return this.createCamera(t) } return this.createNull(t) }, BaseRenderer.prototype.createCamera = function () { throw new Error("You're using a 3d camera. Try the html renderer.") }, BaseRenderer.prototype.buildAllItems = function () { let t; const e = this.layers.length; for (t = 0; t < e; t += 1) this.buildItem(t); this.checkPendingElements() }, BaseRenderer.prototype.includeLayers = function (t) { this.completeLayers = !1; let e; let r; const i = t.length; const s = this.layers.length; for (e = 0; e < i; e += 1) for (r = 0; r < s;) { if (this.layers[r].id == t[e].id) { this.layers[r] = t[e]; break }r += 1 } }, BaseRenderer.prototype.setProjectInterface = function (t) { this.globalData.projectInterface = t }, BaseRenderer.prototype.initItems = function () { this.globalData.progressiveLoad || this.buildAllItems() }, BaseRenderer.prototype.buildElementParenting = function (t, e, r) { for (let i = this.elements, s = this.layers, a = 0, n = s.length; a < n;)s[a].ind == e && (i[a] && !0 !== i[a] ? (r.push(i[a]), i[a].setAsParent(), void 0 !== s[a].parent ? this.buildElementParenting(t, s[a].parent, r) : t.setHierarchy(r)) : (this.buildItem(a), this.addPendingElement(t))), a += 1 }, BaseRenderer.prototype.addPendingElement = function (t) { this.pendingElements.push(t) }, BaseRenderer.prototype.searchExtraCompositions = function (t) { let e; const r = t.length; for (e = 0; e < r; e += 1) if (t[e].xt) { const i = this.createComp(t[e]); i.initExpressions(), this.globalData.projectInterface.registerComposition(i) } }, BaseRenderer.prototype.setupGlobalData = function (t, e) { this.globalData.fontManager = new FontManager(), this.globalData.fontManager.addChars(t.chars), this.globalData.fontManager.addFonts(t.fonts, e), this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem), this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem), this.globalData.imageLoader = this.animationItem.imagePreloader, this.globalData.frameId = 0, this.globalData.frameRate = t.fr, this.globalData.nm = t.nm, this.globalData.compSize = { w: t.w, h: t.h } }, extendPrototype([BaseRenderer], SVGRenderer), SVGRenderer.prototype.createNull = function (t) { return new NullElement(t, this.globalData, this) }, SVGRenderer.prototype.createShape = function (t) { return new SVGShapeElement(t, this.globalData, this) }, SVGRenderer.prototype.createText = function (t) { return new SVGTextElement(t, this.globalData, this) }, SVGRenderer.prototype.createImage = function (t) { return new IImageElement(t, this.globalData, this) }, SVGRenderer.prototype.createComp = function (t) { return new SVGCompElement(t, this.globalData, this) }, SVGRenderer.prototype.createSolid = function (t) { return new ISolidElement(t, this.globalData, this) }, SVGRenderer.prototype.configAnimation = function (t) { this.svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg'), this.renderConfig.viewBoxSize ? this.svgElement.setAttribute('viewBox', this.renderConfig.viewBoxSize) : this.svgElement.setAttribute('viewBox', `0 0 ${t.w} ${t.h}`), this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute('width', t.w), this.svgElement.setAttribute('height', t.h), this.svgElement.style.width = '100%', this.svgElement.style.height = '100%', this.svgElement.style.transform = 'translate3d(0,0,0)'), this.renderConfig.className && this.svgElement.setAttribute('class', this.renderConfig.className), this.renderConfig.id && this.svgElement.setAttribute('id', this.renderConfig.id), void 0 !== this.renderConfig.focusable && this.svgElement.setAttribute('focusable', this.renderConfig.focusable), this.svgElement.setAttribute('preserveAspectRatio', this.renderConfig.preserveAspectRatio), this.animationItem.wrapper.appendChild(this.svgElement); const e = this.globalData.defs; this.setupGlobalData(t, e), this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.data = t; const r = createNS('clipPath'); const i = createNS('rect'); i.setAttribute('width', t.w), i.setAttribute('height', t.h), i.setAttribute('x', 0), i.setAttribute('y', 0); const s = createElementID(); r.setAttribute('id', s), r.appendChild(i), this.layerElement.setAttribute('clip-path', `url(${locationHref}#${s})`), e.appendChild(r), this.layers = t.layers, this.elements = createSizedArray(t.layers.length) }, SVGRenderer.prototype.destroy = function () { this.animationItem.wrapper.innerHTML = '', this.layerElement = null, this.globalData.defs = null; let t; const e = this.layers ? this.layers.length : 0; for (t = 0; t < e; t++) this.elements[t] && this.elements[t].destroy(); this.elements.length = 0, this.destroyed = !0, this.animationItem = null }, SVGRenderer.prototype.updateContainerSize = function () {}, SVGRenderer.prototype.buildItem = function (t) { const e = this.elements; if (!e[t] && this.layers[t].ty != 99) { e[t] = !0; const r = this.createItem(this.layers[t]); e[t] = r, expressionsPlugin && (this.layers[t].ty === 0 && this.globalData.projectInterface.registerComposition(r), r.initExpressions()), this.appendElementInPos(r, t), this.layers[t].tt && (this.elements[t - 1] && !0 !== this.elements[t - 1] ? r.setMatte(e[t - 1].layerId) : (this.buildItem(t - 1), this.addPendingElement(r))) } }, SVGRenderer.prototype.checkPendingElements = function () { for (;this.pendingElements.length;) { const t = this.pendingElements.pop(); if (t.checkParenting(), t.data.tt) for (let e = 0, r = this.elements.length; e < r;) { if (this.elements[e] === t) { t.setMatte(this.elements[e - 1].layerId); break }e += 1 } } }, SVGRenderer.prototype.renderFrame = function (t) { if (this.renderedFrame !== t && !this.destroyed) { t === null ? t = this.renderedFrame : this.renderedFrame = t, this.globalData.frameNum = t, this.globalData.frameId += 1, this.globalData.projectInterface.currentFrame = t, this.globalData._mdf = !1; let e; const r = this.layers.length; for (this.completeLayers || this.checkLayers(t), e = r - 1; e >= 0; e--)(this.completeLayers || this.elements[e]) && this.elements[e].prepareFrame(t - this.layers[e].st); if (this.globalData._mdf) for (e = 0; e < r; e += 1)(this.completeLayers || this.elements[e]) && this.elements[e].renderFrame() } }, SVGRenderer.prototype.appendElementInPos = function (t, e) { const r = t.getBaseElement(); if (r) { for (var i, s = 0; s < e;) this.elements[s] && !0 !== this.elements[s] && this.elements[s].getBaseElement() && (i = this.elements[s].getBaseElement()), s += 1; i ? this.layerElement.insertBefore(r, i) : this.layerElement.appendChild(r) } }, SVGRenderer.prototype.hide = function () { this.layerElement.style.display = 'none' }, SVGRenderer.prototype.show = function () { this.layerElement.style.display = 'block' }, extendPrototype([BaseRenderer], CanvasRenderer), CanvasRenderer.prototype.createShape = function (t) { return new CVShapeElement(t, this.globalData, this) }, CanvasRenderer.prototype.createText = function (t) { return new CVTextElement(t, this.globalData, this) }, CanvasRenderer.prototype.createImage = function (t) { return new CVImageElement(t, this.globalData, this) }, CanvasRenderer.prototype.createComp = function (t) { return new CVCompElement(t, this.globalData, this) }, CanvasRenderer.prototype.createSolid = function (t) { return new CVSolidElement(t, this.globalData, this) }, CanvasRenderer.prototype.createNull = SVGRenderer.prototype.createNull, CanvasRenderer.prototype.ctxTransform = function (t) { if (t[0] !== 1 || t[1] !== 0 || t[4] !== 0 || t[5] !== 1 || t[12] !== 0 || t[13] !== 0) if (this.renderConfig.clearCanvas) { this.transformMat.cloneFromProps(t); const e = this.contextData.cTr.props; this.transformMat.transform(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]), this.contextData.cTr.cloneFromProps(this.transformMat.props); const r = this.contextData.cTr.props; this.canvasContext.setTransform(r[0], r[1], r[4], r[5], r[12], r[13]) } else this.canvasContext.transform(t[0], t[1], t[4], t[5], t[12], t[13]) }, CanvasRenderer.prototype.ctxOpacity = function (t) { if (!this.renderConfig.clearCanvas) return this.canvasContext.globalAlpha *= t < 0 ? 0 : t, void (this.globalData.currentGlobalAlpha = this.contextData.cO); this.contextData.cO *= t < 0 ? 0 : t, this.globalData.currentGlobalAlpha !== this.contextData.cO && (this.canvasContext.globalAlpha = this.contextData.cO, this.globalData.currentGlobalAlpha = this.contextData.cO) }, CanvasRenderer.prototype.reset = function () { this.renderConfig.clearCanvas ? this.contextData.reset() : this.canvasContext.restore() }, CanvasRenderer.prototype.save = function (t) { if (this.renderConfig.clearCanvas) { t && this.canvasContext.save(); const e = this.contextData.cTr.props; this.contextData._length <= this.contextData.cArrPos && this.contextData.duplicate(); let r; const i = this.contextData.saved[this.contextData.cArrPos]; for (r = 0; r < 16; r += 1)i[r] = e[r]; this.contextData.savedOp[this.contextData.cArrPos] = this.contextData.cO, this.contextData.cArrPos += 1 } else this.canvasContext.save() }, CanvasRenderer.prototype.restore = function (t) { if (this.renderConfig.clearCanvas) { t && (this.canvasContext.restore(), this.globalData.blendMode = 'source-over'), this.contextData.cArrPos -= 1; let e; let r = this.contextData.saved[this.contextData.cArrPos]; const i = this.contextData.cTr.props; for (e = 0; e < 16; e += 1)i[e] = r[e]; this.canvasContext.setTransform(r[0], r[1], r[4], r[5], r[12], r[13]), r = this.contextData.savedOp[this.contextData.cArrPos], this.contextData.cO = r, this.globalData.currentGlobalAlpha !== r && (this.canvasContext.globalAlpha = r, this.globalData.currentGlobalAlpha = r) } else this.canvasContext.restore() }, CanvasRenderer.prototype.configAnimation = function (t) {
    this.animationItem.wrapper ? (this.animationItem.container = createTag('canvas'), this.animationItem.container.style.width = '100%', this.animationItem.container.style.height = '100%', this.animationItem.container.style.transformOrigin = this.animationItem.container.style.mozTransformOrigin = this.animationItem.container.style.webkitTransformOrigin = this.animationItem.container.style['-webkit-transform'] = '0px 0px 0px', this.animationItem.wrapper.appendChild(this.animationItem.container), this.canvasContext = this.animationItem.container.getContext('2d'), this.renderConfig.className && this.animationItem.container.setAttribute('class', this.renderConfig.className), this.renderConfig.id && this.animationItem.container.setAttribute('id', this.renderConfig.id)) : this.canvasContext = this.renderConfig.context, this.data = t, this.layers = t.layers, this.transformCanvas = {
      w: t.w, h: t.h, sx: 0, sy: 0, tx: 0, ty: 0
    }, this.setupGlobalData(t, document.body), this.globalData.canvasContext = this.canvasContext, (this.globalData.renderer = this).globalData.isDashed = !1, this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.globalData.transformCanvas = this.transformCanvas, this.elements = createSizedArray(t.layers.length), this.updateContainerSize()
  }, CanvasRenderer.prototype.updateContainerSize = function () { let t; let e; let r; let i; if (this.reset(), this.animationItem.wrapper && this.animationItem.container ? (t = this.animationItem.wrapper.offsetWidth, e = this.animationItem.wrapper.offsetHeight, this.animationItem.container.setAttribute('width', t * this.renderConfig.dpr), this.animationItem.container.setAttribute('height', e * this.renderConfig.dpr)) : (t = this.canvasContext.canvas.width * this.renderConfig.dpr, e = this.canvasContext.canvas.height * this.renderConfig.dpr), this.renderConfig.preserveAspectRatio.indexOf('meet') !== -1 || this.renderConfig.preserveAspectRatio.indexOf('slice') !== -1) { const s = this.renderConfig.preserveAspectRatio.split(' '); const a = s[1] || 'meet'; const n = s[0] || 'xMidYMid'; const o = n.substr(0, 4); const h = n.substr(4); r = t / e, i = this.transformCanvas.w / this.transformCanvas.h, this.transformCanvas.sy = r < i && a === 'meet' || i < r && a === 'slice' ? (this.transformCanvas.sx = t / (this.transformCanvas.w / this.renderConfig.dpr), t / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = e / (this.transformCanvas.h / this.renderConfig.dpr), e / (this.transformCanvas.h / this.renderConfig.dpr)), this.transformCanvas.tx = o === 'xMid' && (i < r && a === 'meet' || r < i && a === 'slice') ? (t - this.transformCanvas.w * (e / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : o === 'xMax' && (i < r && a === 'meet' || r < i && a === 'slice') ? (t - this.transformCanvas.w * (e / this.transformCanvas.h)) * this.renderConfig.dpr : 0, this.transformCanvas.ty = h === 'YMid' && (r < i && a === 'meet' || i < r && a === 'slice') ? (e - this.transformCanvas.h * (t / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : h === 'YMax' && (r < i && a === 'meet' || i < r && a === 'slice') ? (e - this.transformCanvas.h * (t / this.transformCanvas.w)) * this.renderConfig.dpr : 0 } else this.renderConfig.preserveAspectRatio == 'none' ? (this.transformCanvas.sx = t / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = e / (this.transformCanvas.h / this.renderConfig.dpr)) : (this.transformCanvas.sx = this.renderConfig.dpr, this.transformCanvas.sy = this.renderConfig.dpr), this.transformCanvas.tx = 0, this.transformCanvas.ty = 0; this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1], this.ctxTransform(this.transformCanvas.props), this.canvasContext.beginPath(), this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h), this.canvasContext.closePath(), this.canvasContext.clip(), this.renderFrame(this.renderedFrame, !0) }, CanvasRenderer.prototype.destroy = function () { let t; for (this.renderConfig.clearCanvas && (this.animationItem.wrapper.innerHTML = ''), t = (this.layers ? this.layers.length : 0) - 1; t >= 0; t -= 1) this.elements[t] && this.elements[t].destroy(); this.elements.length = 0, this.globalData.canvasContext = null, this.animationItem.container = null, this.destroyed = !0 }, CanvasRenderer.prototype.renderFrame = function (t, e) { if ((this.renderedFrame !== t || !0 !== this.renderConfig.clearCanvas || e) && !this.destroyed && t !== -1) { this.renderedFrame = t, this.globalData.frameNum = t - this.animationItem._isFirstFrame, this.globalData.frameId += 1, this.globalData._mdf = !this.renderConfig.clearCanvas || e, this.globalData.projectInterface.currentFrame = t; let r; const i = this.layers.length; for (this.completeLayers || this.checkLayers(t), r = 0; r < i; r++)(this.completeLayers || this.elements[r]) && this.elements[r].prepareFrame(t - this.layers[r].st); if (this.globalData._mdf) { for (!0 === this.renderConfig.clearCanvas ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(), r = i - 1; r >= 0; r -= 1)(this.completeLayers || this.elements[r]) && this.elements[r].renderFrame(); !0 !== this.renderConfig.clearCanvas && this.restore() } } }, CanvasRenderer.prototype.buildItem = function (t) { const e = this.elements; if (!e[t] && this.layers[t].ty != 99) { const r = this.createItem(this.layers[t], this, this.globalData); (e[t] = r).initExpressions() } }, CanvasRenderer.prototype.checkPendingElements = function () { for (;this.pendingElements.length;) { this.pendingElements.pop().checkParenting() } }, CanvasRenderer.prototype.hide = function () { this.animationItem.container.style.display = 'none' }, CanvasRenderer.prototype.show = function () { this.animationItem.container.style.display = 'block' }, extendPrototype([BaseRenderer], HybridRenderer), HybridRenderer.prototype.buildItem = SVGRenderer.prototype.buildItem, HybridRenderer.prototype.checkPendingElements = function () { for (;this.pendingElements.length;) { this.pendingElements.pop().checkParenting() } }, HybridRenderer.prototype.appendElementInPos = function (t, e) { const r = t.getBaseElement(); if (r) { const i = this.layers[e]; if (i.ddd && this.supports3d) this.addTo3dContainer(r, e); else if (this.threeDElements) this.addTo3dContainer(r, e); else { for (var s, a, n = 0; n < e;) this.elements[n] && !0 !== this.elements[n] && this.elements[n].getBaseElement && (a = this.elements[n], s = (this.layers[n].ddd ? this.getThreeDContainerByPos(n) : a.getBaseElement()) || s), n += 1; s ? i.ddd && this.supports3d || this.layerElement.insertBefore(r, s) : i.ddd && this.supports3d || this.layerElement.appendChild(r) } } }, HybridRenderer.prototype.createShape = function (t) { return this.supports3d ? new HShapeElement(t, this.globalData, this) : new SVGShapeElement(t, this.globalData, this) }, HybridRenderer.prototype.createText = function (t) { return this.supports3d ? new HTextElement(t, this.globalData, this) : new SVGTextElement(t, this.globalData, this) }, HybridRenderer.prototype.createCamera = function (t) { return this.camera = new HCameraElement(t, this.globalData, this), this.camera }, HybridRenderer.prototype.createImage = function (t) { return this.supports3d ? new HImageElement(t, this.globalData, this) : new IImageElement(t, this.globalData, this) }, HybridRenderer.prototype.createComp = function (t) { return this.supports3d ? new HCompElement(t, this.globalData, this) : new SVGCompElement(t, this.globalData, this) }, HybridRenderer.prototype.createSolid = function (t) { return this.supports3d ? new HSolidElement(t, this.globalData, this) : new ISolidElement(t, this.globalData, this) }, HybridRenderer.prototype.createNull = SVGRenderer.prototype.createNull, HybridRenderer.prototype.getThreeDContainerByPos = function (t) { for (let e = 0, r = this.threeDElements.length; e < r;) { if (this.threeDElements[e].startPos <= t && this.threeDElements[e].endPos >= t) return this.threeDElements[e].perspectiveElem; e += 1 } }, HybridRenderer.prototype.createThreeDContainer = function (t, e) {
    const r = createTag('div'); styleDiv(r); const i = createTag('div'); styleDiv(i), e === '3d' && (r.style.width = `${this.globalData.compSize.w}px`, r.style.height = `${this.globalData.compSize.h}px`, r.style.transformOrigin = r.style.mozTransformOrigin = r.style.webkitTransformOrigin = '50% 50%', i.style.transform = i.style.webkitTransform = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)'), r.appendChild(i); const s = {
      container: i, perspectiveElem: r, startPos: t, endPos: t, type: e
    }; return this.threeDElements.push(s), s
  }, HybridRenderer.prototype.build3dContainers = function () { let t; let e; let r = this.layers.length; let i = ''; for (t = 0; t < r; t += 1) this.layers[t].ddd && this.layers[t].ty !== 3 ? i !== '3d' && (i = '3d', e = this.createThreeDContainer(t, '3d')) : i !== '2d' && (i = '2d', e = this.createThreeDContainer(t, '2d')), e.endPos = Math.max(e.endPos, t); for (t = (r = this.threeDElements.length) - 1; t >= 0; t--) this.resizerElem.appendChild(this.threeDElements[t].perspectiveElem) }, HybridRenderer.prototype.addTo3dContainer = function (t, e) { for (let r = 0, i = this.threeDElements.length; r < i;) { if (e <= this.threeDElements[r].endPos) { for (var s, a = this.threeDElements[r].startPos; a < e;) this.elements[a] && this.elements[a].getBaseElement && (s = this.elements[a].getBaseElement()), a += 1; s ? this.threeDElements[r].container.insertBefore(t, s) : this.threeDElements[r].container.appendChild(t); break }r += 1 } }, HybridRenderer.prototype.configAnimation = function (t) { const e = createTag('div'); const r = this.animationItem.wrapper; e.style.width = `${t.w}px`, e.style.height = `${t.h}px`, styleDiv(this.resizerElem = e), e.style.transformStyle = e.style.webkitTransformStyle = e.style.mozTransformStyle = 'flat', this.renderConfig.className && e.setAttribute('class', this.renderConfig.className), r.appendChild(e), e.style.overflow = 'hidden'; const i = createNS('svg'); i.setAttribute('width', '1'), i.setAttribute('height', '1'), styleDiv(i), this.resizerElem.appendChild(i); const s = createNS('defs'); i.appendChild(s), this.data = t, this.setupGlobalData(t, i), this.globalData.defs = s, this.layers = t.layers, this.layerElement = this.resizerElem, this.build3dContainers(), this.updateContainerSize() }, HybridRenderer.prototype.destroy = function () { this.animationItem.wrapper.innerHTML = '', this.animationItem.container = null, this.globalData.defs = null; let t; const e = this.layers ? this.layers.length : 0; for (t = 0; t < e; t++) this.elements[t].destroy(); this.elements.length = 0, this.destroyed = !0, this.animationItem = null }, HybridRenderer.prototype.updateContainerSize = function () { let t; let e; let r; let i; const s = this.animationItem.wrapper.offsetWidth; const a = this.animationItem.wrapper.offsetHeight; i = s / a < this.globalData.compSize.w / this.globalData.compSize.h ? (t = s / this.globalData.compSize.w, e = s / this.globalData.compSize.w, r = 0, (a - this.globalData.compSize.h * (s / this.globalData.compSize.w)) / 2) : (t = a / this.globalData.compSize.h, e = a / this.globalData.compSize.h, r = (s - this.globalData.compSize.w * (a / this.globalData.compSize.h)) / 2, 0), this.resizerElem.style.transform = this.resizerElem.style.webkitTransform = `matrix3d(${t},0,0,0,0,${e},0,0,0,0,1,0,${r},${i},0,1)` }, HybridRenderer.prototype.renderFrame = SVGRenderer.prototype.renderFrame, HybridRenderer.prototype.hide = function () { this.resizerElem.style.display = 'none' }, HybridRenderer.prototype.show = function () { this.resizerElem.style.display = 'block' }, HybridRenderer.prototype.initItems = function () { if (this.buildAllItems(), this.camera) this.camera.setup(); else { let t; const e = this.globalData.compSize.w; const r = this.globalData.compSize.h; const i = this.threeDElements.length; for (t = 0; t < i; t += 1) this.threeDElements[t].perspectiveElem.style.perspective = this.threeDElements[t].perspectiveElem.style.webkitPerspective = `${Math.sqrt(Math.pow(e, 2) + Math.pow(r, 2))}px` } }, HybridRenderer.prototype.searchExtraCompositions = function (t) { let e; const r = t.length; const i = createTag('div'); for (e = 0; e < r; e += 1) if (t[e].xt) { const s = this.createComp(t[e], i, this.globalData.comp, null); s.initExpressions(), this.globalData.projectInterface.registerComposition(s) } }, MaskElement.prototype.getMaskProperty = function (t) { return this.viewData[t].prop }, MaskElement.prototype.renderFrame = function (t) { let e; const r = this.element.finalTransform.mat; const i = this.masksProperties.length; for (e = 0; e < i; e++) if ((this.viewData[e].prop._mdf || t) && this.drawPath(this.masksProperties[e], this.viewData[e].prop.v, this.viewData[e]), (this.viewData[e].op._mdf || t) && this.viewData[e].elem.setAttribute('fill-opacity', this.viewData[e].op.v), this.masksProperties[e].mode !== 'n' && (this.viewData[e].invRect && (this.element.finalTransform.mProp._mdf || t) && this.viewData[e].invRect.setAttribute('transform', r.getInverseMatrix().to2dCSS()), this.storedData[e].x && (this.storedData[e].x._mdf || t))) { const s = this.storedData[e].expan; this.storedData[e].x.v < 0 ? (this.storedData[e].lastOperator !== 'erode' && (this.storedData[e].lastOperator = 'erode', this.storedData[e].elem.setAttribute('filter', `url(${locationHref}#${this.storedData[e].filterId})`)), s.setAttribute('radius', -this.storedData[e].x.v)) : (this.storedData[e].lastOperator !== 'dilate' && (this.storedData[e].lastOperator = 'dilate', this.storedData[e].elem.setAttribute('filter', null)), this.storedData[e].elem.setAttribute('stroke-width', 2 * this.storedData[e].x.v)) } }, MaskElement.prototype.getMaskelement = function () { return this.maskElement }, MaskElement.prototype.createLayerSolidPath = function () { let t = 'M0,0 '; return t += ` h${this.globalData.compSize.w}`, t += ` v${this.globalData.compSize.h}`, t += ` h-${this.globalData.compSize.w}`, t += ` v-${this.globalData.compSize.h} ` }, MaskElement.prototype.drawPath = function (t, e, r) { let i; let s; let a = ` M${e.v[0][0]},${e.v[0][1]}`; for (s = e._length, i = 1; i < s; i += 1)a += ` C${e.o[i - 1][0]},${e.o[i - 1][1]} ${e.i[i][0]},${e.i[i][1]} ${e.v[i][0]},${e.v[i][1]}`; if (e.c && s > 1 && (a += ` C${e.o[i - 1][0]},${e.o[i - 1][1]} ${e.i[0][0]},${e.i[0][1]} ${e.v[0][0]},${e.v[0][1]}`), r.lastPath !== a) { let n = ''; r.elem && (e.c && (n = t.inv ? this.solidPath + a : a), r.elem.setAttribute('d', n)), r.lastPath = a } }, MaskElement.prototype.destroy = function () { this.element = null, this.globalData = null, this.maskElement = null, this.data = null, this.masksProperties = null }, HierarchyElement.prototype = {
    initHierarchy() { this.hierarchy = [], this._isParent = !1, this.checkParenting() }, setHierarchy(t) { this.hierarchy = t }, setAsParent() { this._isParent = !0 }, checkParenting() { void 0 !== this.data.parent && this.comp.buildElementParenting(this, this.data.parent, []) }
  }, FrameElement.prototype = { initFrame() { this._isFirstFrame = !1, this.dynamicProperties = [], this._mdf = !1 }, prepareProperties(t, e) { let r; const i = this.dynamicProperties.length; for (r = 0; r < i; r += 1)(e || this._isParent && this.dynamicProperties[r].propType === 'transform') && (this.dynamicProperties[r].getValue(), this.dynamicProperties[r]._mdf && (this.globalData._mdf = !0, this._mdf = !0)) }, addDynamicProperty(t) { this.dynamicProperties.indexOf(t) === -1 && this.dynamicProperties.push(t) } }, TransformElement.prototype = {
    initTransform() {
      this.finalTransform = {
        mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : { o: 0 }, _matMdf: !1, _opMdf: !1, mat: new Matrix()
      }, this.data.ao && (this.finalTransform.mProp.autoOriented = !0), this.data.ty
    },
    renderTransform() { if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame, this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame, this.hierarchy) { let t; const e = this.finalTransform.mat; let r = 0; const i = this.hierarchy.length; if (!this.finalTransform._matMdf) for (;r < i;) { if (this.hierarchy[r].finalTransform.mProp._mdf) { this.finalTransform._matMdf = !0; break }r += 1 } if (this.finalTransform._matMdf) for (t = this.finalTransform.mProp.v.props, e.cloneFromProps(t), r = 0; r < i; r += 1)t = this.hierarchy[r].finalTransform.mProp.v.props, e.transform(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]) } },
    globalToLocal(t) { const e = []; e.push(this.finalTransform); for (let r = !0, i = this.comp; r;)i.finalTransform ? (i.data.hasMask && e.splice(0, 0, i.finalTransform), i = i.comp) : r = !1; let s; let a; const n = e.length; for (s = 0; s < n; s += 1)a = e[s].mat.applyToPointArray(0, 0, 0), t = [t[0] - a[0], t[1] - a[1], 0]; return t },
    mHelper: new Matrix()
  }, RenderableElement.prototype = {
    initRenderable() { this.isInRange = !1, this.hidden = !1, this.isTransparent = !1, this.renderableComponents = [] },
    addRenderableComponent(t) { this.renderableComponents.indexOf(t) === -1 && this.renderableComponents.push(t) },
    removeRenderableComponent(t) { this.renderableComponents.indexOf(t) !== -1 && this.renderableComponents.splice(this.renderableComponents.indexOf(t), 1) },
    prepareRenderableFrame(t) { this.checkLayerLimits(t) },
    checkTransparency() { this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0, this.hide()) : this.isTransparent && (this.isTransparent = !1, this.show()) },
    checkLayerLimits(t) { this.data.ip - this.data.st <= t && this.data.op - this.data.st > t ? !0 !== this.isInRange && (this.globalData._mdf = !0, this._mdf = !0, this.isInRange = !0, this.show()) : !1 !== this.isInRange && (this.globalData._mdf = !0, this.isInRange = !1, this.hide()) },
    renderRenderable() { let t; const e = this.renderableComponents.length; for (t = 0; t < e; t += 1) this.renderableComponents[t].renderFrame(this._isFirstFrame) },
    sourceRectAtTime() {
      return {
        top: 0, left: 0, width: 100, height: 100
      }
    },
    getLayerSize() { return this.data.ty === 5 ? { w: this.data.textData.width, h: this.data.textData.height } : { w: this.data.width, h: this.data.height } }
  }, extendPrototype([RenderableElement, createProxyFunction({
    initElement(t, e, r) { this.initFrame(), this.initBaseData(t, e, r), this.initTransform(t, e, r), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide() }, hide() { this.hidden || this.isInRange && !this.isTransparent || ((this.baseElement || this.layerElement).style.display = 'none', this.hidden = !0) }, show() { this.isInRange && !this.isTransparent && (this.data.hd || ((this.baseElement || this.layerElement).style.display = 'block'), this.hidden = !1, this._isFirstFrame = !0) }, renderFrame() { this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1)) }, renderInnerContent() {}, prepareFrame(t) { this._mdf = !1, this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange), this.checkTransparency() }, destroy() { this.innerElem = null, this.destroyBaseElement() }
  })], RenderableDOMElement), SVGStyleData.prototype.reset = function () { this.d = '', this._mdf = !1 }, SVGShapeData.prototype.setAsAnimated = function () { this._isAnimated = !0 }, extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData), extendPrototype([DynamicPropertyContainer], SVGFillStyleData), SVGGradientFillStyleData.prototype.initGradientData = function (t, e, r) { this.o = PropertyFactory.getProp(t, e.o, 0, 0.01, this), this.s = PropertyFactory.getProp(t, e.s, 1, null, this), this.e = PropertyFactory.getProp(t, e.e, 1, null, this), this.h = PropertyFactory.getProp(t, e.h || { k: 0 }, 0, 0.01, this), this.a = PropertyFactory.getProp(t, e.a || { k: 0 }, 0, degToRads, this), this.g = new GradientProperty(t, e.g, this), this.style = r, this.stops = [], this.setGradientData(r.pElem, e), this.setGradientOpacity(e, r), this._isAnimated = !!this._isAnimated }, SVGGradientFillStyleData.prototype.setGradientData = function (t, e) { const r = createElementID(); const i = createNS(e.t === 1 ? 'linearGradient' : 'radialGradient'); i.setAttribute('id', r), i.setAttribute('spreadMethod', 'pad'), i.setAttribute('gradientUnits', 'userSpaceOnUse'); let s; let a; let n; const o = []; for (n = 4 * e.g.p, a = 0; a < n; a += 4)s = createNS('stop'), i.appendChild(s), o.push(s); t.setAttribute(e.ty === 'gf' ? 'fill' : 'stroke', `url(${locationHref}#${r})`), this.gf = i, this.cst = o }, SVGGradientFillStyleData.prototype.setGradientOpacity = function (t, e) { if (this.g._hasOpacity && !this.g._collapsable) { let r; let i; let s; const a = createNS('mask'); const n = createNS('path'); a.appendChild(n); const o = createElementID(); const h = createElementID(); a.setAttribute('id', h); const l = createNS(t.t === 1 ? 'linearGradient' : 'radialGradient'); l.setAttribute('id', o), l.setAttribute('spreadMethod', 'pad'), l.setAttribute('gradientUnits', 'userSpaceOnUse'), s = t.g.k.k[0].s ? t.g.k.k[0].s.length : t.g.k.k.length; const p = this.stops; for (i = 4 * t.g.p; i < s; i += 2)(r = createNS('stop')).setAttribute('stop-color', 'rgb(255,255,255)'), l.appendChild(r), p.push(r); n.setAttribute(t.ty === 'gf' ? 'fill' : 'stroke', `url(${locationHref}#${o})`), this.of = l, this.ms = a, this.ost = p, this.maskId = h, e.msElem = n } }, extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData), extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData); const SVGElementsRenderer = (function () {
    const y = new Matrix(); const
      g = new Matrix(); function e(t, e, r) { (r || e.transform.op._mdf) && e.transform.container.setAttribute('opacity', e.transform.op.v), (r || e.transform.mProps._mdf) && e.transform.container.setAttribute('transform', e.transform.mProps.v.to2dCSS()) } function r(t, e, r) { let i; let s; let a; let n; let o; let h; let l; let p; let m; let f; let c; const d = e.styles.length; const u = e.lvl; for (h = 0; h < d; h += 1) { if (n = e.sh._mdf || r, e.styles[h].lvl < u) { for (p = g.reset(), f = u - e.styles[h].lvl, c = e.transformers.length - 1; !n && f > 0;)n = e.transformers[c].mProps._mdf || n, f--, c--; if (n) for (f = u - e.styles[h].lvl, c = e.transformers.length - 1; f > 0;)m = e.transformers[c].mProps.v.props, p.transform(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]), f--, c-- } else p = y; if (s = (l = e.sh.paths)._length, n) { for (a = '', i = 0; i < s; i += 1)(o = l.shapes[i]) && o._length && (a += buildShapeString(o, o._length, o.c, p)); e.caches[h] = a } else a = e.caches[h]; e.styles[h].d += !0 === t.hd ? '' : a, e.styles[h]._mdf = n || e.styles[h]._mdf } } function i(t, e, r) { const i = e.style; (e.c._mdf || r) && i.pElem.setAttribute('fill', `rgb(${bm_floor(e.c.v[0])},${bm_floor(e.c.v[1])},${bm_floor(e.c.v[2])})`), (e.o._mdf || r) && i.pElem.setAttribute('fill-opacity', e.o.v) } function s(t, e, r) { a(t, e, r), n(t, e, r) } function a(t, e, r) {
      let i; let s; let a; let n; let o; const h = e.gf; const l = e.g._hasOpacity; const p = e.s.v; const m = e.e.v; if (e.o._mdf || r) { const f = t.ty === 'gf' ? 'fill-opacity' : 'stroke-opacity'; e.style.pElem.setAttribute(f, e.o.v) } if (e.s._mdf || r) {
        const c = t.t === 1 ? 'x1' : 'cx'; const
          d = c === 'x1' ? 'y1' : 'cy'; h.setAttribute(c, p[0]), h.setAttribute(d, p[1]), l && !e.g._collapsable && (e.of.setAttribute(c, p[0]), e.of.setAttribute(d, p[1]))
      } if (e.g._cmdf || r) { i = e.cst; const u = e.g.c; for (a = i.length, s = 0; s < a; s += 1)(n = i[s]).setAttribute('offset', `${u[4 * s]}%`), n.setAttribute('stop-color', `rgb(${u[4 * s + 1]},${u[4 * s + 2]},${u[4 * s + 3]})`) } if (l && (e.g._omdf || r)) { const y = e.g.o; for (a = (i = e.g._collapsable ? e.cst : e.ost).length, s = 0; s < a; s += 1)n = i[s], e.g._collapsable || n.setAttribute('offset', `${y[2 * s]}%`), n.setAttribute('stop-opacity', y[2 * s + 1]) } if (t.t === 1)(e.e._mdf || r) && (h.setAttribute('x2', m[0]), h.setAttribute('y2', m[1]), l && !e.g._collapsable && (e.of.setAttribute('x2', m[0]), e.of.setAttribute('y2', m[1]))); else if ((e.s._mdf || e.e._mdf || r) && (o = Math.sqrt(Math.pow(p[0] - m[0], 2) + Math.pow(p[1] - m[1], 2)), h.setAttribute('r', o), l && !e.g._collapsable && e.of.setAttribute('r', o)), e.e._mdf || e.h._mdf || e.a._mdf || r) { o || (o = Math.sqrt(Math.pow(p[0] - m[0], 2) + Math.pow(p[1] - m[1], 2))); const g = Math.atan2(m[1] - p[1], m[0] - p[0]); const v = o * (e.h.v >= 1 ? 0.99 : e.h.v <= -1 ? -0.99 : e.h.v); const b = Math.cos(g + e.a.v) * v + p[0]; const E = Math.sin(g + e.a.v) * v + p[1]; h.setAttribute('fx', b), h.setAttribute('fy', E), l && !e.g._collapsable && (e.of.setAttribute('fx', b), e.of.setAttribute('fy', E)) }
    } function n(t, e, r) { const i = e.style; const s = e.d; s && (s._mdf || r) && s.dashStr && (i.pElem.setAttribute('stroke-dasharray', s.dashStr), i.pElem.setAttribute('stroke-dashoffset', s.dashoffset[0])), e.c && (e.c._mdf || r) && i.pElem.setAttribute('stroke', `rgb(${bm_floor(e.c.v[0])},${bm_floor(e.c.v[1])},${bm_floor(e.c.v[2])})`), (e.o._mdf || r) && i.pElem.setAttribute('stroke-opacity', e.o.v), (e.w._mdf || r) && (i.pElem.setAttribute('stroke-width', e.w.v), i.msElem && i.msElem.setAttribute('stroke-width', e.w.v)) } return { createRenderFunction(t) { t.ty; switch (t.ty) { case 'fl': return i; case 'gf': return a; case 'gs': return s; case 'st': return n; case 'sh': case 'el': case 'rc': case 'sr': return r; case 'tr': return e } } }
  }()); function ShapeTransformManager() { this.sequences = {}, this.sequenceList = [], this.transform_key_count = 0 } function CVShapeData(t, e, r, i) { this.styledShapes = [], this.tr = [0, 0, 0, 0, 0, 0]; let s = 4; e.ty == 'rc' ? s = 5 : e.ty == 'el' ? s = 6 : e.ty == 'sr' && (s = 7), this.sh = ShapePropertyFactory.getShapeProp(t, e, s, t); let a; let n; const o = r.length; for (a = 0; a < o; a += 1)r[a].closed || (n = { transforms: i.addTransformSequence(r[a].transforms), trNodes: [] }, this.styledShapes.push(n), r[a].elements.push(n)) } function BaseElement() {} function NullElement(t, e, r) { this.initFrame(), this.initBaseData(t, e, r), this.initFrame(), this.initTransform(t, e, r), this.initHierarchy() } function SVGBaseElement() {} function IShapeElement() {} function ITextElement() {} function ICompElement() {} function IImageElement(t, e, r) {
    this.assetData = e.getAssetData(t.refId), this.initElement(t, e, r), this.sourceRect = {
      top: 0, left: 0, width: this.assetData.w, height: this.assetData.h
    }
  } function ISolidElement(t, e, r) { this.initElement(t, e, r) } function SVGCompElement(t, e, r) { this.layers = t.layers, this.supports3d = !0, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(t, e, r), this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : { _placeholder: !0 } } function SVGTextElement(t, e, r) { this.textSpans = [], this.renderType = 'svg', this.initElement(t, e, r) } function SVGShapeElement(t, e, r) { this.shapes = [], this.shapesData = t.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.initElement(t, e, r), this.prevViewData = [] } function SVGTintFilter(t, e) { this.filterManager = e; let r = createNS('feColorMatrix'); if (r.setAttribute('type', 'matrix'), r.setAttribute('color-interpolation-filters', 'linearRGB'), r.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0'), r.setAttribute('result', 'f1'), t.appendChild(r), (r = createNS('feColorMatrix')).setAttribute('type', 'matrix'), r.setAttribute('color-interpolation-filters', 'sRGB'), r.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0'), r.setAttribute('result', 'f2'), t.appendChild(r), this.matrixFilter = r, e.effectElements[2].p.v !== 100 || e.effectElements[2].p.k) { let i; const s = createNS('feMerge'); t.appendChild(s), (i = createNS('feMergeNode')).setAttribute('in', 'SourceGraphic'), s.appendChild(i), (i = createNS('feMergeNode')).setAttribute('in', 'f2'), s.appendChild(i) } } function SVGFillFilter(t, e) { this.filterManager = e; const r = createNS('feColorMatrix'); r.setAttribute('type', 'matrix'), r.setAttribute('color-interpolation-filters', 'sRGB'), r.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0'), t.appendChild(r), this.matrixFilter = r } function SVGGaussianBlurEffect(t, e) { t.setAttribute('x', '-100%'), t.setAttribute('y', '-100%'), t.setAttribute('width', '300%'), t.setAttribute('height', '300%'), this.filterManager = e; const r = createNS('feGaussianBlur'); t.appendChild(r), this.feGaussianBlur = r } function SVGStrokeEffect(t, e) { this.initialized = !1, this.filterManager = e, this.elem = t, this.paths = [] } function SVGTritoneFilter(t, e) { this.filterManager = e; const r = createNS('feColorMatrix'); r.setAttribute('type', 'matrix'), r.setAttribute('color-interpolation-filters', 'linearRGB'), r.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0'), r.setAttribute('result', 'f1'), t.appendChild(r); const i = createNS('feComponentTransfer'); i.setAttribute('color-interpolation-filters', 'sRGB'), t.appendChild(i), this.matrixFilter = i; const s = createNS('feFuncR'); s.setAttribute('type', 'table'), i.appendChild(s), this.feFuncR = s; const a = createNS('feFuncG'); a.setAttribute('type', 'table'), i.appendChild(a), this.feFuncG = a; const n = createNS('feFuncB'); n.setAttribute('type', 'table'), i.appendChild(n), this.feFuncB = n } function SVGProLevelsFilter(t, e) { this.filterManager = e; const r = this.filterManager.effectElements; let i = createNS('feComponentTransfer'); (r[10].p.k || r[10].p.v !== 0 || r[11].p.k || r[11].p.v !== 1 || r[12].p.k || r[12].p.v !== 1 || r[13].p.k || r[13].p.v !== 0 || r[14].p.k || r[14].p.v !== 1) && (this.feFuncR = this.createFeFunc('feFuncR', i)), (r[17].p.k || r[17].p.v !== 0 || r[18].p.k || r[18].p.v !== 1 || r[19].p.k || r[19].p.v !== 1 || r[20].p.k || r[20].p.v !== 0 || r[21].p.k || r[21].p.v !== 1) && (this.feFuncG = this.createFeFunc('feFuncG', i)), (r[24].p.k || r[24].p.v !== 0 || r[25].p.k || r[25].p.v !== 1 || r[26].p.k || r[26].p.v !== 1 || r[27].p.k || r[27].p.v !== 0 || r[28].p.k || r[28].p.v !== 1) && (this.feFuncB = this.createFeFunc('feFuncB', i)), (r[31].p.k || r[31].p.v !== 0 || r[32].p.k || r[32].p.v !== 1 || r[33].p.k || r[33].p.v !== 1 || r[34].p.k || r[34].p.v !== 0 || r[35].p.k || r[35].p.v !== 1) && (this.feFuncA = this.createFeFunc('feFuncA', i)), (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (i.setAttribute('color-interpolation-filters', 'sRGB'), t.appendChild(i), i = createNS('feComponentTransfer')), (r[3].p.k || r[3].p.v !== 0 || r[4].p.k || r[4].p.v !== 1 || r[5].p.k || r[5].p.v !== 1 || r[6].p.k || r[6].p.v !== 0 || r[7].p.k || r[7].p.v !== 1) && (i.setAttribute('color-interpolation-filters', 'sRGB'), t.appendChild(i), this.feFuncRComposed = this.createFeFunc('feFuncR', i), this.feFuncGComposed = this.createFeFunc('feFuncG', i), this.feFuncBComposed = this.createFeFunc('feFuncB', i)) } function SVGDropShadowEffect(t, e) { const r = e.container.globalData.renderConfig.filterSize; t.setAttribute('x', r.x), t.setAttribute('y', r.y), t.setAttribute('width', r.width), t.setAttribute('height', r.height), this.filterManager = e; const i = createNS('feGaussianBlur'); i.setAttribute('in', 'SourceAlpha'), i.setAttribute('result', 'drop_shadow_1'), i.setAttribute('stdDeviation', '0'), this.feGaussianBlur = i, t.appendChild(i); const s = createNS('feOffset'); s.setAttribute('dx', '25'), s.setAttribute('dy', '0'), s.setAttribute('in', 'drop_shadow_1'), s.setAttribute('result', 'drop_shadow_2'), this.feOffset = s, t.appendChild(s); const a = createNS('feFlood'); a.setAttribute('flood-color', '#00ff00'), a.setAttribute('flood-opacity', '1'), a.setAttribute('result', 'drop_shadow_3'), this.feFlood = a, t.appendChild(a); const n = createNS('feComposite'); n.setAttribute('in', 'drop_shadow_3'), n.setAttribute('in2', 'drop_shadow_2'), n.setAttribute('operator', 'in'), n.setAttribute('result', 'drop_shadow_4'), t.appendChild(n); let o; const h = createNS('feMerge'); t.appendChild(h), o = createNS('feMergeNode'), h.appendChild(o), (o = createNS('feMergeNode')).setAttribute('in', 'SourceGraphic'), this.feMergeNode = o, this.feMerge = h, this.originalNodeAdded = !1, h.appendChild(o) }ShapeTransformManager.prototype = {
    addTransformSequence(t) { let e; const r = t.length; let i = '_'; for (e = 0; e < r; e += 1)i += `${t[e].transform.key}_`; let s = this.sequences[i]; return s || (s = { transforms: [].concat(t), finalTransform: new Matrix(), _mdf: !1 }, this.sequences[i] = s, this.sequenceList.push(s)), s }, processSequence(t, e) { for (var r, i = 0, s = t.transforms.length, a = e; i < s && !e;) { if (t.transforms[i].transform.mProps._mdf) { a = !0; break }i += 1 } if (a) for (t.finalTransform.reset(), i = s - 1; i >= 0; i -= 1)r = t.transforms[i].transform.mProps.v.props, t.finalTransform.transform(r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], r[11], r[12], r[13], r[14], r[15]); t._mdf = a }, processSequences(t) { let e; const r = this.sequenceList.length; for (e = 0; e < r; e += 1) this.processSequence(this.sequenceList[e], t) }, getNewKey() { return `_${this.transform_key_count++}` }
  }, CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated, BaseElement.prototype = {
    checkMasks() { if (!this.data.hasMask) return !1; for (let t = 0, e = this.data.masksProperties.length; t < e;) { if (this.data.masksProperties[t].mode !== 'n' && !1 !== this.data.masksProperties[t].cl) return !0; t += 1 } return !1 }, initExpressions() { this.layerInterface = LayerExpressionInterface(this), this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager); const t = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface); this.layerInterface.registerEffectsInterface(t), this.data.ty === 0 || this.data.xt ? this.compInterface = CompExpressionInterface(this) : this.data.ty === 4 ? (this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface), this.layerInterface.content = this.layerInterface.shapeInterface) : this.data.ty === 5 && (this.layerInterface.textInterface = TextExpressionInterface(this), this.layerInterface.text = this.layerInterface.textInterface) }, setBlendMode() { const t = getBlendMode(this.data.bm); (this.baseElement || this.layerElement).style['mix-blend-mode'] = t }, initBaseData(t, e, r) { this.globalData = e, this.comp = r, this.data = t, this.layerId = createElementID(), this.data.sr || (this.data.sr = 1), this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties) }, getType() { return this.type }, sourceRectAtTime() {}
  }, NullElement.prototype.prepareFrame = function (t) { this.prepareProperties(t, !0) }, NullElement.prototype.renderFrame = function () {}, NullElement.prototype.getBaseElement = function () { return null }, NullElement.prototype.destroy = function () {}, NullElement.prototype.sourceRectAtTime = function () {}, NullElement.prototype.hide = function () {}, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement), SVGBaseElement.prototype = {
    initRendererElement() { this.layerElement = createNS('g') }, createContainerElements() { this.matteElement = createNS('g'), this.transformedElement = this.layerElement, this.maskedElement = this.layerElement, this._sizeChanged = !1; let t; let e; let r; let i = null; if (this.data.td) { if (this.data.td == 3 || this.data.td == 1) { const s = createNS('mask'); s.setAttribute('id', this.layerId), s.setAttribute('mask-type', this.data.td == 3 ? 'luminance' : 'alpha'), s.appendChild(this.layerElement), i = s, this.globalData.defs.appendChild(s), featureSupport.maskType || this.data.td != 1 || (s.setAttribute('mask-type', 'luminance'), t = createElementID(), e = filtersFactory.createFilter(t), this.globalData.defs.appendChild(e), e.appendChild(filtersFactory.createAlphaToLuminanceFilter()), (r = createNS('g')).appendChild(this.layerElement), i = r, s.appendChild(r), r.setAttribute('filter', `url(${locationHref}#${t})`)) } else if (this.data.td == 2) { const a = createNS('mask'); a.setAttribute('id', this.layerId), a.setAttribute('mask-type', 'alpha'); const n = createNS('g'); a.appendChild(n), t = createElementID(), e = filtersFactory.createFilter(t); const o = createNS('feComponentTransfer'); o.setAttribute('in', 'SourceGraphic'), e.appendChild(o); const h = createNS('feFuncA'); h.setAttribute('type', 'table'), h.setAttribute('tableValues', '1.0 0.0'), o.appendChild(h), this.globalData.defs.appendChild(e); const l = createNS('rect'); l.setAttribute('width', this.comp.data.w), l.setAttribute('height', this.comp.data.h), l.setAttribute('x', '0'), l.setAttribute('y', '0'), l.setAttribute('fill', '#ffffff'), l.setAttribute('opacity', '0'), n.setAttribute('filter', `url(${locationHref}#${t})`), n.appendChild(l), n.appendChild(this.layerElement), i = n, featureSupport.maskType || (a.setAttribute('mask-type', 'luminance'), e.appendChild(filtersFactory.createAlphaToLuminanceFilter()), r = createNS('g'), n.appendChild(l), r.appendChild(this.layerElement), i = r, n.appendChild(r)), this.globalData.defs.appendChild(a) } } else this.data.tt ? (this.matteElement.appendChild(this.layerElement), i = this.matteElement, this.baseElement = this.matteElement) : this.baseElement = this.layerElement; if (this.data.ln && this.layerElement.setAttribute('id', this.data.ln), this.data.cl && this.layerElement.setAttribute('class', this.data.cl), this.data.ty === 0 && !this.data.hd) { const p = createNS('clipPath'); const m = createNS('path'); m.setAttribute('d', `M0,0 L${this.data.w},0 L${this.data.w},${this.data.h} L0,${this.data.h}z`); const f = createElementID(); if (p.setAttribute('id', f), p.appendChild(m), this.globalData.defs.appendChild(p), this.checkMasks()) { const c = createNS('g'); c.setAttribute('clip-path', `url(${locationHref}#${f})`), c.appendChild(this.layerElement), this.transformedElement = c, i ? i.appendChild(this.transformedElement) : this.baseElement = this.transformedElement } else this.layerElement.setAttribute('clip-path', `url(${locationHref}#${f})`) } this.data.bm !== 0 && this.setBlendMode() }, renderElement() { this.finalTransform._matMdf && this.transformedElement.setAttribute('transform', this.finalTransform.mat.to2dCSS()), this.finalTransform._opMdf && this.transformedElement.setAttribute('opacity', this.finalTransform.mProp.o.v) }, destroyBaseElement() { this.layerElement = null, this.matteElement = null, this.maskManager.destroy() }, getBaseElement() { return this.data.hd ? null : this.baseElement }, createRenderableComponents() { this.maskManager = new MaskElement(this.data, this, this.globalData), this.renderableEffectsManager = new SVGEffects(this) }, setMatte(t) { this.matteElement && this.matteElement.setAttribute('mask', `url(${locationHref}#${t})`) }
  }, IShapeElement.prototype = {
    addShapeToModifiers(t) { let e; const r = this.shapeModifiers.length; for (e = 0; e < r; e += 1) this.shapeModifiers[e].addShape(t) }, isShapeInAnimatedModifiers(t) { for (let e = this.shapeModifiers.length; e > 0;) if (this.shapeModifiers[0].isAnimatedWithShape(t)) return !0; return !1 }, renderModifiers() { if (this.shapeModifiers.length) { let t; let e = this.shapes.length; for (t = 0; t < e; t += 1) this.shapes[t].sh.reset(); for (t = (e = this.shapeModifiers.length) - 1; t >= 0; t -= 1) this.shapeModifiers[t].processShapes(this._isFirstFrame) } }, lcEnum: { 1: 'butt', 2: 'round', 3: 'square' }, ljEnum: { 1: 'miter', 2: 'round', 3: 'bevel' }, searchProcessedElement(t) { for (let e = this.processedElements, r = 0, i = e.length; r < i;) { if (e[r].elem === t) return e[r].pos; r += 1 } return 0 }, addProcessedElement(t, e) { for (var r = this.processedElements, i = r.length; i;) if (r[i -= 1].elem === t) return void (r[i].pos = e); r.push(new ProcessedElement(t, e)) }, prepareFrame(t) { this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange) }
  }, ITextElement.prototype.initElement = function (t, e, r) { this.lettersChangedFlag = !0, this.initFrame(), this.initBaseData(t, e, r), this.textProperty = new TextProperty(this, t.t, this.dynamicProperties), this.textAnimator = new TextAnimatorProperty(t.t, this.renderType, this), this.initTransform(t, e, r), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide(), this.textAnimator.searchProperties(this.dynamicProperties) }, ITextElement.prototype.prepareFrame = function (t) { this._mdf = !1, this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange), (this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(), this.textProperty._isFirstFrame = !1, this.textProperty._mdf = !1) }, ITextElement.prototype.createPathShape = function (t, e) { let r; let i; const s = e.length; let a = ''; for (r = 0; r < s; r += 1)i = e[r].ks.k, a += buildShapeString(i, i.i.length, !0, t); return a }, ITextElement.prototype.updateDocumentData = function (t, e) { this.textProperty.updateDocumentData(t, e) }, ITextElement.prototype.canResizeFont = function (t) { this.textProperty.canResizeFont(t) }, ITextElement.prototype.setMinimumFontSize = function (t) { this.textProperty.setMinimumFontSize(t) }, ITextElement.prototype.applyTextPropertiesToMatrix = function (t, e, r, i, s) { switch (t.ps && e.translate(t.ps[0], t.ps[1] + t.ascent, 0), e.translate(0, -t.ls, 0), t.j) { case 1: e.translate(t.justifyOffset + (t.boxWidth - t.lineWidths[r]), 0, 0); break; case 2: e.translate(t.justifyOffset + (t.boxWidth - t.lineWidths[r]) / 2, 0, 0) }e.translate(i, s, 0) }, ITextElement.prototype.buildColor = function (t) { return `rgb(${Math.round(255 * t[0])},${Math.round(255 * t[1])},${Math.round(255 * t[2])})` }, ITextElement.prototype.emptyProp = new LetterProps(), ITextElement.prototype.destroy = function () {}, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement), ICompElement.prototype.initElement = function (t, e, r) { this.initFrame(), this.initBaseData(t, e, r), this.initTransform(t, e, r), this.initRenderable(), this.initHierarchy(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), !this.data.xt && e.progressiveLoad || this.buildAllItems(), this.hide() }, ICompElement.prototype.prepareFrame = function (t) { if (this._mdf = !1, this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange), this.isInRange || this.data.xt) { if (this.tm._placeholder) this.renderedFrame = t / this.data.sr; else { let e = this.tm.v; e === this.data.op && (e = this.data.op - 1), this.renderedFrame = e } let r; const i = this.elements.length; for (this.completeLayers || this.checkLayers(this.renderedFrame), r = i - 1; r >= 0; r -= 1)(this.completeLayers || this.elements[r]) && (this.elements[r].prepareFrame(this.renderedFrame - this.layers[r].st), this.elements[r]._mdf && (this._mdf = !0)) } }, ICompElement.prototype.renderInnerContent = function () { let t; const e = this.layers.length; for (t = 0; t < e; t += 1)(this.completeLayers || this.elements[t]) && this.elements[t].renderFrame() }, ICompElement.prototype.setElements = function (t) { this.elements = t }, ICompElement.prototype.getElements = function () { return this.elements }, ICompElement.prototype.destroyElements = function () { let t; const e = this.layers.length; for (t = 0; t < e; t += 1) this.elements[t] && this.elements[t].destroy() }, ICompElement.prototype.destroy = function () { this.destroyElements(), this.destroyBaseElement() }, extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement), IImageElement.prototype.createContent = function () { const t = this.globalData.getAssetsPath(this.assetData); this.innerElem = createNS('image'), this.innerElem.setAttribute('width', `${this.assetData.w}px`), this.innerElem.setAttribute('height', `${this.assetData.h}px`), this.innerElem.setAttribute('preserveAspectRatio', this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio), this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', t), this.layerElement.appendChild(this.innerElem) }, IImageElement.prototype.sourceRectAtTime = function () { return this.sourceRect }, extendPrototype([IImageElement], ISolidElement), ISolidElement.prototype.createContent = function () { const t = createNS('rect'); t.setAttribute('width', this.data.sw), t.setAttribute('height', this.data.sh), t.setAttribute('fill', this.data.sc), this.layerElement.appendChild(t) }, extendPrototype([SVGRenderer, ICompElement, SVGBaseElement], SVGCompElement), extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextElement), SVGTextElement.prototype.createContent = function () { this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS('text')) }, SVGTextElement.prototype.buildTextContents = function (t) { for (var e = 0, r = t.length, i = [], s = ''; e < r;)t[e] === String.fromCharCode(13) || t[e] === String.fromCharCode(3) ? (i.push(s), s = '') : s += t[e], e += 1; return i.push(s), i }, SVGTextElement.prototype.buildNewText = function () { let t; let e; const r = this.textProperty.currentData; this.renderedLetters = createSizedArray(r ? r.l.length : 0), r.fc ? this.layerElement.setAttribute('fill', this.buildColor(r.fc)) : this.layerElement.setAttribute('fill', 'rgba(0,0,0,0)'), r.sc && (this.layerElement.setAttribute('stroke', this.buildColor(r.sc)), this.layerElement.setAttribute('stroke-width', r.sw)), this.layerElement.setAttribute('font-size', r.finalSize); const i = this.globalData.fontManager.getFontByName(r.f); if (i.fClass) this.layerElement.setAttribute('class', i.fClass); else { this.layerElement.setAttribute('font-family', i.fFamily); const s = r.fWeight; const a = r.fStyle; this.layerElement.setAttribute('font-style', a), this.layerElement.setAttribute('font-weight', s) } this.layerElement.setAttribute('aria-label', r.t); let n; const o = r.l || []; const h = !!this.globalData.fontManager.chars; e = o.length; let l; const p = this.mHelper; let m = ''; const f = this.data.singleShape; let c = 0; let d = 0; let u = !0; const y = r.tr / 1e3 * r.finalSize; if (!f || h || r.sz) { let g; let v; const b = this.textSpans.length; for (t = 0; t < e; t += 1)h && f && t !== 0 || (n = t < b ? this.textSpans[t] : createNS(h ? 'path' : 'text'), b <= t && (n.setAttribute('stroke-linecap', 'butt'), n.setAttribute('stroke-linejoin', 'round'), n.setAttribute('stroke-miterlimit', '4'), this.textSpans[t] = n, this.layerElement.appendChild(n)), n.style.display = 'inherit'), p.reset(), p.scale(r.finalSize / 100, r.finalSize / 100), f && (o[t].n && (c = -y, d += r.yOffset, d += u ? 1 : 0, u = !1), this.applyTextPropertiesToMatrix(r, p, o[t].line, c, d), c += o[t].l || 0, c += y), h ? (l = (g = (v = this.globalData.fontManager.getCharData(r.finalText[t], i.fStyle, this.globalData.fontManager.getFontByName(r.f).fFamily)) && v.data || {}).shapes ? g.shapes[0].it : [], f ? m += this.createPathShape(p, l) : n.setAttribute('d', this.createPathShape(p, l))) : (f && n.setAttribute('transform', `translate(${p.props[12]},${p.props[13]})`), n.textContent = o[t].val, n.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve')); f && n && n.setAttribute('d', m) } else { const E = this.textContainer; let x = 'start'; switch (r.j) { case 1: x = 'end'; break; case 2: x = 'middle' }E.setAttribute('text-anchor', x), E.setAttribute('letter-spacing', y); const S = this.buildTextContents(r.finalText); for (e = S.length, d = r.ps ? r.ps[1] + r.ascent : 0, t = 0; t < e; t += 1)(n = this.textSpans[t] || createNS('tspan')).textContent = S[t], n.setAttribute('x', 0), n.setAttribute('y', d), n.style.display = 'inherit', E.appendChild(n), this.textSpans[t] = n, d += r.finalLineHeight; this.layerElement.appendChild(E) } for (;t < this.textSpans.length;) this.textSpans[t].style.display = 'none', t += 1; this._sizeChanged = !0 }, SVGTextElement.prototype.sourceRectAtTime = function (t) {
    if (this.prepareFrame(this.comp.renderedFrame - this.data.st), this.renderInnerContent(), this._sizeChanged) {
      this._sizeChanged = !1; const e = this.layerElement.getBBox(); this.bbox = {
        top: e.y, left: e.x, width: e.width, height: e.height
      }
    } return this.bbox
  }, SVGTextElement.prototype.renderInnerContent = function () { if (!this.data.singleShape && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) { let t; let e; this._sizeChanged = !0; let r; let i; const s = this.textAnimator.renderedLetters; const a = this.textProperty.currentData.l; for (e = a.length, t = 0; t < e; t += 1)a[t].n || (r = s[t], i = this.textSpans[t], r._mdf.m && i.setAttribute('transform', r.m), r._mdf.o && i.setAttribute('opacity', r.o), r._mdf.sw && i.setAttribute('stroke-width', r.sw), r._mdf.sc && i.setAttribute('stroke', r.sc), r._mdf.fc && i.setAttribute('fill', r.fc)) } }, extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement), SVGShapeElement.prototype.initSecondaryElement = function () {}, SVGShapeElement.prototype.identityMatrix = new Matrix(), SVGShapeElement.prototype.buildExpressionInterface = function () {}, SVGShapeElement.prototype.createContent = function () { this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes() }, SVGShapeElement.prototype.filterUniqueShapes = function () { let t; let e; let r; let i; const s = this.shapes.length; const a = this.stylesList.length; const n = []; let o = !1; for (r = 0; r < a; r += 1) { for (i = this.stylesList[r], o = !1, t = n.length = 0; t < s; t += 1)(e = this.shapes[t]).styles.indexOf(i) !== -1 && (n.push(e), o = e._isAnimated || o); n.length > 1 && o && this.setShapesAsAnimated(n) } }, SVGShapeElement.prototype.setShapesAsAnimated = function (t) { let e; const r = t.length; for (e = 0; e < r; e += 1)t[e].setAsAnimated() }, SVGShapeElement.prototype.createStyleElement = function (t, e) { let r; const i = new SVGStyleData(t, e); const s = i.pElem; if (t.ty === 'st')r = new SVGStrokeStyleData(this, t, i); else if (t.ty === 'fl')r = new SVGFillStyleData(this, t, i); else if (t.ty === 'gf' || t.ty === 'gs') { r = new (t.ty === 'gf' ? SVGGradientFillStyleData : SVGGradientStrokeStyleData)(this, t, i), this.globalData.defs.appendChild(r.gf), r.maskId && (this.globalData.defs.appendChild(r.ms), this.globalData.defs.appendChild(r.of), s.setAttribute('mask', `url(${locationHref}#${r.maskId})`)) } return t.ty !== 'st' && t.ty !== 'gs' || (s.setAttribute('stroke-linecap', this.lcEnum[t.lc] || 'round'), s.setAttribute('stroke-linejoin', this.ljEnum[t.lj] || 'round'), s.setAttribute('fill-opacity', '0'), t.lj === 1 && s.setAttribute('stroke-miterlimit', t.ml)), t.r === 2 && s.setAttribute('fill-rule', 'evenodd'), t.ln && s.setAttribute('id', t.ln), t.cl && s.setAttribute('class', t.cl), t.bm && (s.style['mix-blend-mode'] = getBlendMode(t.bm)), this.stylesList.push(i), this.addToAnimatedContents(t, r), r }, SVGShapeElement.prototype.createGroupElement = function (t) { const e = new ShapeGroupData(); return t.ln && e.gr.setAttribute('id', t.ln), t.cl && e.gr.setAttribute('class', t.cl), t.bm && (e.gr.style['mix-blend-mode'] = getBlendMode(t.bm)), e }, SVGShapeElement.prototype.createTransformElement = function (t, e) { const r = TransformPropertyFactory.getTransformProperty(this, t, this); const i = new SVGTransformData(r, r.o, e); return this.addToAnimatedContents(t, i), i }, SVGShapeElement.prototype.createShapeElement = function (t, e, r) { let i = 4; t.ty === 'rc' ? i = 5 : t.ty === 'el' ? i = 6 : t.ty === 'sr' && (i = 7); const s = new SVGShapeData(e, r, ShapePropertyFactory.getShapeProp(this, t, i, this)); return this.shapes.push(s), this.addShapeToModifiers(s), this.addToAnimatedContents(t, s), s }, SVGShapeElement.prototype.addToAnimatedContents = function (t, e) { for (let r = 0, i = this.animatedContents.length; r < i;) { if (this.animatedContents[r].element === e) return; r += 1 } this.animatedContents.push({ fn: SVGElementsRenderer.createRenderFunction(t), element: e, data: t }) }, SVGShapeElement.prototype.setElementStyles = function (t) { let e; const r = t.styles; const i = this.stylesList.length; for (e = 0; e < i; e += 1) this.stylesList[e].closed || r.push(this.stylesList[e]) }, SVGShapeElement.prototype.reloadShapes = function () { this._isFirstFrame = !0; let t; let e = this.itemsData.length; for (t = 0; t < e; t += 1) this.prevViewData[t] = this.itemsData[t]; for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes(), e = this.dynamicProperties.length, t = 0; t < e; t += 1) this.dynamicProperties[t].getValue(); this.renderModifiers() }, SVGShapeElement.prototype.searchShapes = function (t, e, r, i, s, a, n) { let o; let h; let l; let p; let m; let f; const c = [].concat(a); let d = t.length - 1; const u = []; const y = []; for (o = d; o >= 0; o -= 1) { if ((f = this.searchProcessedElement(t[o])) ? e[o] = r[f - 1] : t[o]._render = n, t[o].ty == 'fl' || t[o].ty == 'st' || t[o].ty == 'gf' || t[o].ty == 'gs')f ? e[o].style.closed = !1 : e[o] = this.createStyleElement(t[o], s), t[o]._render && i.appendChild(e[o].style.pElem), u.push(e[o].style); else if (t[o].ty == 'gr') { if (f) for (l = e[o].it.length, h = 0; h < l; h += 1)e[o].prevViewData[h] = e[o].it[h]; else e[o] = this.createGroupElement(t[o]); this.searchShapes(t[o].it, e[o].it, e[o].prevViewData, e[o].gr, s + 1, c, n), t[o]._render && i.appendChild(e[o].gr) } else t[o].ty == 'tr' ? (f || (e[o] = this.createTransformElement(t[o], i)), p = e[o].transform, c.push(p)) : t[o].ty == 'sh' || t[o].ty == 'rc' || t[o].ty == 'el' || t[o].ty == 'sr' ? (f || (e[o] = this.createShapeElement(t[o], c, s)), this.setElementStyles(e[o])) : t[o].ty == 'tm' || t[o].ty == 'rd' || t[o].ty == 'ms' ? (f ? (m = e[o]).closed = !1 : ((m = ShapeModifiers.getModifier(t[o].ty)).init(this, t[o]), e[o] = m, this.shapeModifiers.push(m)), y.push(m)) : t[o].ty == 'rp' && (f ? (m = e[o]).closed = !0 : (m = ShapeModifiers.getModifier(t[o].ty), (e[o] = m).init(this, t, o, e), this.shapeModifiers.push(m), n = !1), y.push(m)); this.addProcessedElement(t[o], o + 1) } for (d = u.length, o = 0; o < d; o += 1)u[o].closed = !0; for (d = y.length, o = 0; o < d; o += 1)y[o].closed = !0 }, SVGShapeElement.prototype.renderInnerContent = function () { this.renderModifiers(); let t; const e = this.stylesList.length; for (t = 0; t < e; t += 1) this.stylesList[t].reset(); for (this.renderShape(), t = 0; t < e; t += 1)(this.stylesList[t]._mdf || this._isFirstFrame) && (this.stylesList[t].msElem && (this.stylesList[t].msElem.setAttribute('d', this.stylesList[t].d), this.stylesList[t].d = `M0 0${this.stylesList[t].d}`), this.stylesList[t].pElem.setAttribute('d', this.stylesList[t].d || 'M0 0')) }, SVGShapeElement.prototype.renderShape = function () { let t; let e; const r = this.animatedContents.length; for (t = 0; t < r; t += 1)e = this.animatedContents[t], (this._isFirstFrame || e.element._isAnimated) && !0 !== e.data && e.fn(e.data, e.element, this._isFirstFrame) }, SVGShapeElement.prototype.destroy = function () { this.destroyBaseElement(), this.shapesData = null, this.itemsData = null }, SVGTintFilter.prototype.renderFrame = function (t) { if (t || this.filterManager._mdf) { const e = this.filterManager.effectElements[0].p.v; const r = this.filterManager.effectElements[1].p.v; const i = this.filterManager.effectElements[2].p.v / 100; this.matrixFilter.setAttribute('values', `${r[0] - e[0]} 0 0 0 ${e[0]} ${r[1] - e[1]} 0 0 0 ${e[1]} ${r[2] - e[2]} 0 0 0 ${e[2]} 0 0 0 ${i} 0`) } }, SVGFillFilter.prototype.renderFrame = function (t) { if (t || this.filterManager._mdf) { const e = this.filterManager.effectElements[2].p.v; const r = this.filterManager.effectElements[6].p.v; this.matrixFilter.setAttribute('values', `0 0 0 0 ${e[0]} 0 0 0 0 ${e[1]} 0 0 0 0 ${e[2]} 0 0 0 ${r} 0`) } }, SVGGaussianBlurEffect.prototype.renderFrame = function (t) { if (t || this.filterManager._mdf) { const e = 0.3 * this.filterManager.effectElements[0].p.v; const r = this.filterManager.effectElements[1].p.v; const i = r == 3 ? 0 : e; const s = r == 2 ? 0 : e; this.feGaussianBlur.setAttribute('stdDeviation', `${i} ${s}`); const a = this.filterManager.effectElements[2].p.v == 1 ? 'wrap' : 'duplicate'; this.feGaussianBlur.setAttribute('edgeMode', a) } }, SVGStrokeEffect.prototype.initialize = function () { let t; let e; let r; let i; let s = this.elem.layerElement.children || this.elem.layerElement.childNodes; for (this.filterManager.effectElements[1].p.v === 1 ? (i = this.elem.maskManager.masksProperties.length, r = 0) : i = (r = this.filterManager.effectElements[0].p.v - 1) + 1, (e = createNS('g')).setAttribute('fill', 'none'), e.setAttribute('stroke-linecap', 'round'), e.setAttribute('stroke-dashoffset', 1); r < i; r += 1)t = createNS('path'), e.appendChild(t), this.paths.push({ p: t, m: r }); if (this.filterManager.effectElements[10].p.v === 3) { const a = createNS('mask'); const n = createElementID(); a.setAttribute('id', n), a.setAttribute('mask-type', 'alpha'), a.appendChild(e), this.elem.globalData.defs.appendChild(a); const o = createNS('g'); for (o.setAttribute('mask', `url(${locationHref}#${n})`); s[0];)o.appendChild(s[0]); this.elem.layerElement.appendChild(o), this.masker = a, e.setAttribute('stroke', '#fff') } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) { if (this.filterManager.effectElements[10].p.v === 2) for (s = this.elem.layerElement.children || this.elem.layerElement.childNodes; s.length;) this.elem.layerElement.removeChild(s[0]); this.elem.layerElement.appendChild(e), this.elem.layerElement.removeAttribute('mask'), e.setAttribute('stroke', '#fff') } this.initialized = !0, this.pathMasker = e }, SVGStrokeEffect.prototype.renderFrame = function (t) { this.initialized || this.initialize(); let e; let r; let i; const s = this.paths.length; for (e = 0; e < s; e += 1) if (this.paths[e].m !== -1 && (r = this.elem.maskManager.viewData[this.paths[e].m], i = this.paths[e].p, (t || this.filterManager._mdf || r.prop._mdf) && i.setAttribute('d', r.lastPath), t || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || r.prop._mdf)) { var a; if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) { const n = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) / 100; const o = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) / 100; const h = i.getTotalLength(); a = `0 0 0 ${h * n} `; var l; const p = h * (o - n); const m = 1 + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v / 100; const f = Math.floor(p / m); for (l = 0; l < f; l += 1)a += `1 ${2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v / 100} `; a += `0 ${10 * h} 0 0` } else a = `1 ${2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v / 100}`; i.setAttribute('stroke-dasharray', a) } if ((t || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute('stroke-width', 2 * this.filterManager.effectElements[4].p.v), (t || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute('opacity', this.filterManager.effectElements[6].p.v), (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) && (t || this.filterManager.effectElements[3].p._mdf)) { const c = this.filterManager.effectElements[3].p.v; this.pathMasker.setAttribute('stroke', `rgb(${bm_floor(255 * c[0])},${bm_floor(255 * c[1])},${bm_floor(255 * c[2])})`) } }, SVGTritoneFilter.prototype.renderFrame = function (t) { if (t || this.filterManager._mdf) { const e = this.filterManager.effectElements[0].p.v; const r = this.filterManager.effectElements[1].p.v; const i = this.filterManager.effectElements[2].p.v; const s = `${i[0]} ${r[0]} ${e[0]}`; const a = `${i[1]} ${r[1]} ${e[1]}`; const n = `${i[2]} ${r[2]} ${e[2]}`; this.feFuncR.setAttribute('tableValues', s), this.feFuncG.setAttribute('tableValues', a), this.feFuncB.setAttribute('tableValues', n) } }, SVGProLevelsFilter.prototype.createFeFunc = function (t, e) { const r = createNS(t); return r.setAttribute('type', 'table'), e.appendChild(r), r }, SVGProLevelsFilter.prototype.getTableValue = function (t, e, r, i, s) { for (var a, n, o = 0, h = Math.min(t, e), l = Math.max(t, e), p = Array.call(null, { length: 256 }), m = 0, f = s - i, c = e - t; o <= 256;)n = (a = o / 256) <= h ? c < 0 ? s : i : l <= a ? c < 0 ? i : s : i + f * Math.pow((a - t) / c, 1 / r), p[m++] = n, o += 256 / 255; return p.join(' ') }, SVGProLevelsFilter.prototype.renderFrame = function (t) { if (t || this.filterManager._mdf) { let e; const r = this.filterManager.effectElements; this.feFuncRComposed && (t || r[3].p._mdf || r[4].p._mdf || r[5].p._mdf || r[6].p._mdf || r[7].p._mdf) && (e = this.getTableValue(r[3].p.v, r[4].p.v, r[5].p.v, r[6].p.v, r[7].p.v), this.feFuncRComposed.setAttribute('tableValues', e), this.feFuncGComposed.setAttribute('tableValues', e), this.feFuncBComposed.setAttribute('tableValues', e)), this.feFuncR && (t || r[10].p._mdf || r[11].p._mdf || r[12].p._mdf || r[13].p._mdf || r[14].p._mdf) && (e = this.getTableValue(r[10].p.v, r[11].p.v, r[12].p.v, r[13].p.v, r[14].p.v), this.feFuncR.setAttribute('tableValues', e)), this.feFuncG && (t || r[17].p._mdf || r[18].p._mdf || r[19].p._mdf || r[20].p._mdf || r[21].p._mdf) && (e = this.getTableValue(r[17].p.v, r[18].p.v, r[19].p.v, r[20].p.v, r[21].p.v), this.feFuncG.setAttribute('tableValues', e)), this.feFuncB && (t || r[24].p._mdf || r[25].p._mdf || r[26].p._mdf || r[27].p._mdf || r[28].p._mdf) && (e = this.getTableValue(r[24].p.v, r[25].p.v, r[26].p.v, r[27].p.v, r[28].p.v), this.feFuncB.setAttribute('tableValues', e)), this.feFuncA && (t || r[31].p._mdf || r[32].p._mdf || r[33].p._mdf || r[34].p._mdf || r[35].p._mdf) && (e = this.getTableValue(r[31].p.v, r[32].p.v, r[33].p.v, r[34].p.v, r[35].p.v), this.feFuncA.setAttribute('tableValues', e)) } }, SVGDropShadowEffect.prototype.renderFrame = function (t) { if (t || this.filterManager._mdf) { if ((t || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute('stdDeviation', this.filterManager.effectElements[4].p.v / 4), t || this.filterManager.effectElements[0].p._mdf) { const e = this.filterManager.effectElements[0].p.v; this.feFlood.setAttribute('flood-color', rgbToHex(Math.round(255 * e[0]), Math.round(255 * e[1]), Math.round(255 * e[2]))) } if ((t || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute('flood-opacity', this.filterManager.effectElements[1].p.v / 255), t || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) { const r = this.filterManager.effectElements[3].p.v; const i = (this.filterManager.effectElements[2].p.v - 90) * degToRads; const s = r * Math.cos(i); const a = r * Math.sin(i); this.feOffset.setAttribute('dx', s), this.feOffset.setAttribute('dy', a) } } }; const _svgMatteSymbols = []; function SVGMatte3Effect(t, e, r) { this.initialized = !1, this.filterManager = e, this.filterElem = t, (this.elem = r).matteElement = createNS('g'), r.matteElement.appendChild(r.layerElement), r.matteElement.appendChild(r.transformedElement), r.baseElement = r.matteElement } function SVGEffects(t) { let e; let r; const i = t.data.ef ? t.data.ef.length : 0; const s = createElementID(); const a = filtersFactory.createFilter(s); let n = 0; for (this.filters = [], e = 0; e < i; e += 1)r = null, t.data.ef[e].ty === 20 ? (n += 1, r = new SVGTintFilter(a, t.effectsManager.effectElements[e])) : t.data.ef[e].ty === 21 ? (n += 1, r = new SVGFillFilter(a, t.effectsManager.effectElements[e])) : t.data.ef[e].ty === 22 ? r = new SVGStrokeEffect(t, t.effectsManager.effectElements[e]) : t.data.ef[e].ty === 23 ? (n += 1, r = new SVGTritoneFilter(a, t.effectsManager.effectElements[e])) : t.data.ef[e].ty === 24 ? (n += 1, r = new SVGProLevelsFilter(a, t.effectsManager.effectElements[e])) : t.data.ef[e].ty === 25 ? (n += 1, r = new SVGDropShadowEffect(a, t.effectsManager.effectElements[e])) : t.data.ef[e].ty === 28 ? r = new SVGMatte3Effect(a, t.effectsManager.effectElements[e], t) : t.data.ef[e].ty === 29 && (n += 1, r = new SVGGaussianBlurEffect(a, t.effectsManager.effectElements[e])), r && this.filters.push(r); n && (t.globalData.defs.appendChild(a), t.layerElement.setAttribute('filter', `url(${locationHref}#${s})`)), this.filters.length && t.addRenderableComponent(this) } function CVContextData() { this.saved = [], this.cArrPos = 0, this.cTr = new Matrix(), this.cO = 1; let t; for (this.savedOp = createTypedArray('float32', 15), t = 0; t < 15; t += 1) this.saved[t] = createTypedArray('float32', 16); this._length = 15 } function CVBaseElement() {} function CVImageElement(t, e, r) { this.assetData = e.getAssetData(t.refId), this.img = e.imageLoader.getImage(this.assetData), this.initElement(t, e, r) } function CVCompElement(t, e, r) { this.completeLayers = !1, this.layers = t.layers, this.pendingElements = [], this.elements = createSizedArray(this.layers.length), this.initElement(t, e, r), this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : { _placeholder: !0 } } function CVMaskElement(t, e) { this.data = t, this.element = e, this.masksProperties = this.data.masksProperties || [], this.viewData = createSizedArray(this.masksProperties.length); let r; const i = this.masksProperties.length; let s = !1; for (r = 0; r < i; r++) this.masksProperties[r].mode !== 'n' && (s = !0), this.viewData[r] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[r], 3); (this.hasMasks = s) && this.element.addRenderableComponent(this) } function CVShapeElement(t, e, r) { this.shapes = [], this.shapesData = t.shapes, this.stylesList = [], this.itemsData = [], this.prevViewData = [], this.shapeModifiers = [], this.processedElements = [], this.transformsManager = new ShapeTransformManager(), this.initElement(t, e, r) } function CVSolidElement(t, e, r) { this.initElement(t, e, r) } function CVTextElement(t, e, r) {
    this.textSpans = [], this.yOffset = 0, this.fillColorAnim = !1, this.strokeColorAnim = !1, this.strokeWidthAnim = !1, this.stroke = !1, this.fill = !1, this.justifyOffset = 0, this.currentRender = null, this.renderType = 'canvas', this.values = {
      fill: 'rgba(0,0,0,0)', stroke: 'rgba(0,0,0,0)', sWidth: 0, fValue: ''
    }, this.initElement(t, e, r)
  } function CVEffects() {} function HBaseElement(t, e, r) {} function HSolidElement(t, e, r) { this.initElement(t, e, r) } function HCompElement(t, e, r) { this.layers = t.layers, this.supports3d = !t.hasMask, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(t, e, r), this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : { _placeholder: !0 } } function HShapeElement(t, e, r) {
    this.shapes = [], this.shapesData = t.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.shapesContainer = createNS('g'), this.initElement(t, e, r), this.prevViewData = [], this.currentBBox = {
      x: 999999, y: -999999, h: 0, w: 0
    }
  } function HTextElement(t, e, r) {
    this.textSpans = [], this.textPaths = [], this.currentBBox = {
      x: 999999, y: -999999, h: 0, w: 0
    }, this.renderType = 'svg', this.isMasked = !1, this.initElement(t, e, r)
  } function HImageElement(t, e, r) { this.assetData = e.getAssetData(t.refId), this.initElement(t, e, r) } function HCameraElement(t, e, r) { this.initFrame(), this.initBaseData(t, e, r), this.initHierarchy(); const i = PropertyFactory.getProp; if (this.pe = i(this, t.pe, 0, 0, this), t.ks.p.s ? (this.px = i(this, t.ks.p.x, 1, 0, this), this.py = i(this, t.ks.p.y, 1, 0, this), this.pz = i(this, t.ks.p.z, 1, 0, this)) : this.p = i(this, t.ks.p, 1, 0, this), t.ks.a && (this.a = i(this, t.ks.a, 1, 0, this)), t.ks.or.k.length && t.ks.or.k[0].to) { let s; const a = t.ks.or.k.length; for (s = 0; s < a; s += 1)t.ks.or.k[s].to = null, t.ks.or.k[s].ti = null } this.or = i(this, t.ks.or, 1, degToRads, this), this.or.sh = !0, this.rx = i(this, t.ks.rx, 0, degToRads, this), this.ry = i(this, t.ks.ry, 0, degToRads, this), this.rz = i(this, t.ks.rz, 0, degToRads, this), this.mat = new Matrix(), this._prevMat = new Matrix(), this._isFirstFrame = !0, this.finalTransform = { mProp: this } } function HEffects() {}SVGMatte3Effect.prototype.findSymbol = function (t) { for (let e = 0, r = _svgMatteSymbols.length; e < r;) { if (_svgMatteSymbols[e] === t) return _svgMatteSymbols[e]; e += 1 } return null }, SVGMatte3Effect.prototype.replaceInParent = function (t, e) { const r = t.layerElement.parentNode; if (r) { for (var i, s = r.children, a = 0, n = s.length; a < n && s[a] !== t.layerElement;)a += 1; a <= n - 2 && (i = s[a + 1]); const o = createNS('use'); o.setAttribute('href', `#${e}`), i ? r.insertBefore(o, i) : r.appendChild(o) } }, SVGMatte3Effect.prototype.setElementAsMask = function (t, e) { if (!this.findSymbol(e)) { const r = createElementID(); const i = createNS('mask'); i.setAttribute('id', e.layerId), i.setAttribute('mask-type', 'alpha'), _svgMatteSymbols.push(e); const s = t.globalData.defs; s.appendChild(i); const a = createNS('symbol'); a.setAttribute('id', r), this.replaceInParent(e, r), a.appendChild(e.layerElement), s.appendChild(a); const n = createNS('use'); n.setAttribute('href', `#${r}`), i.appendChild(n), e.data.hd = !1, e.show() }t.setMatte(e.layerId) }, SVGMatte3Effect.prototype.initialize = function () { for (let t = this.filterManager.effectElements[0].p.v, e = this.elem.comp.elements, r = 0, i = e.length; r < i;)e[r] && e[r].data.ind === t && this.setElementAsMask(this.elem, e[r]), r += 1; this.initialized = !0 }, SVGMatte3Effect.prototype.renderFrame = function () { this.initialized || this.initialize() }, SVGEffects.prototype.renderFrame = function (t) { let e; const r = this.filters.length; for (e = 0; e < r; e += 1) this.filters[e].renderFrame(t) }, CVContextData.prototype.duplicate = function () { const t = 2 * this._length; const e = this.savedOp; this.savedOp = createTypedArray('float32', t), this.savedOp.set(e); let r = 0; for (r = this._length; r < t; r += 1) this.saved[r] = createTypedArray('float32', 16); this._length = t }, CVContextData.prototype.reset = function () { this.cArrPos = 0, this.cTr.reset(), this.cO = 1 }, CVBaseElement.prototype = {
    createElements() {}, initRendererElement() {}, createContainerElements() { this.canvasContext = this.globalData.canvasContext, this.renderableEffectsManager = new CVEffects(this) }, createContent() {}, setBlendMode() { const t = this.globalData; if (t.blendMode !== this.data.bm) { t.blendMode = this.data.bm; const e = getBlendMode(this.data.bm); t.canvasContext.globalCompositeOperation = e } }, createRenderableComponents() { this.maskManager = new CVMaskElement(this.data, this) }, hideElement() { this.hidden || this.isInRange && !this.isTransparent || (this.hidden = !0) }, showElement() { this.isInRange && !this.isTransparent && (this.hidden = !1, this._isFirstFrame = !0, this.maskManager._isFirstFrame = !0) }, renderFrame() { if (!this.hidden && !this.data.hd) { this.renderTransform(), this.renderRenderable(), this.setBlendMode(); const t = this.data.ty === 0; this.globalData.renderer.save(t), this.globalData.renderer.ctxTransform(this.finalTransform.mat.props), this.globalData.renderer.ctxOpacity(this.finalTransform.mProp.o.v), this.renderInnerContent(), this.globalData.renderer.restore(t), this.maskManager.hasMasks && this.globalData.renderer.restore(!0), this._isFirstFrame && (this._isFirstFrame = !1) } }, destroy() { this.canvasContext = null, this.data = null, this.globalData = null, this.maskManager.destroy() }, mHelper: new Matrix()
  }, CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement, CVBaseElement.prototype.show = CVBaseElement.prototype.showElement, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement), CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVImageElement.prototype.createContent = function () { if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) { const t = createTag('canvas'); t.width = this.assetData.w, t.height = this.assetData.h; let e; let r; const i = t.getContext('2d'); const s = this.img.width; const a = this.img.height; const n = s / a; const o = this.assetData.w / this.assetData.h; const h = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio; o < n && h === 'xMidYMid slice' || n < o && h !== 'xMidYMid slice' ? e = (r = a) * o : r = (e = s) / o, i.drawImage(this.img, (s - e) / 2, (a - r) / 2, e, r, 0, 0, this.assetData.w, this.assetData.h), this.img = t } }, CVImageElement.prototype.renderInnerContent = function (t) { this.canvasContext.drawImage(this.img, 0, 0) }, CVImageElement.prototype.destroy = function () { this.img = null }, extendPrototype([CanvasRenderer, ICompElement, CVBaseElement], CVCompElement), CVCompElement.prototype.renderInnerContent = function () { let t; const e = this.canvasContext; for (e.beginPath(), e.moveTo(0, 0), e.lineTo(this.data.w, 0), e.lineTo(this.data.w, this.data.h), e.lineTo(0, this.data.h), e.lineTo(0, 0), e.clip(), t = this.layers.length - 1; t >= 0; t -= 1)(this.completeLayers || this.elements[t]) && this.elements[t].renderFrame() }, CVCompElement.prototype.destroy = function () { let t; for (t = this.layers.length - 1; t >= 0; t -= 1) this.elements[t] && this.elements[t].destroy(); this.layers = null, this.elements = null }, CVMaskElement.prototype.renderFrame = function () { if (this.hasMasks) { let t; let e; let r; let i; const s = this.element.finalTransform.mat; const a = this.element.canvasContext; const n = this.masksProperties.length; for (a.beginPath(), t = 0; t < n; t++) if (this.masksProperties[t].mode !== 'n') { this.masksProperties[t].inv && (a.moveTo(0, 0), a.lineTo(this.element.globalData.compSize.w, 0), a.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h), a.lineTo(0, this.element.globalData.compSize.h), a.lineTo(0, 0)), i = this.viewData[t].v, e = s.applyToPointArray(i.v[0][0], i.v[0][1], 0), a.moveTo(e[0], e[1]); var o; const h = i._length; for (o = 1; o < h; o++)r = s.applyToTriplePoints(i.o[o - 1], i.i[o], i.v[o]), a.bezierCurveTo(r[0], r[1], r[2], r[3], r[4], r[5]); r = s.applyToTriplePoints(i.o[o - 1], i.i[0], i.v[0]), a.bezierCurveTo(r[0], r[1], r[2], r[3], r[4], r[5]) } this.element.globalData.renderer.save(!0), a.clip() } }, CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty, CVMaskElement.prototype.destroy = function () { this.element = null }, extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement), CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement, CVShapeElement.prototype.transformHelper = { opacity: 1, _opMdf: !1 }, CVShapeElement.prototype.dashResetter = [], CVShapeElement.prototype.createContent = function () { this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []) }, CVShapeElement.prototype.createStyleElement = function (t, e) {
    const r = {
      data: t, type: t.ty, preTransforms: this.transformsManager.addTransformSequence(e), transforms: [], elements: [], closed: !0 === t.hd
    }; const i = {}; if (t.ty == 'fl' || t.ty == 'st' ? (i.c = PropertyFactory.getProp(this, t.c, 1, 255, this), i.c.k || (r.co = `rgb(${bm_floor(i.c.v[0])},${bm_floor(i.c.v[1])},${bm_floor(i.c.v[2])})`)) : t.ty !== 'gf' && t.ty !== 'gs' || (i.s = PropertyFactory.getProp(this, t.s, 1, null, this), i.e = PropertyFactory.getProp(this, t.e, 1, null, this), i.h = PropertyFactory.getProp(this, t.h || { k: 0 }, 0, 0.01, this), i.a = PropertyFactory.getProp(this, t.a || { k: 0 }, 0, degToRads, this), i.g = new GradientProperty(this, t.g, this)), i.o = PropertyFactory.getProp(this, t.o, 0, 0.01, this), t.ty == 'st' || t.ty == 'gs') { if (r.lc = this.lcEnum[t.lc] || 'round', r.lj = this.ljEnum[t.lj] || 'round', t.lj == 1 && (r.ml = t.ml), i.w = PropertyFactory.getProp(this, t.w, 0, null, this), i.w.k || (r.wi = i.w.v), t.d) { const s = new DashProperty(this, t.d, 'canvas', this); i.d = s, i.d.k || (r.da = i.d.dashArray, r.do = i.d.dashoffset[0]) } } else r.r = t.r === 2 ? 'evenodd' : 'nonzero'; return this.stylesList.push(r), i.style = r, i
  }, CVShapeElement.prototype.createGroupElement = function (t) { return { it: [], prevViewData: [] } }, CVShapeElement.prototype.createTransformElement = function (t) {
    return {
      transform: {
        opacity: 1, _opMdf: !1, key: this.transformsManager.getNewKey(), op: PropertyFactory.getProp(this, t.o, 0, 0.01, this), mProps: TransformPropertyFactory.getTransformProperty(this, t, this)
      }
    }
  }, CVShapeElement.prototype.createShapeElement = function (t) { const e = new CVShapeData(this, t, this.stylesList, this.transformsManager); return this.shapes.push(e), this.addShapeToModifiers(e), e }, CVShapeElement.prototype.reloadShapes = function () { this._isFirstFrame = !0; let t; let e = this.itemsData.length; for (t = 0; t < e; t += 1) this.prevViewData[t] = this.itemsData[t]; for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []), e = this.dynamicProperties.length, t = 0; t < e; t += 1) this.dynamicProperties[t].getValue(); this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame) }, CVShapeElement.prototype.addTransformToStyleList = function (t) { let e; const r = this.stylesList.length; for (e = 0; e < r; e += 1) this.stylesList[e].closed || this.stylesList[e].transforms.push(t) }, CVShapeElement.prototype.removeTransformFromStyleList = function () { let t; const e = this.stylesList.length; for (t = 0; t < e; t += 1) this.stylesList[t].closed || this.stylesList[t].transforms.pop() }, CVShapeElement.prototype.closeStyles = function (t) { let e; const r = t.length; for (e = 0; e < r; e += 1)t[e].closed = !0 }, CVShapeElement.prototype.searchShapes = function (t, e, r, i, s) { let a; let n; let o; let h; let l; let p; let m = t.length - 1; const f = []; const c = []; const d = [].concat(s); for (a = m; a >= 0; a -= 1) { if ((h = this.searchProcessedElement(t[a])) ? e[a] = r[h - 1] : t[a]._shouldRender = i, t[a].ty == 'fl' || t[a].ty == 'st' || t[a].ty == 'gf' || t[a].ty == 'gs')h ? e[a].style.closed = !1 : e[a] = this.createStyleElement(t[a], d), f.push(e[a].style); else if (t[a].ty == 'gr') { if (h) for (o = e[a].it.length, n = 0; n < o; n += 1)e[a].prevViewData[n] = e[a].it[n]; else e[a] = this.createGroupElement(t[a]); this.searchShapes(t[a].it, e[a].it, e[a].prevViewData, i, d) } else t[a].ty == 'tr' ? (h || (p = this.createTransformElement(t[a]), e[a] = p), d.push(e[a]), this.addTransformToStyleList(e[a])) : t[a].ty == 'sh' || t[a].ty == 'rc' || t[a].ty == 'el' || t[a].ty == 'sr' ? h || (e[a] = this.createShapeElement(t[a])) : t[a].ty == 'tm' || t[a].ty == 'rd' ? (h ? (l = e[a]).closed = !1 : ((l = ShapeModifiers.getModifier(t[a].ty)).init(this, t[a]), e[a] = l, this.shapeModifiers.push(l)), c.push(l)) : t[a].ty == 'rp' && (h ? (l = e[a]).closed = !0 : (l = ShapeModifiers.getModifier(t[a].ty), (e[a] = l).init(this, t, a, e), this.shapeModifiers.push(l), i = !1), c.push(l)); this.addProcessedElement(t[a], a + 1) } for (this.removeTransformFromStyleList(), this.closeStyles(f), m = c.length, a = 0; a < m; a += 1)c[a].closed = !0 }, CVShapeElement.prototype.renderInnerContent = function () { this.transformHelper.opacity = 1, this.transformHelper._opMdf = !1, this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame), this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0) }, CVShapeElement.prototype.renderShapeTransform = function (t, e) { (t._opMdf || e.op._mdf || this._isFirstFrame) && (e.opacity = t.opacity, e.opacity *= e.op.v, e._opMdf = !0) }, CVShapeElement.prototype.drawLayer = function () { let t; let e; let r; let i; let s; let a; let n; let o; let h; const l = this.stylesList.length; const p = this.globalData.renderer; const m = this.globalData.canvasContext; for (t = 0; t < l; t += 1) if (((o = (h = this.stylesList[t]).type) !== 'st' && o !== 'gs' || h.wi !== 0) && h.data._shouldRender && h.coOp !== 0 && this.globalData.currentGlobalAlpha !== 0) { for (p.save(), a = h.elements, o === 'st' || o === 'gs' ? (m.strokeStyle = o === 'st' ? h.co : h.grd, m.lineWidth = h.wi, m.lineCap = h.lc, m.lineJoin = h.lj, m.miterLimit = h.ml || 0) : m.fillStyle = o === 'fl' ? h.co : h.grd, p.ctxOpacity(h.coOp), o !== 'st' && o !== 'gs' && m.beginPath(), p.ctxTransform(h.preTransforms.finalTransform.props), r = a.length, e = 0; e < r; e += 1) { for (o !== 'st' && o !== 'gs' || (m.beginPath(), h.da && (m.setLineDash(h.da), m.lineDashOffset = h.do)), s = (n = a[e].trNodes).length, i = 0; i < s; i += 1)n[i].t == 'm' ? m.moveTo(n[i].p[0], n[i].p[1]) : n[i].t == 'c' ? m.bezierCurveTo(n[i].pts[0], n[i].pts[1], n[i].pts[2], n[i].pts[3], n[i].pts[4], n[i].pts[5]) : m.closePath(); o !== 'st' && o !== 'gs' || (m.stroke(), h.da && m.setLineDash(this.dashResetter)) }o !== 'st' && o !== 'gs' && m.fill(h.r), p.restore() } }, CVShapeElement.prototype.renderShape = function (t, e, r, i) { let s; let a; for (a = t, s = e.length - 1; s >= 0; s -= 1)e[s].ty == 'tr' ? (a = r[s].transform, this.renderShapeTransform(t, a)) : e[s].ty == 'sh' || e[s].ty == 'el' || e[s].ty == 'rc' || e[s].ty == 'sr' ? this.renderPath(e[s], r[s]) : e[s].ty == 'fl' ? this.renderFill(e[s], r[s], a) : e[s].ty == 'st' ? this.renderStroke(e[s], r[s], a) : e[s].ty == 'gf' || e[s].ty == 'gs' ? this.renderGradientFill(e[s], r[s], a) : e[s].ty == 'gr' ? this.renderShape(a, e[s].it, r[s].it) : e[s].ty; i && this.drawLayer() }, CVShapeElement.prototype.renderStyledShape = function (t, e) { if (this._isFirstFrame || e._mdf || t.transforms._mdf) { let r; let i; let s; const a = t.trNodes; const n = e.paths; const o = n._length; a.length = 0; const h = t.transforms.finalTransform; for (s = 0; s < o; s += 1) { const l = n.shapes[s]; if (l && l.v) { for (i = l._length, r = 1; r < i; r += 1)r === 1 && a.push({ t: 'm', p: h.applyToPointArray(l.v[0][0], l.v[0][1], 0) }), a.push({ t: 'c', pts: h.applyToTriplePoints(l.o[r - 1], l.i[r], l.v[r]) }); i === 1 && a.push({ t: 'm', p: h.applyToPointArray(l.v[0][0], l.v[0][1], 0) }), l.c && i && (a.push({ t: 'c', pts: h.applyToTriplePoints(l.o[r - 1], l.i[0], l.v[0]) }), a.push({ t: 'z' })) } }t.trNodes = a } }, CVShapeElement.prototype.renderPath = function (t, e) { if (!0 !== t.hd && t._shouldRender) { let r; const i = e.styledShapes.length; for (r = 0; r < i; r += 1) this.renderStyledShape(e.styledShapes[r], e.sh) } }, CVShapeElement.prototype.renderFill = function (t, e, r) { const i = e.style; (e.c._mdf || this._isFirstFrame) && (i.co = `rgb(${bm_floor(e.c.v[0])},${bm_floor(e.c.v[1])},${bm_floor(e.c.v[2])})`), (e.o._mdf || r._opMdf || this._isFirstFrame) && (i.coOp = e.o.v * r.opacity) }, CVShapeElement.prototype.renderGradientFill = function (t, e, r) { const i = e.style; if (!i.grd || e.g._mdf || e.s._mdf || e.e._mdf || t.t !== 1 && (e.h._mdf || e.a._mdf)) { const s = this.globalData.canvasContext; const a = e.s.v; const n = e.e.v; if (t.t === 1)f = s.createLinearGradient(a[0], a[1], n[0], n[1]); else var o = Math.sqrt(Math.pow(a[0] - n[0], 2) + Math.pow(a[1] - n[1], 2)); const h = Math.atan2(n[1] - a[1], n[0] - a[0]); const l = o * (e.h.v >= 1 ? 0.99 : e.h.v <= -1 ? -0.99 : e.h.v); const p = Math.cos(h + e.a.v) * l + a[0]; const m = Math.sin(h + e.a.v) * l + a[1]; var f = s.createRadialGradient(p, m, 0, a[0], a[1], o); let c; const d = t.g.p; const u = e.g.c; let y = 1; for (c = 0; c < d; c += 1)e.g._hasOpacity && e.g._collapsable && (y = e.g.o[2 * c + 1]), f.addColorStop(u[4 * c] / 100, `rgba(${u[4 * c + 1]},${u[4 * c + 2]},${u[4 * c + 3]},${y})`); i.grd = f }i.coOp = e.o.v * r.opacity }, CVShapeElement.prototype.renderStroke = function (t, e, r) { const i = e.style; const s = e.d; s && (s._mdf || this._isFirstFrame) && (i.da = s.dashArray, i.do = s.dashoffset[0]), (e.c._mdf || this._isFirstFrame) && (i.co = `rgb(${bm_floor(e.c.v[0])},${bm_floor(e.c.v[1])},${bm_floor(e.c.v[2])})`), (e.o._mdf || r._opMdf || this._isFirstFrame) && (i.coOp = e.o.v * r.opacity), (e.w._mdf || this._isFirstFrame) && (i.wi = e.w.v) }, CVShapeElement.prototype.destroy = function () { this.shapesData = null, this.globalData = null, this.canvasContext = null, this.stylesList.length = 0, this.itemsData.length = 0 }, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement), CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVSolidElement.prototype.renderInnerContent = function () { const t = this.canvasContext; t.fillStyle = this.data.sc, t.fillRect(0, 0, this.data.sw, this.data.sh) }, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement), CVTextElement.prototype.tHelper = createTag('canvas').getContext('2d'), CVTextElement.prototype.buildNewText = function () { const t = this.textProperty.currentData; this.renderedLetters = createSizedArray(t.l ? t.l.length : 0); let e = !1; t.fc ? (e = !0, this.values.fill = this.buildColor(t.fc)) : this.values.fill = 'rgba(0,0,0,0)', this.fill = e; let r = !1; t.sc && (r = !0, this.values.stroke = this.buildColor(t.sc), this.values.sWidth = t.sw); let i; let s; const a = this.globalData.fontManager.getFontByName(t.f); const n = t.l; const o = this.mHelper; this.stroke = r, this.values.fValue = `${t.finalSize}px ${this.globalData.fontManager.getFontByName(t.f).fFamily}`, s = t.finalText.length; let h; let l; let p; let m; let f; let c; let d; let u; let y; let g; const v = this.data.singleShape; const b = t.tr / 1e3 * t.finalSize; let E = 0; let x = 0; let S = !0; let P = 0; for (i = 0; i < s; i += 1) { for (l = (h = this.globalData.fontManager.getCharData(t.finalText[i], a.fStyle, this.globalData.fontManager.getFontByName(t.f).fFamily)) && h.data || {}, o.reset(), v && n[i].n && (E = -b, x += t.yOffset, x += S ? 1 : 0, S = !1), d = (f = l.shapes ? l.shapes[0].it : []).length, o.scale(t.finalSize / 100, t.finalSize / 100), v && this.applyTextPropertiesToMatrix(t, o, n[i].line, E, x), y = createSizedArray(d), c = 0; c < d; c += 1) { for (m = f[c].ks.k.i.length, u = f[c].ks.k, g = [], p = 1; p < m; p += 1)p == 1 && g.push(o.applyToX(u.v[0][0], u.v[0][1], 0), o.applyToY(u.v[0][0], u.v[0][1], 0)), g.push(o.applyToX(u.o[p - 1][0], u.o[p - 1][1], 0), o.applyToY(u.o[p - 1][0], u.o[p - 1][1], 0), o.applyToX(u.i[p][0], u.i[p][1], 0), o.applyToY(u.i[p][0], u.i[p][1], 0), o.applyToX(u.v[p][0], u.v[p][1], 0), o.applyToY(u.v[p][0], u.v[p][1], 0)); g.push(o.applyToX(u.o[p - 1][0], u.o[p - 1][1], 0), o.applyToY(u.o[p - 1][0], u.o[p - 1][1], 0), o.applyToX(u.i[0][0], u.i[0][1], 0), o.applyToY(u.i[0][0], u.i[0][1], 0), o.applyToX(u.v[0][0], u.v[0][1], 0), o.applyToY(u.v[0][0], u.v[0][1], 0)), y[c] = g }v && (E += n[i].l, E += b), this.textSpans[P] ? this.textSpans[P].elem = y : this.textSpans[P] = { elem: y }, P += 1 } }, CVTextElement.prototype.renderInnerContent = function () { let t; let e; let r; let i; let s; let a; const n = this.canvasContext; this.finalTransform.mat.props; n.font = this.values.fValue, n.lineCap = 'butt', n.lineJoin = 'miter', n.miterLimit = 4, this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag); let o; const h = this.textAnimator.renderedLetters; const { l } = this.textProperty.currentData; e = l.length; let p; let m; let f = null; let c = null; let d = null; for (t = 0; t < e; t += 1) if (!l[t].n) { if ((o = h[t]) && (this.globalData.renderer.save(), this.globalData.renderer.ctxTransform(o.p), this.globalData.renderer.ctxOpacity(o.o)), this.fill) { for (o && o.fc ? f !== o.fc && (f = o.fc, n.fillStyle = o.fc) : f !== this.values.fill && (f = this.values.fill, n.fillStyle = this.values.fill), i = (p = this.textSpans[t].elem).length, this.globalData.canvasContext.beginPath(), r = 0; r < i; r += 1) for (a = (m = p[r]).length, this.globalData.canvasContext.moveTo(m[0], m[1]), s = 2; s < a; s += 6) this.globalData.canvasContext.bezierCurveTo(m[s], m[s + 1], m[s + 2], m[s + 3], m[s + 4], m[s + 5]); this.globalData.canvasContext.closePath(), this.globalData.canvasContext.fill() } if (this.stroke) { for (o && o.sw ? d !== o.sw && (d = o.sw, n.lineWidth = o.sw) : d !== this.values.sWidth && (d = this.values.sWidth, n.lineWidth = this.values.sWidth), o && o.sc ? c !== o.sc && (c = o.sc, n.strokeStyle = o.sc) : c !== this.values.stroke && (c = this.values.stroke, n.strokeStyle = this.values.stroke), i = (p = this.textSpans[t].elem).length, this.globalData.canvasContext.beginPath(), r = 0; r < i; r += 1) for (a = (m = p[r]).length, this.globalData.canvasContext.moveTo(m[0], m[1]), s = 2; s < a; s += 6) this.globalData.canvasContext.bezierCurveTo(m[s], m[s + 1], m[s + 2], m[s + 3], m[s + 4], m[s + 5]); this.globalData.canvasContext.closePath(), this.globalData.canvasContext.stroke() }o && this.globalData.renderer.restore() } }, CVEffects.prototype.renderFrame = function () {}, HBaseElement.prototype = {
    checkBlendMode() {}, initRendererElement() { this.baseElement = createTag(this.data.tg || 'div'), this.data.hasMask ? (this.svgElement = createNS('svg'), this.layerElement = createNS('g'), this.maskedElement = this.layerElement, this.svgElement.appendChild(this.layerElement), this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement, styleDiv(this.baseElement) }, createContainerElements() { this.renderableEffectsManager = new CVEffects(this), this.transformedElement = this.baseElement, this.maskedElement = this.layerElement, this.data.ln && this.layerElement.setAttribute('id', this.data.ln), this.data.cl && this.layerElement.setAttribute('class', this.data.cl), this.data.bm !== 0 && this.setBlendMode() }, renderElement() { this.finalTransform._matMdf && (this.transformedElement.style.transform = this.transformedElement.style.webkitTransform = this.finalTransform.mat.toCSS()), this.finalTransform._opMdf && (this.transformedElement.style.opacity = this.finalTransform.mProp.o.v) }, renderFrame() { this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1)) }, destroy() { this.layerElement = null, this.transformedElement = null, this.matteElement && (this.matteElement = null), this.maskManager && (this.maskManager.destroy(), this.maskManager = null) }, createRenderableComponents() { this.maskManager = new MaskElement(this.data, this, this.globalData) }, addEffects() {}, setMatte() {}
  }, HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement, HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy, HBaseElement.prototype.buildElementParenting = HybridRenderer.prototype.buildElementParenting, extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement), HSolidElement.prototype.createContent = function () { let t; this.data.hasMask ? ((t = createNS('rect')).setAttribute('width', this.data.sw), t.setAttribute('height', this.data.sh), t.setAttribute('fill', this.data.sc), this.svgElement.setAttribute('width', this.data.sw), this.svgElement.setAttribute('height', this.data.sh)) : ((t = createTag('div')).style.width = `${this.data.sw}px`, t.style.height = `${this.data.sh}px`, t.style.backgroundColor = this.data.sc), this.layerElement.appendChild(t) }, extendPrototype([HybridRenderer, ICompElement, HBaseElement], HCompElement), HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements, HCompElement.prototype.createContainerElements = function () { this._createBaseContainerElements(), this.data.hasMask ? (this.svgElement.setAttribute('width', this.data.w), this.svgElement.setAttribute('height', this.data.h), this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement }, HCompElement.prototype.addTo3dContainer = function (t, e) { for (var r, i = 0; i < e;) this.elements[i] && this.elements[i].getBaseElement && (r = this.elements[i].getBaseElement()), i += 1; r ? this.layerElement.insertBefore(t, r) : this.layerElement.appendChild(t) }, extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement), HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent, HShapeElement.prototype.createContent = function () { let t; if (this.baseElement.style.fontSize = 0, this.data.hasMask) this.layerElement.appendChild(this.shapesContainer), t = this.svgElement; else { t = createNS('svg'); const e = this.comp.data ? this.comp.data : this.globalData.compSize; t.setAttribute('width', e.w), t.setAttribute('height', e.h), t.appendChild(this.shapesContainer), this.layerElement.appendChild(t) } this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0), this.filterUniqueShapes(), this.shapeCont = t }, HShapeElement.prototype.getTransformedPoint = function (t, e) { let r; const i = t.length; for (r = 0; r < i; r += 1)e = t[r].mProps.v.applyToPointArray(e[0], e[1], 0); return e }, HShapeElement.prototype.calculateShapeBoundingBox = function (t, e) { let r; let i; let s; let a; let n; const o = t.sh.v; const h = t.transformers; const l = o._length; if (!(l <= 1)) { for (r = 0; r < l - 1; r += 1)i = this.getTransformedPoint(h, o.v[r]), s = this.getTransformedPoint(h, o.o[r]), a = this.getTransformedPoint(h, o.i[r + 1]), n = this.getTransformedPoint(h, o.v[r + 1]), this.checkBounds(i, s, a, n, e); o.c && (i = this.getTransformedPoint(h, o.v[r]), s = this.getTransformedPoint(h, o.o[r]), a = this.getTransformedPoint(h, o.i[0]), n = this.getTransformedPoint(h, o.v[0]), this.checkBounds(i, s, a, n, e)) } }, HShapeElement.prototype.checkBounds = function (t, e, r, i, s) { this.getBoundsOfCurve(t, e, r, i); const a = this.shapeBoundingBox; s.x = bm_min(a.left, s.x), s.xMax = bm_max(a.right, s.xMax), s.y = bm_min(a.top, s.y), s.yMax = bm_max(a.bottom, s.yMax) }, HShapeElement.prototype.shapeBoundingBox = {
    left: 0, right: 0, top: 0, bottom: 0
  }, HShapeElement.prototype.tempBoundingBox = {
    x: 0, xMax: 0, y: 0, yMax: 0, width: 0, height: 0
  }, HShapeElement.prototype.getBoundsOfCurve = function (t, e, r, i) { for (var s, a, n, o, h, l, p, m = [[t[0], i[0]], [t[1], i[1]]], f = 0; f < 2; ++f) if (a = 6 * t[f] - 12 * e[f] + 6 * r[f], s = -3 * t[f] + 9 * e[f] - 9 * r[f] + 3 * i[f], n = 3 * e[f] - 3 * t[f], a |= 0, n |= 0, (s |= 0) !== 0)(h = a * a - 4 * n * s) < 0 || ((l = (-a + bm_sqrt(h)) / (2 * s)) > 0 && l < 1 && m[f].push(this.calculateF(l, t, e, r, i, f)), (p = (-a - bm_sqrt(h)) / (2 * s)) > 0 && p < 1 && m[f].push(this.calculateF(p, t, e, r, i, f))); else { if (a === 0) continue; (o = -n / a) > 0 && o < 1 && m[f].push(this.calculateF(o, t, e, r, i, f)) } this.shapeBoundingBox.left = bm_min.apply(null, m[0]), this.shapeBoundingBox.top = bm_min.apply(null, m[1]), this.shapeBoundingBox.right = bm_max.apply(null, m[0]), this.shapeBoundingBox.bottom = bm_max.apply(null, m[1]) }, HShapeElement.prototype.calculateF = function (t, e, r, i, s, a) { return bm_pow(1 - t, 3) * e[a] + 3 * bm_pow(1 - t, 2) * t * r[a] + 3 * (1 - t) * bm_pow(t, 2) * i[a] + bm_pow(t, 3) * s[a] }, HShapeElement.prototype.calculateBoundingBox = function (t, e) { let r; const i = t.length; for (r = 0; r < i; r += 1)t[r] && t[r].sh ? this.calculateShapeBoundingBox(t[r], e) : t[r] && t[r].it && this.calculateBoundingBox(t[r].it, e) }, HShapeElement.prototype.currentBoxContains = function (t) { return this.currentBBox.x <= t.x && this.currentBBox.y <= t.y && this.currentBBox.width + this.currentBBox.x >= t.x + t.width && this.currentBBox.height + this.currentBBox.y >= t.y + t.height }, HShapeElement.prototype.renderInnerContent = function () { if (this._renderShapeFrame(), !this.hidden && (this._isFirstFrame || this._mdf)) { const t = this.tempBoundingBox; const e = 999999; if (t.x = e, t.xMax = -e, t.y = e, t.yMax = -e, this.calculateBoundingBox(this.itemsData, t), t.width = t.xMax < t.x ? 0 : t.xMax - t.x, t.height = t.yMax < t.y ? 0 : t.yMax - t.y, this.currentBoxContains(t)) return; let r = !1; this.currentBBox.w !== t.width && (this.currentBBox.w = t.width, this.shapeCont.setAttribute('width', t.width), r = !0), this.currentBBox.h !== t.height && (this.currentBBox.h = t.height, this.shapeCont.setAttribute('height', t.height), r = !0), (r || this.currentBBox.x !== t.x || this.currentBBox.y !== t.y) && (this.currentBBox.w = t.width, this.currentBBox.h = t.height, this.currentBBox.x = t.x, this.currentBBox.y = t.y, this.shapeCont.setAttribute('viewBox', `${this.currentBBox.x} ${this.currentBBox.y} ${this.currentBBox.w} ${this.currentBBox.h}`), this.shapeCont.style.transform = this.shapeCont.style.webkitTransform = `translate(${this.currentBBox.x}px,${this.currentBBox.y}px)`) } }, extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement), HTextElement.prototype.createContent = function () { if (this.isMasked = this.checkMasks(), this.isMasked) { this.renderType = 'svg', this.compW = this.comp.data.w, this.compH = this.comp.data.h, this.svgElement.setAttribute('width', this.compW), this.svgElement.setAttribute('height', this.compH); const t = createNS('g'); this.maskedElement.appendChild(t), this.innerElem = t } else this.renderType = 'html', this.innerElem = this.layerElement; this.checkParenting() }, HTextElement.prototype.buildNewText = function () { const t = this.textProperty.currentData; this.renderedLetters = createSizedArray(t.l ? t.l.length : 0); const e = this.innerElem.style; e.color = e.fill = t.fc ? this.buildColor(t.fc) : 'rgba(0,0,0,0)', t.sc && (e.stroke = this.buildColor(t.sc), e.strokeWidth = `${t.sw}px`); let r; let i; const s = this.globalData.fontManager.getFontByName(t.f); if (!this.globalData.fontManager.chars) if (e.fontSize = `${t.finalSize}px`, e.lineHeight = `${t.finalSize}px`, s.fClass) this.innerElem.className = s.fClass; else { e.fontFamily = s.fFamily; const a = t.fWeight; const n = t.fStyle; e.fontStyle = n, e.fontWeight = a } let o; let h; let l; const p = t.l; i = p.length; let m; const f = this.mHelper; let c = ''; let d = 0; for (r = 0; r < i; r += 1) { if (this.globalData.fontManager.chars ? (this.textPaths[d] ? o = this.textPaths[d] : ((o = createNS('path')).setAttribute('stroke-linecap', 'butt'), o.setAttribute('stroke-linejoin', 'round'), o.setAttribute('stroke-miterlimit', '4')), this.isMasked || (this.textSpans[d] ? l = (h = this.textSpans[d]).children[0] : ((h = createTag('div')).style.lineHeight = 0, (l = createNS('svg')).appendChild(o), styleDiv(h)))) : this.isMasked ? o = this.textPaths[d] ? this.textPaths[d] : createNS('text') : this.textSpans[d] ? (h = this.textSpans[d], o = this.textPaths[d]) : (styleDiv(h = createTag('span')), styleDiv(o = createTag('span')), h.appendChild(o)), this.globalData.fontManager.chars) { var u; const y = this.globalData.fontManager.getCharData(t.finalText[r], s.fStyle, this.globalData.fontManager.getFontByName(t.f).fFamily); if (u = y ? y.data : null, f.reset(), u && u.shapes && (m = u.shapes[0].it, f.scale(t.finalSize / 100, t.finalSize / 100), c = this.createPathShape(f, m), o.setAttribute('d', c)), this.isMasked) this.innerElem.appendChild(o); else { if (this.innerElem.appendChild(h), u && u.shapes) { document.body.appendChild(l); const g = l.getBBox(); l.setAttribute('width', g.width + 2), l.setAttribute('height', g.height + 2), l.setAttribute('viewBox', `${g.x - 1} ${g.y - 1} ${g.width + 2} ${g.height + 2}`), l.style.transform = l.style.webkitTransform = `translate(${g.x - 1}px,${g.y - 1}px)`, p[r].yOffset = g.y - 1 } else l.setAttribute('width', 1), l.setAttribute('height', 1); h.appendChild(l) } } else o.textContent = p[r].val, o.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve'), this.isMasked ? this.innerElem.appendChild(o) : (this.innerElem.appendChild(h), o.style.transform = o.style.webkitTransform = `translate3d(0,${-t.finalSize / 1.2}px,0)`); this.isMasked ? this.textSpans[d] = o : this.textSpans[d] = h, this.textSpans[d].style.display = 'block', this.textPaths[d] = o, d += 1 } for (;d < this.textSpans.length;) this.textSpans[d].style.display = 'none', d += 1 }, HTextElement.prototype.renderInnerContent = function () { if (this.data.singleShape) { if (!this._isFirstFrame && !this.lettersChangedFlag) return; this.isMasked && this.finalTransform._matMdf && (this.svgElement.setAttribute('viewBox', `${-this.finalTransform.mProp.p.v[0]} ${-this.finalTransform.mProp.p.v[1]} ${this.compW} ${this.compH}`), this.svgElement.style.transform = this.svgElement.style.webkitTransform = `translate(${-this.finalTransform.mProp.p.v[0]}px,${-this.finalTransform.mProp.p.v[1]}px)`) } if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) { let t; let e; let r; let i; let s; let a = 0; const n = this.textAnimator.renderedLetters; const o = this.textProperty.currentData.l; for (e = o.length, t = 0; t < e; t += 1)o[t].n ? a += 1 : (i = this.textSpans[t], s = this.textPaths[t], r = n[a], a += 1, r._mdf.m && (this.isMasked ? i.setAttribute('transform', r.m) : i.style.transform = i.style.webkitTransform = r.m), i.style.opacity = r.o, r.sw && r._mdf.sw && s.setAttribute('stroke-width', r.sw), r.sc && r._mdf.sc && s.setAttribute('stroke', r.sc), r.fc && r._mdf.fc && (s.setAttribute('fill', r.fc), s.style.color = r.fc)); if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) { const h = this.innerElem.getBBox(); this.currentBBox.w !== h.width && (this.currentBBox.w = h.width, this.svgElement.setAttribute('width', h.width)), this.currentBBox.h !== h.height && (this.currentBBox.h = h.height, this.svgElement.setAttribute('height', h.height)); this.currentBBox.w === h.width + 2 && this.currentBBox.h === h.height + 2 && this.currentBBox.x === h.x - 1 && this.currentBBox.y === h.y - 1 || (this.currentBBox.w = h.width + 2, this.currentBBox.h = h.height + 2, this.currentBBox.x = h.x - 1, this.currentBBox.y = h.y - 1, this.svgElement.setAttribute('viewBox', `${this.currentBBox.x} ${this.currentBBox.y} ${this.currentBBox.w} ${this.currentBBox.h}`), this.svgElement.style.transform = this.svgElement.style.webkitTransform = `translate(${this.currentBBox.x}px,${this.currentBBox.y}px)`) } } }, extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement), HImageElement.prototype.createContent = function () { const t = this.globalData.getAssetsPath(this.assetData); const e = new Image(); this.data.hasMask ? (this.imageElem = createNS('image'), this.imageElem.setAttribute('width', `${this.assetData.w}px`), this.imageElem.setAttribute('height', `${this.assetData.h}px`), this.imageElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', t), this.layerElement.appendChild(this.imageElem), this.baseElement.setAttribute('width', this.assetData.w), this.baseElement.setAttribute('height', this.assetData.h)) : this.layerElement.appendChild(e), e.src = t, this.data.ln && this.baseElement.setAttribute('id', this.data.ln) }, extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement), HCameraElement.prototype.setup = function () { let t; let e; const r = this.comp.threeDElements.length; for (t = 0; t < r; t += 1)(e = this.comp.threeDElements[t]).type === '3d' && (e.perspectiveElem.style.perspective = e.perspectiveElem.style.webkitPerspective = `${this.pe.v}px`, e.container.style.transformOrigin = e.container.style.mozTransformOrigin = e.container.style.webkitTransformOrigin = '0px 0px 0px', e.perspectiveElem.style.transform = e.perspectiveElem.style.webkitTransform = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)') }, HCameraElement.prototype.createElements = function () {}, HCameraElement.prototype.hide = function () {}, HCameraElement.prototype.renderFrame = function () { let t; let e; let r = this._isFirstFrame; if (this.hierarchy) for (e = this.hierarchy.length, t = 0; t < e; t += 1)r = this.hierarchy[t].finalTransform.mProp._mdf || r; if (r || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) { if (this.mat.reset(), this.hierarchy) for (t = e = this.hierarchy.length - 1; t >= 0; t -= 1) { const i = this.hierarchy[t].finalTransform.mProp; this.mat.translate(-i.p.v[0], -i.p.v[1], i.p.v[2]), this.mat.rotateX(-i.or.v[0]).rotateY(-i.or.v[1]).rotateZ(i.or.v[2]), this.mat.rotateX(-i.rx.v).rotateY(-i.ry.v).rotateZ(i.rz.v), this.mat.scale(1 / i.s.v[0], 1 / i.s.v[1], 1 / i.s.v[2]), this.mat.translate(i.a.v[0], i.a.v[1], i.a.v[2]) } if (this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v), this.a) { let s; s = this.p ? [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]]; const a = Math.sqrt(Math.pow(s[0], 2) + Math.pow(s[1], 2) + Math.pow(s[2], 2)); const n = [s[0] / a, s[1] / a, s[2] / a]; const o = Math.sqrt(n[2] * n[2] + n[0] * n[0]); const h = Math.atan2(n[1], o); const l = Math.atan2(n[0], -n[2]); this.mat.rotateY(l).rotateX(-h) } this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v), this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]), this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0), this.mat.translate(0, 0, this.pe.v); const p = !this._prevMat.equals(this.mat); if ((p || this.pe._mdf) && this.comp.threeDElements) { let m; for (e = this.comp.threeDElements.length, t = 0; t < e; t += 1)(m = this.comp.threeDElements[t]).type === '3d' && (p && (m.container.style.transform = m.container.style.webkitTransform = this.mat.toCSS()), this.pe._mdf && (m.perspectiveElem.style.perspective = m.perspectiveElem.style.webkitPerspective = `${this.pe.v}px`)); this.mat.clone(this._prevMat) } } this._isFirstFrame = !1 }, HCameraElement.prototype.prepareFrame = function (t) { this.prepareProperties(t, !0) }, HCameraElement.prototype.destroy = function () {}, HCameraElement.prototype.getBaseElement = function () { return null }, HEffects.prototype.renderFrame = function () {}; const animationManager = (function () { const t = {}; const s = []; let i = 0; let a = 0; let n = 0; let o = !0; let h = !1; function r(t) { for (let e = 0, r = t.target; e < a;)s[e].animation === r && (s.splice(e, 1), e -= 1, a -= 1, r.isPaused || m()), e += 1 } function l(t, e) { if (!t) return null; for (let r = 0; r < a;) { if (s[r].elem == t && s[r].elem !== null) return s[r].animation; r += 1 } const i = new AnimationItem(); return f(i, t), i.setData(t, e), i } function p() { n += 1, d() } function m() { n -= 1 } function f(t, e) { t.addEventListener('destroy', r), t.addEventListener('_active', p), t.addEventListener('_idle', m), s.push({ elem: e, animation: t }), a += 1 } function c(t) { let e; const r = t - i; for (e = 0; e < a; e += 1)s[e].animation.advanceTime(r); i = t, n && !h ? window.requestAnimationFrame(c) : o = !0 } function e(t) { i = t, window.requestAnimationFrame(c) } function d() { !h && n && o && (window.requestAnimationFrame(e), o = !1) } return t.registerAnimation = l, t.loadAnimation = function (t) { const e = new AnimationItem(); return f(e, null), e.setParams(t), e }, t.setSpeed = function (t, e) { let r; for (r = 0; r < a; r += 1)s[r].animation.setSpeed(t, e) }, t.setDirection = function (t, e) { let r; for (r = 0; r < a; r += 1)s[r].animation.setDirection(t, e) }, t.play = function (t) { let e; for (e = 0; e < a; e += 1)s[e].animation.play(t) }, t.pause = function (t) { let e; for (e = 0; e < a; e += 1)s[e].animation.pause(t) }, t.stop = function (t) { let e; for (e = 0; e < a; e += 1)s[e].animation.stop(t) }, t.togglePause = function (t) { let e; for (e = 0; e < a; e += 1)s[e].animation.togglePause(t) }, t.searchAnimations = function (t, e, r) { let i; const s = [].concat([].slice.call(document.getElementsByClassName('lottie')), [].slice.call(document.getElementsByClassName('bodymovin'))); const a = s.length; for (i = 0; i < a; i += 1)r && s[i].setAttribute('data-bm-type', r), l(s[i], t); if (e && a === 0) { r || (r = 'svg'); const n = document.getElementsByTagName('body')[0]; n.innerHTML = ''; const o = createTag('div'); o.style.width = '100%', o.style.height = '100%', o.setAttribute('data-bm-type', r), n.appendChild(o), l(o, t) } }, t.resize = function () { let t; for (t = 0; t < a; t += 1)s[t].animation.resize() }, t.goToAndStop = function (t, e, r) { let i; for (i = 0; i < a; i += 1)s[i].animation.goToAndStop(t, e, r) }, t.destroy = function (t) { let e; for (e = a - 1; e >= 0; e -= 1)s[e].animation.destroy(t) }, t.freeze = function () { h = !0 }, t.unfreeze = function () { h = !1, d() }, t.getRegisteredAnimations = function () { let t; const e = s.length; const r = []; for (t = 0; t < e; t += 1)r.push(s[t].animation); return r }, t }()); var AnimationItem = function () { this._cbs = [], this.name = '', this.path = '', this.isLoaded = !1, this.currentFrame = 0, this.currentRawFrame = 0, this.firstFrame = 0, this.totalFrames = 0, this.frameRate = 0, this.frameMult = 0, this.playSpeed = 1, this.playDirection = 1, this.playCount = 0, this.animationData = {}, this.assets = [], this.isPaused = !0, this.autoplay = !1, this.loop = !0, this.renderer = null, this.animationID = createElementID(), this.assetsPath = '', this.timeCompleted = 0, this.segmentPos = 0, this.subframeEnabled = subframeEnabled, this.segments = [], this._idle = !0, this._completedLoop = !1, this.projectInterface = ProjectInterface(), this.imagePreloader = new ImagePreloader() }; extendPrototype([BaseEvent], AnimationItem), AnimationItem.prototype.setParams = function (t) { t.context && (this.context = t.context), (t.wrapper || t.container) && (this.wrapper = t.wrapper || t.container); const e = t.animType ? t.animType : t.renderer ? t.renderer : 'svg'; switch (e) { case 'canvas': this.renderer = new CanvasRenderer(this, t.rendererSettings); break; case 'svg': this.renderer = new SVGRenderer(this, t.rendererSettings); break; default: this.renderer = new HybridRenderer(this, t.rendererSettings) } this.renderer.setProjectInterface(this.projectInterface), this.animType = e, t.loop === '' || t.loop === null || (!1 === t.loop ? this.loop = !1 : !0 === t.loop ? this.loop = !0 : this.loop = parseInt(t.loop)), this.autoplay = !('autoplay' in t) || t.autoplay, this.name = t.name ? t.name : '', this.autoloadSegments = !t.hasOwnProperty('autoloadSegments') || t.autoloadSegments, this.assetsPath = t.assetsPath, t.animationData ? this.configAnimation(t.animationData) : t.path && (t.path.lastIndexOf('\\') !== -1 ? this.path = t.path.substr(0, t.path.lastIndexOf('\\') + 1) : this.path = t.path.substr(0, t.path.lastIndexOf('/') + 1), this.fileName = t.path.substr(t.path.lastIndexOf('/') + 1), this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf('.json')), assetLoader.load(t.path, this.configAnimation.bind(this), () => { this.trigger('data_failed') })), this.initialSegment = t.initialSegment }, AnimationItem.prototype.setData = function (t, e) { const r = { wrapper: t, animationData: e ? typeof e === 'object' ? e : JSON.parse(e) : null }; const i = t.attributes; r.path = i.getNamedItem('data-animation-path') ? i.getNamedItem('data-animation-path').value : i.getNamedItem('data-bm-path') ? i.getNamedItem('data-bm-path').value : i.getNamedItem('bm-path') ? i.getNamedItem('bm-path').value : '', r.animType = i.getNamedItem('data-anim-type') ? i.getNamedItem('data-anim-type').value : i.getNamedItem('data-bm-type') ? i.getNamedItem('data-bm-type').value : i.getNamedItem('bm-type') ? i.getNamedItem('bm-type').value : i.getNamedItem('data-bm-renderer') ? i.getNamedItem('data-bm-renderer').value : i.getNamedItem('bm-renderer') ? i.getNamedItem('bm-renderer').value : 'canvas'; const s = i.getNamedItem('data-anim-loop') ? i.getNamedItem('data-anim-loop').value : i.getNamedItem('data-bm-loop') ? i.getNamedItem('data-bm-loop').value : i.getNamedItem('bm-loop') ? i.getNamedItem('bm-loop').value : ''; s === '' || (r.loop = s !== 'false' && (s === 'true' || parseInt(s))); const a = i.getNamedItem('data-anim-autoplay') ? i.getNamedItem('data-anim-autoplay').value : i.getNamedItem('data-bm-autoplay') ? i.getNamedItem('data-bm-autoplay').value : !i.getNamedItem('bm-autoplay') || i.getNamedItem('bm-autoplay').value; r.autoplay = a !== 'false', r.name = i.getNamedItem('data-name') ? i.getNamedItem('data-name').value : i.getNamedItem('data-bm-name') ? i.getNamedItem('data-bm-name').value : i.getNamedItem('bm-name') ? i.getNamedItem('bm-name').value : '', (i.getNamedItem('data-anim-prerender') ? i.getNamedItem('data-anim-prerender').value : i.getNamedItem('data-bm-prerender') ? i.getNamedItem('data-bm-prerender').value : i.getNamedItem('bm-prerender') ? i.getNamedItem('bm-prerender').value : '') === 'false' && (r.prerender = !1), this.setParams(r) }, AnimationItem.prototype.includeLayers = function (t) { t.op > this.animationData.op && (this.animationData.op = t.op, this.totalFrames = Math.floor(t.op - this.animationData.ip)); let e; let r; const i = this.animationData.layers; let s = i.length; const a = t.layers; const n = a.length; for (r = 0; r < n; r += 1) for (e = 0; e < s;) { if (i[e].id == a[r].id) { i[e] = a[r]; break }e += 1 } if ((t.chars || t.fonts) && (this.renderer.globalData.fontManager.addChars(t.chars), this.renderer.globalData.fontManager.addFonts(t.fonts, this.renderer.globalData.defs)), t.assets) for (s = t.assets.length, e = 0; e < s; e += 1) this.animationData.assets.push(t.assets[e]); this.animationData.__complete = !1, dataManager.completeData(this.animationData, this.renderer.globalData.fontManager), this.renderer.includeLayers(t.layers), expressionsPlugin && expressionsPlugin.initExpressions(this), this.loadNextSegment() }, AnimationItem.prototype.loadNextSegment = function () { const t = this.animationData.segments; if (!t || t.length === 0 || !this.autoloadSegments) return this.trigger('data_ready'), void (this.timeCompleted = this.totalFrames); const e = t.shift(); this.timeCompleted = e.time * this.frameRate; const r = `${this.path + this.fileName}_${this.segmentPos}.json`; this.segmentPos += 1, assetLoader.load(r, this.includeLayers.bind(this), () => { this.trigger('data_failed') }) }, AnimationItem.prototype.loadSegments = function () { this.animationData.segments || (this.timeCompleted = this.totalFrames), this.loadNextSegment() }, AnimationItem.prototype.imagesLoaded = function () { this.trigger('loaded_images'), this.checkLoaded() }, AnimationItem.prototype.preloadImages = function () { this.imagePreloader.setAssetsPath(this.assetsPath), this.imagePreloader.setPath(this.path), this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this)) }, AnimationItem.prototype.configAnimation = function (t) { if (this.renderer) try { this.animationData = t, this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]), this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip), this.firstFrame = Math.round(this.animationData.ip)), this.renderer.configAnimation(t), t.assets || (t.assets = []), this.assets = this.animationData.assets, this.frameRate = this.animationData.fr, this.frameMult = this.animationData.fr / 1e3, this.renderer.searchExtraCompositions(t.assets), this.trigger('config_ready'), this.preloadImages(), this.loadSegments(), this.updaFrameModifier(), this.waitForFontsLoaded() } catch (t) { this.triggerConfigError(t) } }, AnimationItem.prototype.waitForFontsLoaded = function () { this.renderer && (this.renderer.globalData.fontManager.loaded() ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20)) }, AnimationItem.prototype.checkLoaded = function () { this.isLoaded || !this.renderer.globalData.fontManager.loaded() || !this.imagePreloader.loaded() && this.renderer.rendererType === 'canvas' || (this.isLoaded = !0, dataManager.completeData(this.animationData, this.renderer.globalData.fontManager), expressionsPlugin && expressionsPlugin.initExpressions(this), this.renderer.initItems(), setTimeout(() => { this.trigger('DOMLoaded') }, 0), this.gotoFrame(), this.autoplay && this.play()) }, AnimationItem.prototype.resize = function () { this.renderer.updateContainerSize() }, AnimationItem.prototype.setSubframe = function (t) { this.subframeEnabled = !!t }, AnimationItem.prototype.gotoFrame = function () { this.currentFrame = this.subframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame, this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted), this.trigger('enterFrame'), this.renderFrame() }, AnimationItem.prototype.renderFrame = function () { if (!1 !== this.isLoaded) try { this.renderer.renderFrame(this.currentFrame + this.firstFrame) } catch (t) { this.triggerRenderFrameError(t) } }, AnimationItem.prototype.play = function (t) { t && this.name != t || !0 === this.isPaused && (this.isPaused = !1, this._idle && (this._idle = !1, this.trigger('_active'))) }, AnimationItem.prototype.pause = function (t) { t && this.name != t || !1 === this.isPaused && (this.isPaused = !0, this._idle = !0, this.trigger('_idle')) }, AnimationItem.prototype.togglePause = function (t) { t && this.name != t || (!0 === this.isPaused ? this.play() : this.pause()) }, AnimationItem.prototype.stop = function (t) { t && this.name != t || (this.pause(), this.playCount = 0, this._completedLoop = !1, this.setCurrentRawFrameValue(0)) }, AnimationItem.prototype.goToAndStop = function (t, e, r) { r && this.name != r || (e ? this.setCurrentRawFrameValue(t) : this.setCurrentRawFrameValue(t * this.frameModifier), this.pause()) }, AnimationItem.prototype.goToAndPlay = function (t, e, r) { this.goToAndStop(t, e, r), this.play() }, AnimationItem.prototype.advanceTime = function (t) { if (!0 !== this.isPaused && !1 !== this.isLoaded) { let e = this.currentRawFrame + t * this.frameModifier; let r = !1; e >= this.totalFrames - 1 && this.frameModifier > 0 ? this.loop && this.playCount !== this.loop ? e >= this.totalFrames ? (this.playCount += 1, this.checkSegments(e % this.totalFrames) || (this.setCurrentRawFrameValue(e % this.totalFrames), this._completedLoop = !0, this.trigger('loopComplete'))) : this.setCurrentRawFrameValue(e) : this.checkSegments(e > this.totalFrames ? e % this.totalFrames : 0) || (r = !0, e = this.totalFrames - 1) : e < 0 ? this.checkSegments(e % this.totalFrames) || (!this.loop || this.playCount-- <= 0 && !0 !== this.loop ? (r = !0, e = 0) : (this.setCurrentRawFrameValue(this.totalFrames + e % this.totalFrames), this._completedLoop ? this.trigger('loopComplete') : this._completedLoop = !0)) : this.setCurrentRawFrameValue(e), r && (this.setCurrentRawFrameValue(e), this.pause(), this.trigger('complete')) } }, AnimationItem.prototype.adjustSegment = function (t, e) { this.playCount = 0, t[1] < t[0] ? (this.frameModifier > 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)), this.timeCompleted = this.totalFrames = t[0] - t[1], this.firstFrame = t[1], this.setCurrentRawFrameValue(this.totalFrames - 0.001 - e)) : t[1] > t[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)), this.timeCompleted = this.totalFrames = t[1] - t[0], this.firstFrame = t[0], this.setCurrentRawFrameValue(0.001 + e)), this.trigger('segmentStart') }, AnimationItem.prototype.setSegment = function (t, e) { let r = -1; this.isPaused && (this.currentRawFrame + this.firstFrame < t ? r = t : this.currentRawFrame + this.firstFrame > e && (r = e - t)), this.firstFrame = t, this.timeCompleted = this.totalFrames = e - t, r !== -1 && this.goToAndStop(r, !0) }, AnimationItem.prototype.playSegments = function (t, e) { if (e && (this.segments.length = 0), typeof t[0] === 'object') { let r; const i = t.length; for (r = 0; r < i; r += 1) this.segments.push(t[r]) } else this.segments.push(t); this.segments.length && e && this.adjustSegment(this.segments.shift(), 0), this.isPaused && this.play() }, AnimationItem.prototype.resetSegments = function (t) { this.segments.length = 0, this.segments.push([this.animationData.ip, this.animationData.op]), t && this.checkSegments(0) }, AnimationItem.prototype.checkSegments = function (t) { return !!this.segments.length && (this.adjustSegment(this.segments.shift(), t), !0) }, AnimationItem.prototype.destroy = function (t) { t && this.name != t || !this.renderer || (this.renderer.destroy(), this.imagePreloader.destroy(), this.trigger('destroy'), this._cbs = null, this.onEnterFrame = this.onLoopComplete = this.onComplete = this.onSegmentStart = this.onDestroy = null, this.renderer = null) }, AnimationItem.prototype.setCurrentRawFrameValue = function (t) { this.currentRawFrame = t, this.gotoFrame() }, AnimationItem.prototype.setSpeed = function (t) { this.playSpeed = t, this.updaFrameModifier() }, AnimationItem.prototype.setDirection = function (t) { this.playDirection = t < 0 ? -1 : 1, this.updaFrameModifier() }, AnimationItem.prototype.updaFrameModifier = function () { this.frameModifier = this.frameMult * this.playSpeed * this.playDirection }, AnimationItem.prototype.getPath = function () { return this.path }, AnimationItem.prototype.getAssetsPath = function (t) { let e = ''; if (t.e)e = t.p; else if (this.assetsPath) { let r = t.p; r.indexOf('images/') !== -1 && (r = r.split('/')[1]), e = this.assetsPath + r } else e = this.path, e += t.u ? t.u : '', e += t.p; return e }, AnimationItem.prototype.getAssetData = function (t) { for (let e = 0, r = this.assets.length; e < r;) { if (t == this.assets[e].id) return this.assets[e]; e += 1 } }, AnimationItem.prototype.hide = function () { this.renderer.hide() }, AnimationItem.prototype.show = function () { this.renderer.show() }, AnimationItem.prototype.getDuration = function (t) { return t ? this.totalFrames : this.totalFrames / this.frameRate }, AnimationItem.prototype.trigger = function (t) { if (this._cbs && this._cbs[t]) switch (t) { case 'enterFrame': this.triggerEvent(t, new BMEnterFrameEvent(t, this.currentFrame, this.totalFrames, this.frameModifier)); break; case 'loopComplete': this.triggerEvent(t, new BMCompleteLoopEvent(t, this.loop, this.playCount, this.frameMult)); break; case 'complete': this.triggerEvent(t, new BMCompleteEvent(t, this.frameMult)); break; case 'segmentStart': this.triggerEvent(t, new BMSegmentStartEvent(t, this.firstFrame, this.totalFrames)); break; case 'destroy': this.triggerEvent(t, new BMDestroyEvent(t, this)); break; default: this.triggerEvent(t) }t === 'enterFrame' && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(t, this.currentFrame, this.totalFrames, this.frameMult)), t === 'loopComplete' && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(t, this.loop, this.playCount, this.frameMult)), t === 'complete' && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(t, this.frameMult)), t === 'segmentStart' && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(t, this.firstFrame, this.totalFrames)), t === 'destroy' && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(t, this)) }, AnimationItem.prototype.triggerRenderFrameError = function (t) { const e = new BMRenderFrameErrorEvent(t, this.currentFrame); this.triggerEvent('error', e), this.onError && this.onError.call(this, e) }, AnimationItem.prototype.triggerConfigError = function (t) { const e = new BMConfigErrorEvent(t, this.currentFrame); this.triggerEvent('error', e), this.onError && this.onError.call(this, e) }; const Expressions = (IW = {}, IW.initExpressions = function (t) { let e = 0; const r = []; function i() { let t; const e = r.length; for (t = 0; t < e; t += 1)r[t].release(); r.length = 0 }t.renderer.compInterface = CompExpressionInterface(t.renderer), t.renderer.globalData.projectInterface.registerComposition(t.renderer), t.renderer.globalData.pushExpression = function () { e += 1 }, t.renderer.globalData.popExpression = function () { (e -= 1) == 0 && i() }, t.renderer.globalData.registerExpressionProperty = function (t) { r.indexOf(t) === -1 && r.push(t) } }, IW); let IW; expressionsPlugin = Expressions; const ExpressionManager = (function () { const ob = {}; const Math = BMMath; const window = null; const document = null; function $bm_isInstanceOfArray(t) { return t.constructor === Array || t.constructor === Float32Array } function isNumerable(t, e) { return t === 'number' || t === 'boolean' || t === 'string' || e instanceof Number } function $bm_neg(t) { const e = typeof t; if (e === 'number' || e === 'boolean' || t instanceof Number) return -t; if ($bm_isInstanceOfArray(t)) { let r; const i = t.length; const s = []; for (r = 0; r < i; r += 1)s[r] = -t[r]; return s } return t.propType ? t.v : void 0 } const easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, 'easeIn').get; const easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, 'easeOut').get; const easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, 'easeInOut').get; function sum(t, e) { const r = typeof t; const i = typeof e; if (r === 'string' || i === 'string') return t + e; if (isNumerable(r, t) && isNumerable(i, e)) return t + e; if ($bm_isInstanceOfArray(t) && isNumerable(i, e)) return (t = t.slice(0))[0] = t[0] + e, t; if (isNumerable(r, t) && $bm_isInstanceOfArray(e)) return (e = e.slice(0))[0] = t + e[0], e; if ($bm_isInstanceOfArray(t) && $bm_isInstanceOfArray(e)) { for (var s = 0, a = t.length, n = e.length, o = []; s < a || s < n;)(typeof t[s] === 'number' || t[s] instanceof Number) && (typeof e[s] === 'number' || e[s] instanceof Number) ? o[s] = t[s] + e[s] : o[s] = void 0 === e[s] ? t[s] : t[s] || e[s], s += 1; return o } return 0 } const add = sum; function sub(t, e) { const r = typeof t; const i = typeof e; if (isNumerable(r, t) && isNumerable(i, e)) return r === 'string' && (t = parseInt(t)), i === 'string' && (e = parseInt(e)), t - e; if ($bm_isInstanceOfArray(t) && isNumerable(i, e)) return (t = t.slice(0))[0] = t[0] - e, t; if (isNumerable(r, t) && $bm_isInstanceOfArray(e)) return (e = e.slice(0))[0] = t - e[0], e; if ($bm_isInstanceOfArray(t) && $bm_isInstanceOfArray(e)) { for (var s = 0, a = t.length, n = e.length, o = []; s < a || s < n;)(typeof t[s] === 'number' || t[s] instanceof Number) && (typeof e[s] === 'number' || e[s] instanceof Number) ? o[s] = t[s] - e[s] : o[s] = void 0 === e[s] ? t[s] : t[s] || e[s], s += 1; return o } return 0 } function mul(t, e) { let r; let i; let s; const a = typeof t; const n = typeof e; if (isNumerable(a, t) && isNumerable(n, e)) return t * e; if ($bm_isInstanceOfArray(t) && isNumerable(n, e)) { for (s = t.length, r = createTypedArray('float32', s), i = 0; i < s; i += 1)r[i] = t[i] * e; return r } if (isNumerable(a, t) && $bm_isInstanceOfArray(e)) { for (s = e.length, r = createTypedArray('float32', s), i = 0; i < s; i += 1)r[i] = t * e[i]; return r } return 0 } function div(t, e) { let r; let i; let s; const a = typeof t; const n = typeof e; if (isNumerable(a, t) && isNumerable(n, e)) return t / e; if ($bm_isInstanceOfArray(t) && isNumerable(n, e)) { for (s = t.length, r = createTypedArray('float32', s), i = 0; i < s; i += 1)r[i] = t[i] / e; return r } if (isNumerable(a, t) && $bm_isInstanceOfArray(e)) { for (s = e.length, r = createTypedArray('float32', s), i = 0; i < s; i += 1)r[i] = t / e[i]; return r } return 0 } function mod(t, e) { return typeof t === 'string' && (t = parseInt(t)), typeof e === 'string' && (e = parseInt(e)), t % e } const $bm_sum = sum; const $bm_sub = sub; const $bm_mul = mul; const $bm_div = div; const $bm_mod = mod; function clamp(t, e, r) { if (r < e) { const i = r; r = e, e = i } return Math.min(Math.max(t, e), r) } function radiansToDegrees(t) { return t / degToRads } const radians_to_degrees = radiansToDegrees; function degreesToRadians(t) { return t * degToRads } const degrees_to_radians = radiansToDegrees; const helperLengthArray = [0, 0, 0, 0, 0, 0]; function length(t, e) { if (typeof t === 'number' || t instanceof Number) return e = e || 0, Math.abs(t - e); e || (e = helperLengthArray); let r; const i = Math.min(t.length, e.length); let s = 0; for (r = 0; r < i; r += 1)s += Math.pow(e[r] - t[r], 2); return Math.sqrt(s) } function normalize(t) { return div(t, length(t)) } function rgbToHsl(t) { let e; let r; const i = t[0]; const s = t[1]; const a = t[2]; const n = Math.max(i, s, a); const o = Math.min(i, s, a); const h = (n + o) / 2; if (n == o)e = r = 0; else { const l = n - o; switch (r = h > 0.5 ? l / (2 - n - o) : l / (n + o), n) { case i: e = (s - a) / l + (s < a ? 6 : 0); break; case s: e = (a - i) / l + 2; break; case a: e = (i - s) / l + 4 }e /= 6 } return [e, r, h, t[3]] } function hue2rgb(t, e, r) { return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? t + 6 * (e - t) * r : r < 0.5 ? e : r < 2 / 3 ? t + (e - t) * (2 / 3 - r) * 6 : t } function hslToRgb(t) { let e; let r; let i; const s = t[0]; const a = t[1]; const n = t[2]; if (a === 0)e = r = i = n; else { const o = n < 0.5 ? n * (1 + a) : n + a - n * a; const h = 2 * n - o; e = hue2rgb(h, o, s + 1 / 3), r = hue2rgb(h, o, s), i = hue2rgb(h, o, s - 1 / 3) } return [e, r, i, t[3]] } function linear(t, e, r, i, s) { if (void 0 !== i && void 0 !== s || (i = e, s = r, e = 0, r = 1), r < e) { const a = r; r = e, e = a } if (t <= e) return i; if (r <= t) return s; const n = r === e ? 0 : (t - e) / (r - e); if (!i.length) return i + (s - i) * n; let o; const h = i.length; const l = createTypedArray('float32', h); for (o = 0; o < h; o += 1)l[o] = i[o] + (s[o] - i[o]) * n; return l } function random(t, e) { if (void 0 === e && (void 0 === t ? (t = 0, e = 1) : (e = t, t = void 0)), e.length) { let r; const i = e.length; t || (t = createTypedArray('float32', i)); const s = createTypedArray('float32', i); const a = BMMath.random(); for (r = 0; r < i; r += 1)s[r] = t[r] + a * (e[r] - t[r]); return s } return void 0 === t && (t = 0), t + BMMath.random() * (e - t) } function createPath(t, e, r, i) { let s; const a = t.length; const n = shape_pool.newElement(); n.setPathData(!!i, a); let o; let h; const l = [0, 0]; for (s = 0; s < a; s += 1)o = e && e[s] ? e[s] : l, h = r && r[s] ? r[s] : l, n.setTripleAt(t[s][0], t[s][1], h[0] + t[s][0], h[1] + t[s][1], o[0] + t[s][0], o[1] + t[s][1], s, !0); return n } function initiateExpression(elem, data, property) { const val = data.x; const needsVelocity = /velocity(?![\w\d])/.test(val); const _needsRandom = val.indexOf('random') !== -1; const elemType = elem.data.ty; let transform; let $bm_transform; let content; let effect; const thisProperty = property; thisProperty.valueAtTime = thisProperty.getValueAtTime, Object.defineProperty(thisProperty, 'value', { get() { return thisProperty.v } }), elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate, elem.comp.displayStartTime = 0; const inPoint = elem.data.ip / elem.comp.globalData.frameRate; const outPoint = elem.data.op / elem.comp.globalData.frameRate; const width = elem.data.sw ? elem.data.sw : 0; const height = elem.data.sh ? elem.data.sh : 0; const name = elem.data.nm; let loopIn; let loop_in; let loopOut; let loop_out; let smooth; let toWorld; let fromWorld; let fromComp; let toComp; let fromCompToSurface; let position; let rotation; let anchorPoint; let scale; let thisLayer; let thisComp; let mask; let valueAtTime; let velocityAtTime; const __expression_functions = []; let scoped_bm_rt; if (data.xf) { let i; const len = data.xf.length; for (i = 0; i < len; i += 1)__expression_functions[i] = eval(`(function(){ return ${data.xf[i]}}())`) } const expression_function = eval(`[function _expression_function(){${val};scoped_bm_rt=$bm_rt}]`)[0]; const numKeys = property.kf ? data.k.length : 0; const active = !this.data || !0 !== this.data.hd; const wiggle = function (t, e) { let r; let i; const s = this.pv.length ? this.pv.length : 1; const a = createTypedArray('float32', s); const n = Math.floor(5 * time); for (i = r = 0; r < n;) { for (i = 0; i < s; i += 1)a[i] += -e + 2 * e * BMMath.random(); r += 1 } const o = 5 * time; const h = o - Math.floor(o); const l = createTypedArray('float32', s); if (s > 1) { for (i = 0; i < s; i += 1)l[i] = this.pv[i] + a[i] + (-e + 2 * e * BMMath.random()) * h; return l } return this.pv + a[0] + (-e + 2 * e * BMMath.random()) * h }.bind(this); function loopInDuration(t, e) { return loopIn(t, e, !0) } function loopOutDuration(t, e) { return loopOut(t, e, !0) }thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty), loop_in = loopIn), thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty), loop_out = loopOut), thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty)), this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)), this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this)); const comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface); let time; let velocity; let value; let text; let textIndex; let textTotal; let selectorValue; function lookAt(t, e) { const r = [e[0] - t[0], e[1] - t[1], e[2] - t[2]]; const i = Math.atan2(r[0], Math.sqrt(r[1] * r[1] + r[2] * r[2])) / degToRads; return [-Math.atan2(r[1], r[2]) / degToRads, i, 0] } function easeOut(t, e, r, i, s) { return applyEase(easeOutBez, t, e, r, i, s) } function easeIn(t, e, r, i, s) { return applyEase(easeInBez, t, e, r, i, s) } function ease(t, e, r, i, s) { return applyEase(easeInOutBez, t, e, r, i, s) } function applyEase(t, e, r, i, s, a) { void 0 === s ? (s = r, a = i) : e = (e - r) / (i - r); const n = t(e = e > 1 ? 1 : e < 0 ? 0 : e); if ($bm_isInstanceOfArray(s)) { let o; const h = s.length; const l = createTypedArray('float32', h); for (o = 0; o < h; o += 1)l[o] = (a[o] - s[o]) * n + s[o]; return l } return (a - s) * n + s } function nearestKey(t) { let e; let r; let i; const s = data.k.length; if (data.k.length && typeof data.k[0] !== 'number') if (r = -1, (t *= elem.comp.globalData.frameRate) < data.k[0].t)r = 1, i = data.k[0].t; else { for (e = 0; e < s - 1; e += 1) { if (t === data.k[e].t) { r = e + 1, i = data.k[e].t; break } if (t > data.k[e].t && t < data.k[e + 1].t) { i = t - data.k[e].t > data.k[e + 1].t - t ? (r = e + 2, data.k[e + 1].t) : (r = e + 1, data.k[e].t); break } }r === -1 && (r = e + 1, i = data.k[e].t) } else i = r = 0; const a = {}; return a.index = r, a.time = i / elem.comp.globalData.frameRate, a } function key(t) { let e; let r; let i; if (!data.k.length || typeof data.k[0] === 'number') throw new Error(`The property has no keyframe at index ${t}`); t -= 1, e = { time: data.k[t].t / elem.comp.globalData.frameRate, value: [] }; const s = data.k[t].hasOwnProperty('s') ? data.k[t].s : data.k[t - 1].e; for (i = s.length, r = 0; r < i; r += 1)e[r] = s[r], e.value[r] = s[r]; return e } function framesToTime(t, e) { return e || (e = elem.comp.globalData.frameRate), t / e } function timeToFrames(t, e) { return t || t === 0 || (t = time), e || (e = elem.comp.globalData.frameRate), t * e } function seedRandom(t) { BMMath.seedrandom(randSeed + t) } function sourceRectAtTime() { return elem.sourceRectAtTime() } function substring(t, e) { return typeof value === 'string' ? void 0 === e ? value.substring(t) : value.substring(t, e) : '' } function substr(t, e) { return typeof value === 'string' ? void 0 === e ? value.substr(t) : value.substr(t, e) : '' } function posterizeTime(t) { time = t === 0 ? 0 : Math.floor(time * t) / t, value = valueAtTime(time) } const index = elem.data.ind; let hasParent = !(!elem.hierarchy || !elem.hierarchy.length); let parent; var randSeed = Math.floor(1e6 * Math.random()); const { globalData } = elem; function executeExpression(t) { return value = t, _needsRandom && seedRandom(randSeed), this.frameExpressionId === elem.globalData.frameId && this.propType !== 'textSelector' ? value : (this.propType === 'textSelector' && (textIndex = this.textIndex, textTotal = this.textTotal, selectorValue = this.selectorValue), thisLayer || (text = elem.layerInterface.text, thisLayer = elem.layerInterface, thisComp = elem.comp.compInterface, toWorld = thisLayer.toWorld.bind(thisLayer), fromWorld = thisLayer.fromWorld.bind(thisLayer), fromComp = thisLayer.fromComp.bind(thisLayer), toComp = thisLayer.toComp.bind(thisLayer), mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null, fromCompToSurface = fromComp), transform || (transform = elem.layerInterface('ADBE Transform Group'), ($bm_transform = transform) && (anchorPoint = transform.anchorPoint)), elemType !== 4 || content || (content = thisLayer('ADBE Root Vectors Group')), effect || (effect = thisLayer(4)), (hasParent = !(!elem.hierarchy || !elem.hierarchy.length)) && !parent && (parent = elem.hierarchy[0].layerInterface), time = this.comp.renderedFrame / this.comp.globalData.frameRate, needsVelocity && (velocity = velocityAtTime(time)), expression_function(), this.frameExpressionId = elem.globalData.frameId, scoped_bm_rt.propType === 'shape' && (scoped_bm_rt = scoped_bm_rt.v), scoped_bm_rt) } return executeExpression } return ob.initiateExpression = initiateExpression, ob }()); const expressionHelpers = {
    searchExpressions(t, e, r) { e.x && (r.k = !0, r.x = !0, r.initiateExpression = ExpressionManager.initiateExpression, r.effectsSequence.push(r.initiateExpression(t, e, r).bind(r))) }, getSpeedAtTime(t) { const e = this.getValueAtTime(t); const r = this.getValueAtTime(t + -0.01); let i = 0; if (e.length) { let s; for (s = 0; s < e.length; s += 1)i += Math.pow(r[s] - e[s], 2); i = 100 * Math.sqrt(i) } else i = 0; return i }, getVelocityAtTime(t) { if (void 0 !== this.vel) return this.vel; let e; let r; const i = this.getValueAtTime(t); const s = this.getValueAtTime(t + -0.001); if (i.length) for (e = createTypedArray('float32', i.length), r = 0; r < i.length; r += 1)e[r] = (s[r] - i[r]) / -0.001; else e = (s - i) / -0.001; return e }, getValueAtTime(t) { return t *= this.elem.globalData.frameRate, (t -= this.offsetTime) !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < t ? this._cachingAtTime.lastIndex : 0, this._cachingAtTime.value = this.interpolateValue(t, this._cachingAtTime), this._cachingAtTime.lastFrame = t), this._cachingAtTime.value }, getStaticValueAtTime() { return this.pv }, setGroupProperty(t) { this.propertyGroup = t }
  }; !(function () {
    function o(t, e, r) { if (!this.k || !this.keyframes) return this.pv; t = t ? t.toLowerCase() : ''; let i; let s; let a; let n; let o; const h = this.comp.renderedFrame; const l = this.keyframes; const p = l[l.length - 1].t; if (h <= p) return this.pv; if (r ? s = p - (i = e ? Math.abs(p - elem.comp.globalData.frameRate * e) : Math.max(0, p - this.elem.data.ip)) : ((!e || e > l.length - 1) && (e = l.length - 1), i = p - (s = l[l.length - 1 - e].t)), t === 'pingpong') { if (Math.floor((h - s) / i) % 2 != 0) return this.getValueAtTime((i - (h - s) % i + s) / this.comp.globalData.frameRate, 0) } else { if (t === 'offset') { const m = this.getValueAtTime(s / this.comp.globalData.frameRate, 0); const f = this.getValueAtTime(p / this.comp.globalData.frameRate, 0); const c = this.getValueAtTime(((h - s) % i + s) / this.comp.globalData.frameRate, 0); const d = Math.floor((h - s) / i); if (this.pv.length) { for (n = (o = new Array(m.length)).length, a = 0; a < n; a += 1)o[a] = (f[a] - m[a]) * d + c[a]; return o } return (f - m) * d + c } if (t === 'continue') { const u = this.getValueAtTime(p / this.comp.globalData.frameRate, 0); const y = this.getValueAtTime((p - 0.001) / this.comp.globalData.frameRate, 0); if (this.pv.length) { for (n = (o = new Array(u.length)).length, a = 0; a < n; a += 1)o[a] = u[a] + (u[a] - y[a]) * ((h - p) / this.comp.globalData.frameRate) / 5e-4; return o } return u + (h - p) / 0.001 * (u - y) } } return this.getValueAtTime(((h - s) % i + s) / this.comp.globalData.frameRate, 0) } function h(t, e, r) { if (!this.k) return this.pv; t = t ? t.toLowerCase() : ''; let i; let s; let a; let n; let o; const h = this.comp.renderedFrame; const l = this.keyframes; const p = l[0].t; if (p <= h) return this.pv; if (r ? s = p + (i = e ? Math.abs(elem.comp.globalData.frameRate * e) : Math.max(0, this.elem.data.op - p)) : ((!e || e > l.length - 1) && (e = l.length - 1), i = (s = l[e].t) - p), t === 'pingpong') { if (Math.floor((p - h) / i) % 2 == 0) return this.getValueAtTime(((p - h) % i + p) / this.comp.globalData.frameRate, 0) } else { if (t === 'offset') { const m = this.getValueAtTime(p / this.comp.globalData.frameRate, 0); const f = this.getValueAtTime(s / this.comp.globalData.frameRate, 0); const c = this.getValueAtTime((i - (p - h) % i + p) / this.comp.globalData.frameRate, 0); const d = Math.floor((p - h) / i) + 1; if (this.pv.length) { for (n = (o = new Array(m.length)).length, a = 0; a < n; a += 1)o[a] = c[a] - (f[a] - m[a]) * d; return o } return c - (f - m) * d } if (t === 'continue') { const u = this.getValueAtTime(p / this.comp.globalData.frameRate, 0); const y = this.getValueAtTime((p + 0.001) / this.comp.globalData.frameRate, 0); if (this.pv.length) { for (n = (o = new Array(u.length)).length, a = 0; a < n; a += 1)o[a] = u[a] + (u[a] - y[a]) * (p - h) / 0.001; return o } return u + (u - y) * (p - h) / 0.001 } } return this.getValueAtTime((i - (p - h) % i + p) / this.comp.globalData.frameRate, 0) } function l(t, e) { if (!this.k) return this.pv; if (t = 0.5 * (t || 0.4), (e = Math.floor(e || 5)) <= 1) return this.pv; let r; let i; const s = this.comp.renderedFrame / this.comp.globalData.frameRate; const a = s - t; const n = e > 1 ? (s + t - a) / (e - 1) : 1; let o = 0; let h = 0; for (r = this.pv.length ? createTypedArray('float32', this.pv.length) : 0; o < e;) { if (i = this.getValueAtTime(a + o * n), this.pv.length) for (h = 0; h < this.pv.length; h += 1)r[h] += i[h]; else r += i; o += 1 } if (this.pv.length) for (h = 0; h < this.pv.length; h += 1)r[h] /= e; else r /= e; return r } const s = TransformPropertyFactory.getTransformProperty; TransformPropertyFactory.getTransformProperty = function (t, e, r) { const i = s(t, e, r); return i.dynamicProperties.length ? i.getValueAtTime = function (t) { console.warn('Transform at time not supported') } : i.getValueAtTime = function (t) {}, i.setGroupProperty = expressionHelpers.setGroupProperty, i }; const p = PropertyFactory.getProp; PropertyFactory.getProp = function (t, e, r, i, s) { const a = p(t, e, r, i, s); a.kf ? a.getValueAtTime = expressionHelpers.getValueAtTime.bind(a) : a.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(a), a.setGroupProperty = expressionHelpers.setGroupProperty, a.loopOut = o, a.loopIn = h, a.smooth = l, a.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(a), a.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(a), a.numKeys = e.a === 1 ? e.k.length : 0, a.propertyIndex = e.ix; let n = 0; return r !== 0 && (n = createTypedArray('float32', e.a === 1 ? e.k[0].s.length : e.k.length)), a._cachingAtTime = { lastFrame: initialDefaultFrame, lastIndex: 0, value: n }, expressionHelpers.searchExpressions(t, e, a), a.k && s.addDynamicProperty(a), a }; const t = ShapePropertyFactory.getConstructorFunction(); const e = ShapePropertyFactory.getKeyframedConstructorFunction(); function r() {}r.prototype = {
      vertices(t, e) { this.k && this.getValue(); let r = this.v; void 0 !== e && (r = this.getValueAtTime(e, 0)); let i; const s = r._length; const a = r[t]; const n = r.v; const o = createSizedArray(s); for (i = 0; i < s; i += 1)o[i] = t === 'i' || t === 'o' ? [a[i][0] - n[i][0], a[i][1] - n[i][1]] : [a[i][0], a[i][1]]; return o }, points(t) { return this.vertices('v', t) }, inTangents(t) { return this.vertices('i', t) }, outTangents(t) { return this.vertices('o', t) }, isClosed() { return this.v.c }, pointOnPath(t, e) { let r = this.v; void 0 !== e && (r = this.getValueAtTime(e, 0)), this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(r)); for (var i, s = this._segmentsLength, a = s.lengths, n = s.totalLength * t, o = 0, h = a.length, l = 0; o < h;) { if (l + a[o].addedLength > n) { const p = o; const m = r.c && o === h - 1 ? 0 : o + 1; const f = (n - l) / a[o].addedLength; i = bez.getPointInSegment(r.v[p], r.v[m], r.o[p], r.i[m], f, a[o]); break }l += a[o].addedLength, o += 1 } return i || (i = r.c ? [r.v[0][0], r.v[0][1]] : [r.v[r._length - 1][0], r.v[r._length - 1][1]]), i }, vectorOnPath(t, e, r) { t = t == 1 ? this.v.c ? 0 : 0.999 : t; const i = this.pointOnPath(t, e); const s = this.pointOnPath(t + 0.001, e); const a = s[0] - i[0]; const n = s[1] - i[1]; const o = Math.sqrt(Math.pow(a, 2) + Math.pow(n, 2)); return o === 0 ? [0, 0] : r === 'tangent' ? [a / o, n / o] : [-n / o, a / o] }, tangentOnPath(t, e) { return this.vectorOnPath(t, e, 'tangent') }, normalOnPath(t, e) { return this.vectorOnPath(t, e, 'normal') }, setGroupProperty: expressionHelpers.setGroupProperty, getValueAtTime: expressionHelpers.getStaticValueAtTime
    }, extendPrototype([r], t), extendPrototype([r], e), e.prototype.getValueAtTime = function (t) { return this._cachingAtTime || (this._cachingAtTime = { shapeValue: shape_pool.clone(this.pv), lastIndex: 0, lastTime: initialDefaultFrame }), t *= this.elem.globalData.frameRate, (t -= this.offsetTime) !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < t ? this._caching.lastIndex : 0, this._cachingAtTime.lastTime = t, this.interpolateShape(t, this._cachingAtTime.shapeValue, this._cachingAtTime)), this._cachingAtTime.shapeValue }, e.prototype.initiateExpression = ExpressionManager.initiateExpression; const n = ShapePropertyFactory.getShapeProp; ShapePropertyFactory.getShapeProp = function (t, e, r, i, s) { const a = n(t, e, r, i, s); return a.propertyIndex = e.ix, a.lock = !1, r === 3 ? expressionHelpers.searchExpressions(t, e.pt, a) : r === 4 && expressionHelpers.searchExpressions(t, e.ks, a), a.k && t.addDynamicProperty(a), a }
  }()), TextProperty.prototype.getExpressionValue = function (t, e) { const r = this.calculateExpression(e); if (t.t === r) return t; const i = {}; return this.copyData(i, t), i.t = r.toString(), i.__complete = !1, i }, TextProperty.prototype.searchProperty = function () { const t = this.searchKeyframes(); const e = this.searchExpressions(); return this.kf = t || e, this.kf }, TextProperty.prototype.searchExpressions = function () { if (this.data.d.x) return this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this), this.addEffect(this.getExpressionValue.bind(this)), !0 }; var ShapeExpressionInterface = (function () {
    function m(t, e, r) { let i; const s = []; const a = t ? t.length : 0; for (i = 0; i < a; i += 1)t[i].ty == 'gr' ? s.push(n(t[i], e[i], r)) : t[i].ty == 'fl' ? s.push(o(t[i], e[i], r)) : t[i].ty == 'st' ? s.push(h(t[i], e[i], r)) : t[i].ty == 'tm' ? s.push(l(t[i], e[i], r)) : t[i].ty == 'tr' || (t[i].ty == 'el' ? s.push(p(t[i], e[i], r)) : t[i].ty == 'sr' ? s.push(f(t[i], e[i], r)) : t[i].ty == 'sh' ? s.push(y(t[i], e[i], r)) : t[i].ty == 'rc' ? s.push(c(t[i], e[i], r)) : t[i].ty == 'rd' ? s.push(d(t[i], e[i], r)) : t[i].ty == 'rp' && s.push(u(t[i], e[i], r))); return s } function n(t, e, r) {
      var i = function (t) { switch (t) { case 'ADBE Vectors Group': case 'Contents': case 2: return i.content; default: return i.transform } }; i.propertyGroup = function (t) { return t === 1 ? i : r(t - 1) }; let s; let a; let n; let o; let h; const l = (s = t, a = e, n = i.propertyGroup, (h = function (t) { for (let e = 0, r = o.length; e < r;) { if (o[e]._name === t || o[e].mn === t || o[e].propertyIndex === t || o[e].ix === t || o[e].ind === t) return o[e]; e += 1 } if (typeof t === 'number') return o[t - 1] }).propertyGroup = function (t) { return t === 1 ? h : n(t - 1) }, o = m(s.it, a.it, h.propertyGroup), h.numProperties = o.length, h.propertyIndex = s.cix, h._name = s.nm, h); const p = (function (e, t, r) {
        function i(t) { return t == 1 ? s : r(--t) }t.transform.mProps.o.setGroupProperty(i), t.transform.mProps.p.setGroupProperty(i), t.transform.mProps.a.setGroupProperty(i), t.transform.mProps.s.setGroupProperty(i), t.transform.mProps.r.setGroupProperty(i), t.transform.mProps.sk && (t.transform.mProps.sk.setGroupProperty(i), t.transform.mProps.sa.setGroupProperty(i)); function s(t) { return e.a.ix === t || t === 'Anchor Point' ? s.anchorPoint : e.o.ix === t || t === 'Opacity' ? s.opacity : e.p.ix === t || t === 'Position' ? s.position : e.r.ix === t || t === 'Rotation' || t === 'ADBE Vector Rotation' ? s.rotation : e.s.ix === t || t === 'Scale' ? s.scale : e.sk && e.sk.ix === t || t === 'Skew' ? s.skew : e.sa && e.sa.ix === t || t === 'Skew Axis' ? s.skewAxis : void 0 } return t.transform.op.setGroupProperty(i), Object.defineProperties(s, {
          opacity: { get: ExpressionPropertyInterface(t.transform.mProps.o) }, position: { get: ExpressionPropertyInterface(t.transform.mProps.p) }, anchorPoint: { get: ExpressionPropertyInterface(t.transform.mProps.a) }, scale: { get: ExpressionPropertyInterface(t.transform.mProps.s) }, rotation: { get: ExpressionPropertyInterface(t.transform.mProps.r) }, skew: { get: ExpressionPropertyInterface(t.transform.mProps.sk) }, skewAxis: { get: ExpressionPropertyInterface(t.transform.mProps.sa) }, _name: { value: e.nm }
        }), s.ty = 'tr', s.mn = e.mn, s.propertyGroup = r, s
      }(t.it[t.it.length - 1], e.it[e.it.length - 1], i.propertyGroup)); return i.content = l, i.transform = p, Object.defineProperty(i, '_name', { get() { return t.nm } }), i.numProperties = t.np, i.propertyIndex = t.ix, i.nm = t.nm, i.mn = t.mn, i
    } function o(t, e, r) {
      function i(t) { return t === 'Color' || t === 'color' ? i.color : t === 'Opacity' || t === 'opacity' ? i.opacity : void 0 } return Object.defineProperties(i, {
        color: { get: ExpressionPropertyInterface(e.c) }, opacity: { get: ExpressionPropertyInterface(e.o) }, _name: { value: t.nm }, mn: { value: t.mn }
      }), e.c.setGroupProperty(r), e.o.setGroupProperty(r), i
    } function h(t, e, r) {
      function i(t) { return t === 1 ? ob : r(t - 1) } function s(t) { return t === 1 ? h : i(t - 1) } let a; let n; const o = t.d ? t.d.length : 0; var h = {}; for (a = 0; a < o; a += 1)n = a, Object.defineProperty(h, t.d[n].nm, { get: ExpressionPropertyInterface(e.d.dataProps[n].p) }), e.d.dataProps[a].p.setGroupProperty(s); function l(t) { return t === 'Color' || t === 'color' ? l.color : t === 'Opacity' || t === 'opacity' ? l.opacity : t === 'Stroke Width' || t === 'stroke width' ? l.strokeWidth : void 0 } return Object.defineProperties(l, {
        color: { get: ExpressionPropertyInterface(e.c) }, opacity: { get: ExpressionPropertyInterface(e.o) }, strokeWidth: { get: ExpressionPropertyInterface(e.w) }, dash: { get() { return h } }, _name: { value: t.nm }, mn: { value: t.mn }
      }), e.c.setGroupProperty(i), e.o.setGroupProperty(i), e.w.setGroupProperty(i), l
    } function l(e, t, r) {
      function i(t) { return t == 1 ? s : r(--t) } function s(t) { return t === e.e.ix || t === 'End' || t === 'end' ? s.end : t === e.s.ix ? s.start : t === e.o.ix ? s.offset : void 0 } return s.propertyIndex = e.ix, t.s.setGroupProperty(i), t.e.setGroupProperty(i), t.o.setGroupProperty(i), s.propertyIndex = e.ix, s.propertyGroup = r, Object.defineProperties(s, {
        start: { get: ExpressionPropertyInterface(t.s) }, end: { get: ExpressionPropertyInterface(t.e) }, offset: { get: ExpressionPropertyInterface(t.o) }, _name: { value: e.nm }
      }), s.mn = e.mn, s
    } function p(e, t, r) { function i(t) { return t == 1 ? a : r(--t) }a.propertyIndex = e.ix; const s = t.sh.ty === 'tm' ? t.sh.prop : t.sh; function a(t) { return e.p.ix === t ? a.position : e.s.ix === t ? a.size : void 0 } return s.s.setGroupProperty(i), s.p.setGroupProperty(i), Object.defineProperties(a, { size: { get: ExpressionPropertyInterface(s.s) }, position: { get: ExpressionPropertyInterface(s.p) }, _name: { value: e.nm } }), a.mn = e.mn, a } function f(e, t, r) {
      function i(t) { return t == 1 ? a : r(--t) } const s = t.sh.ty === 'tm' ? t.sh.prop : t.sh; function a(t) { return e.p.ix === t ? a.position : e.r.ix === t ? a.rotation : e.pt.ix === t ? a.points : e.or.ix === t || t === 'ADBE Vector Star Outer Radius' ? a.outerRadius : e.os.ix === t ? a.outerRoundness : !e.ir || e.ir.ix !== t && t !== 'ADBE Vector Star Inner Radius' ? e.is && e.is.ix === t ? a.innerRoundness : void 0 : a.innerRadius } return a.propertyIndex = e.ix, s.or.setGroupProperty(i), s.os.setGroupProperty(i), s.pt.setGroupProperty(i), s.p.setGroupProperty(i), s.r.setGroupProperty(i), e.ir && (s.ir.setGroupProperty(i), s.is.setGroupProperty(i)), Object.defineProperties(a, {
        position: { get: ExpressionPropertyInterface(s.p) }, rotation: { get: ExpressionPropertyInterface(s.r) }, points: { get: ExpressionPropertyInterface(s.pt) }, outerRadius: { get: ExpressionPropertyInterface(s.or) }, outerRoundness: { get: ExpressionPropertyInterface(s.os) }, innerRadius: { get: ExpressionPropertyInterface(s.ir) }, innerRoundness: { get: ExpressionPropertyInterface(s.is) }, _name: { value: e.nm }
      }), a.mn = e.mn, a
    } function c(e, t, r) {
      function i(t) { return t == 1 ? a : r(--t) } const s = t.sh.ty === 'tm' ? t.sh.prop : t.sh; function a(t) { return e.p.ix === t ? a.position : e.r.ix === t ? a.roundness : e.s.ix === t || t === 'Size' || t === 'ADBE Vector Rect Size' ? a.size : void 0 } return a.propertyIndex = e.ix, s.p.setGroupProperty(i), s.s.setGroupProperty(i), s.r.setGroupProperty(i), Object.defineProperties(a, {
        position: { get: ExpressionPropertyInterface(s.p) }, roundness: { get: ExpressionPropertyInterface(s.r) }, size: { get: ExpressionPropertyInterface(s.s) }, _name: { value: e.nm }
      }), a.mn = e.mn, a
    } function d(e, t, r) { const i = t; function s(t) { if (e.r.ix === t || t === 'Round Corners 1') return s.radius } return s.propertyIndex = e.ix, i.rd.setGroupProperty(t => (t == 1 ? s : r(--t))), Object.defineProperties(s, { radius: { get: ExpressionPropertyInterface(i.rd) }, _name: { value: e.nm } }), s.mn = e.mn, s } function u(e, t, r) { function i(t) { return t == 1 ? a : r(--t) } const s = t; function a(t) { return e.c.ix === t || t === 'Copies' ? a.copies : e.o.ix === t || t === 'Offset' ? a.offset : void 0 } return a.propertyIndex = e.ix, s.c.setGroupProperty(i), s.o.setGroupProperty(i), Object.defineProperties(a, { copies: { get: ExpressionPropertyInterface(s.c) }, offset: { get: ExpressionPropertyInterface(s.o) }, _name: { value: e.nm } }), a.mn = e.mn, a } function y(t, e, r) {
      const i = e.sh; function s(t) { if (t === 'Shape' || t === 'shape' || t === 'Path' || t === 'path' || t === 'ADBE Vector Shape' || t === 2) return s.path } return i.setGroupProperty(t => (t == 1 ? s : r(--t))), Object.defineProperties(s, {
        path: { get() { return i.k && i.getValue(), i } }, shape: { get() { return i.k && i.getValue(), i } }, _name: { value: t.nm }, ix: { value: t.ix }, propertyIndex: { value: t.ix }, mn: { value: t.mn }
      }), s
    } return function (t, e, r) { let i; function s(t) { if (typeof t === 'number') return i[t - 1]; for (let e = 0, r = i.length; e < r;) { if (i[e]._name === t) return i[e]; e += 1 } } return s.propertyGroup = r, i = m(t, e, s), s.numProperties = i.length, s }
  }()); var TextExpressionInterface = function (e) { let r; function t() {} return Object.defineProperty(t, 'sourceText', { get() { e.textProperty.getValue(); const { t } = e.textProperty.currentData; return void 0 !== t && (e.textProperty.currentData.t = void 0, (r = new String(t)).value = t || new String(t)), r } }), t }; var LayerExpressionInterface = (function () {
    function s(t, e) { const r = new Matrix(); if (r.reset(), this._elem.finalTransform.mProp.applyToMatrix(r), this._elem.hierarchy && this._elem.hierarchy.length) { let i; const s = this._elem.hierarchy.length; for (i = 0; i < s; i += 1) this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(r); return r.applyToPointArray(t[0], t[1], t[2] || 0) } return r.applyToPointArray(t[0], t[1], t[2] || 0) } function a(t, e) { const r = new Matrix(); if (r.reset(), this._elem.finalTransform.mProp.applyToMatrix(r), this._elem.hierarchy && this._elem.hierarchy.length) { let i; const s = this._elem.hierarchy.length; for (i = 0; i < s; i += 1) this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(r); return r.inversePoint(t) } return r.inversePoint(t) } function n(t) { const e = new Matrix(); if (e.reset(), this._elem.finalTransform.mProp.applyToMatrix(e), this._elem.hierarchy && this._elem.hierarchy.length) { let r; const i = this._elem.hierarchy.length; for (r = 0; r < i; r += 1) this._elem.hierarchy[r].finalTransform.mProp.applyToMatrix(e); return e.inversePoint(t) } return e.inversePoint(t) } function o() { return [1, 1, 1, 1] } return function (e) {
      let r; function i(t) { switch (t) { case 'ADBE Root Vectors Group': case 'Contents': case 2: return i.shapeInterface; case 1: case 6: case 'Transform': case 'transform': case 'ADBE Transform Group': return r; case 4: case 'ADBE Effect Parade': case 'effects': case 'Effects': return i.effect } }i.toWorld = s, i.fromWorld = a, i.toComp = s, i.fromComp = n, i.sampleImage = o, i.sourceRectAtTime = e.sourceRectAtTime.bind(e); const t = getDescriptor(r = TransformExpressionInterface((i._elem = e).finalTransform.mProp), 'anchorPoint'); return Object.defineProperties(i, {
        hasParent: { get() { return e.hierarchy.length } }, parent: { get() { return e.hierarchy[0].layerInterface } }, rotation: getDescriptor(r, 'rotation'), scale: getDescriptor(r, 'scale'), position: getDescriptor(r, 'position'), opacity: getDescriptor(r, 'opacity'), anchorPoint: t, anchor_point: t, transform: { get() { return r } }, active: { get() { return e.isInRange } }
      }), i.startTime = e.data.st, i.index = e.data.ind, i.source = e.data.refId, i.height = e.data.ty === 0 ? e.data.h : 100, i.width = e.data.ty === 0 ? e.data.w : 100, i.inPoint = e.data.ip / e.comp.globalData.frameRate, i.outPoint = e.data.op / e.comp.globalData.frameRate, i._name = e.data.nm, i.registerMaskInterface = function (t) { i.mask = new MaskManagerInterface(t, e) }, i.registerEffectsInterface = function (t) { i.effect = t }, i
    }
  }()); var CompExpressionInterface = function (i) { function t(t) { for (let e = 0, r = i.layers.length; e < r;) { if (i.layers[e].nm === t || i.layers[e].ind === t) return i.elements[e].layerInterface; e += 1 } return null } return Object.defineProperty(t, '_name', { value: i.data.nm }), (t.layer = t).pixelAspect = 1, t.height = i.data.h || i.globalData.compSize.h, t.width = i.data.w || i.globalData.compSize.w, t.pixelAspect = 1, t.frameDuration = 1 / i.globalData.frameRate, t.displayStartTime = 0, t.numLayers = i.layers.length, t }; var TransformExpressionInterface = function (t) { function e(t) { switch (t) { case 'scale': case 'Scale': case 'ADBE Scale': case 6: return e.scale; case 'rotation': case 'Rotation': case 'ADBE Rotation': case 'ADBE Rotate Z': case 10: return e.rotation; case 'ADBE Rotate X': return e.xRotation; case 'ADBE Rotate Y': return e.yRotation; case 'position': case 'Position': case 'ADBE Position': case 2: return e.position; case 'ADBE Position_0': return e.xPosition; case 'ADBE Position_1': return e.yPosition; case 'ADBE Position_2': return e.zPosition; case 'anchorPoint': case 'AnchorPoint': case 'Anchor Point': case 'ADBE AnchorPoint': case 1: return e.anchorPoint; case 'opacity': case 'Opacity': case 11: return e.opacity } } if (Object.defineProperty(e, 'rotation', { get: ExpressionPropertyInterface(t.r || t.rz) }), Object.defineProperty(e, 'zRotation', { get: ExpressionPropertyInterface(t.rz || t.r) }), Object.defineProperty(e, 'xRotation', { get: ExpressionPropertyInterface(t.rx) }), Object.defineProperty(e, 'yRotation', { get: ExpressionPropertyInterface(t.ry) }), Object.defineProperty(e, 'scale', { get: ExpressionPropertyInterface(t.s) }), t.p) var r = ExpressionPropertyInterface(t.p); return Object.defineProperty(e, 'position', { get() { return t.p ? r() : [t.px.v, t.py.v, t.pz ? t.pz.v : 0] } }), Object.defineProperty(e, 'xPosition', { get: ExpressionPropertyInterface(t.px) }), Object.defineProperty(e, 'yPosition', { get: ExpressionPropertyInterface(t.py) }), Object.defineProperty(e, 'zPosition', { get: ExpressionPropertyInterface(t.pz) }), Object.defineProperty(e, 'anchorPoint', { get: ExpressionPropertyInterface(t.a) }), Object.defineProperty(e, 'opacity', { get: ExpressionPropertyInterface(t.o) }), Object.defineProperty(e, 'skew', { get: ExpressionPropertyInterface(t.sk) }), Object.defineProperty(e, 'skewAxis', { get: ExpressionPropertyInterface(t.sa) }), Object.defineProperty(e, 'orientation', { get: ExpressionPropertyInterface(t.or) }), e }; var ProjectInterface = (function () { function e(t) { this.compositions.push(t) } return function () { function t(t) { for (let e = 0, r = this.compositions.length; e < r;) { if (this.compositions[e].data && this.compositions[e].data.nm === t) return this.compositions[e].prepareFrame && this.compositions[e].data.xt && this.compositions[e].prepareFrame(this.currentFrame), this.compositions[e].compInterface; e += 1 } } return t.compositions = [], t.currentFrame = 0, t.registerComposition = e, t } }()); var EffectsExpressionInterface = (function () { function l(s, t, e, r) { let i; const a = []; const n = s.ef.length; for (i = 0; i < n; i += 1)s.ef[i].ty === 5 ? a.push(l(s.ef[i], t.effectElements[i], t.effectElements[i].propertyGroup, r)) : a.push(p(t.effectElements[i], s.ef[i].ty, r, o)); function o(t) { return t === 1 ? h : e(t - 1) } var h = function (t) { for (let e = s.ef, r = 0, i = e.length; r < i;) { if (t === e[r].nm || t === e[r].mn || t === e[r].ix) return e[r].ty === 5 ? a[r] : a[r](); r += 1 } return a[0]() }; return h.propertyGroup = o, s.mn === 'ADBE Color Control' && Object.defineProperty(h, 'color', { get() { return a[0]() } }), Object.defineProperty(h, 'numProperties', { get() { return s.np } }), h.active = h.enabled = s.en !== 0, h } function p(t, e, r, i) { const s = ExpressionPropertyInterface(t.p); return t.p.setGroupProperty && t.p.setGroupProperty(i), function () { return e === 10 ? r.comp.compInterface(t.p.v) : s() } } return { createEffectsInterface(s, t) { if (s.effectsManager) { let e; const a = []; const r = s.data.ef; const i = s.effectsManager.effectElements.length; for (e = 0; e < i; e += 1)a.push(l(r[e], s.effectsManager.effectElements[e], t, s)); return function (t) { for (let e = s.data.ef || [], r = 0, i = e.length; r < i;) { if (t === e[r].nm || t === e[r].mn || t === e[r].ix) return a[r]; r += 1 } } } } } }()); var MaskManagerInterface = (function () { function a(t, e) { this._mask = t, this._data = e }Object.defineProperty(a.prototype, 'maskPath', { get() { return this._mask.prop.k && this._mask.prop.getValue(), this._mask.prop } }), Object.defineProperty(a.prototype, 'maskOpacity', { get() { return this._mask.op.k && this._mask.op.getValue(), 100 * this._mask.op.v } }); return function (e, t) { let r; const i = createSizedArray(e.viewData.length); const s = e.viewData.length; for (r = 0; r < s; r += 1)i[r] = new a(e.viewData[r], e.masksProperties[r]); return function (t) { for (r = 0; r < s;) { if (e.masksProperties[r].nm === t) return i[r]; r += 1 } } } }()); var ExpressionPropertyInterface = (function () { const s = { pv: 0, v: 0, mult: 1 }; const n = { pv: [0, 0, 0], v: [0, 0, 0], mult: 1 }; function o(i, s, a) { Object.defineProperty(i, 'velocity', { get() { return s.getVelocityAtTime(s.comp.currentFrame) } }), i.numKeys = s.keyframes ? s.keyframes.length : 0, i.key = function (t) { if (i.numKeys) { let e = ''; e = 's' in s.keyframes[t - 1] ? s.keyframes[t - 1].s : 'e' in s.keyframes[t - 2] ? s.keyframes[t - 2].e : s.keyframes[t - 2].s; const r = a === 'unidimensional' ? new Number(e) : ({ ...e }); return r.time = s.keyframes[t - 1].t / s.elem.comp.globalData.frameRate, r } return 0 }, i.valueAtTime = s.getValueAtTime, i.speedAtTime = s.getSpeedAtTime, i.velocityAtTime = s.getVelocityAtTime, i.propertyGroup = s.propertyGroup } function e() { return s } return function (t) { return t ? t.propType === 'unidimensional' ? (function (t) { t && 'pv' in t || (t = s); const e = 1 / t.mult; let r = t.pv * e; let i = new Number(r); return i.value = r, o(i, t, 'unidimensional'), function () { return t.k && t.getValue(), r = t.v * e, i.value !== r && ((i = new Number(r)).value = r, o(i, t, 'unidimensional')), i } }(t)) : (function (e) { e && 'pv' in e || (e = n); const r = 1 / e.mult; const i = e.pv.length; const s = createTypedArray('float32', i); const a = createTypedArray('float32', i); return s.value = a, o(s, e, 'multidimensional'), function () { e.k && e.getValue(); for (let t = 0; t < i; t += 1)s[t] = a[t] = e.v[t] * r; return s } }(t)) : e } }()); let r5; let s5; function SliderEffect(t, e, r) { this.p = PropertyFactory.getProp(e, t.v, 0, 0, r) } function AngleEffect(t, e, r) { this.p = PropertyFactory.getProp(e, t.v, 0, 0, r) } function ColorEffect(t, e, r) { this.p = PropertyFactory.getProp(e, t.v, 1, 0, r) } function PointEffect(t, e, r) { this.p = PropertyFactory.getProp(e, t.v, 1, 0, r) } function LayerIndexEffect(t, e, r) { this.p = PropertyFactory.getProp(e, t.v, 0, 0, r) } function MaskIndexEffect(t, e, r) { this.p = PropertyFactory.getProp(e, t.v, 0, 0, r) } function CheckboxEffect(t, e, r) { this.p = PropertyFactory.getProp(e, t.v, 0, 0, r) } function NoValueEffect() { this.p = {} } function EffectsManager() {} function EffectsManager(t, e) { const r = t.ef || []; this.effectElements = []; let i; let s; const a = r.length; for (i = 0; i < a; i++)s = new GroupEffect(r[i], e), this.effectElements.push(s) } function GroupEffect(t, e) { this.init(t, e) }r5 = (function () { function r(t, e) { return this.textIndex = t + 1, this.textTotal = e, this.v = this.getValue() * this.mult, this.v } return function (t, e) { this.pv = 1, this.comp = t.comp, this.elem = t, this.mult = 0.01, this.propType = 'textSelector', this.textTotal = e.totalChars, this.selectorValue = 100, this.lastValue = [1, 1, 1], this.k = !0, this.x = !0, this.getValue = ExpressionManager.initiateExpression.bind(this)(t, e, this), this.getMult = r, this.getVelocityAtTime = expressionHelpers.getVelocityAtTime, this.kf ? this.getValueAtTime = expressionHelpers.getValueAtTime.bind(this) : this.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(this), this.setGroupProperty = expressionHelpers.setGroupProperty } }()), s5 = TextSelectorProp.getTextSelectorProp, TextSelectorProp.getTextSelectorProp = function (t, e, r) { return e.t === 1 ? new r5(t, e, r) : s5(t, e, r) }, extendPrototype([DynamicPropertyContainer], GroupEffect), GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties, GroupEffect.prototype.init = function (t, e) { this.data = t, this.effectElements = [], this.initDynamicPropertyContainer(e); let r; let i; const s = this.data.ef.length; const a = this.data.ef; for (r = 0; r < s; r += 1) { switch (i = null, a[r].ty) { case 0: i = new SliderEffect(a[r], e, this); break; case 1: i = new AngleEffect(a[r], e, this); break; case 2: i = new ColorEffect(a[r], e, this); break; case 3: i = new PointEffect(a[r], e, this); break; case 4: case 7: i = new CheckboxEffect(a[r], e, this); break; case 10: i = new LayerIndexEffect(a[r], e, this); break; case 11: i = new MaskIndexEffect(a[r], e, this); break; case 5: i = new EffectsManager(a[r], e, this); break; default: i = new NoValueEffect(a[r], e, this) }i && this.effectElements.push(i) } }; const lottie = {}; const _isFrozen = !1; function setLocationHref(t) { locationHref = t } function searchAnimations() { !0 === standalone ? animationManager.searchAnimations(animationData, standalone, renderer) : animationManager.searchAnimations() } function setSubframeRendering(t) { subframeEnabled = t } function loadAnimation(t) { return !0 === standalone && (t.animationData = JSON.parse(animationData)), animationManager.loadAnimation(t) } function setQuality(t) { if (typeof t === 'string') switch (t) { case 'high': defaultCurveSegments = 200; break; case 'medium': defaultCurveSegments = 50; break; case 'low': defaultCurveSegments = 10 } else !isNaN(t) && t > 1 && (defaultCurveSegments = t); roundValues(!(defaultCurveSegments >= 50)) } function inBrowser() { return typeof navigator !== 'undefined' } function installPlugin(t, e) { t === 'expressions' && (expressionsPlugin = e) } function getFactory(t) { switch (t) { case 'propertyFactory': return PropertyFactory; case 'shapePropertyFactory': return ShapePropertyFactory; case 'matrix': return Matrix } } function checkReady() { document.readyState === 'complete' && (clearInterval(readyStateCheckInterval), searchAnimations()) } function getQueryVariable(t) { for (let e = queryString.split('&'), r = 0; r < e.length; r++) { const i = e[r].split('='); if (decodeURIComponent(i[0]) == t) return decodeURIComponent(i[1]) } }lottie.play = animationManager.play, lottie.pause = animationManager.pause, lottie.setLocationHref = setLocationHref, lottie.togglePause = animationManager.togglePause, lottie.setSpeed = animationManager.setSpeed, lottie.setDirection = animationManager.setDirection, lottie.stop = animationManager.stop, lottie.searchAnimations = searchAnimations, lottie.registerAnimation = animationManager.registerAnimation, lottie.loadAnimation = loadAnimation, lottie.setSubframeRendering = setSubframeRendering, lottie.resize = animationManager.resize, lottie.goToAndStop = animationManager.goToAndStop, lottie.destroy = animationManager.destroy, lottie.setQuality = setQuality, lottie.inBrowser = inBrowser, lottie.installPlugin = installPlugin, lottie.freeze = animationManager.freeze, lottie.unfreeze = animationManager.unfreeze, lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations, lottie.__getFactory = getFactory, lottie.version = '5.6.6'; var standalone = '__[STANDALONE]__'; var animationData = '__[ANIMATIONDATA]__'; var renderer = ''; if (standalone) { const scripts = document.getElementsByTagName('script'); const index = scripts.length - 1; const myScript = scripts[index] || { src: '' }; var queryString = myScript.src.replace(/^[^\?]+\??/, ''); renderer = getQueryVariable('renderer') } var readyStateCheckInterval = setInterval(checkReady, 100)
  return lottie
}
